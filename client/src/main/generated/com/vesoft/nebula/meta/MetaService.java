/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package com.vesoft.nebula.meta;

import org.apache.commons.lang.builder.HashCodeBuilder;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import java.util.BitSet;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.facebook.thrift.*;
import com.facebook.thrift.async.*;
import com.facebook.thrift.meta_data.*;
import com.facebook.thrift.server.*;
import com.facebook.thrift.transport.*;
import com.facebook.thrift.protocol.*;

@SuppressWarnings({ "unused", "serial" })
public class MetaService {

  public interface Iface {

    public ExecResp createSpace(CreateSpaceReq req) throws TException;

    public ExecResp dropSpace(DropSpaceReq req) throws TException;

    public GetSpaceResp getSpace(GetSpaceReq req) throws TException;

    public ListSpacesResp listSpaces(ListSpacesReq req) throws TException;

    public ExecResp createTag(CreateTagReq req) throws TException;

    public ExecResp alterTag(AlterTagReq req) throws TException;

    public ExecResp dropTag(DropTagReq req) throws TException;

    public GetTagResp getTag(GetTagReq req) throws TException;

    public ListTagsResp listTags(ListTagsReq req) throws TException;

    public ExecResp createEdge(CreateEdgeReq req) throws TException;

    public ExecResp alterEdge(AlterEdgeReq req) throws TException;

    public ExecResp dropEdge(DropEdgeReq req) throws TException;

    public GetEdgeResp getEdge(GetEdgeReq req) throws TException;

    public ListEdgesResp listEdges(ListEdgesReq req) throws TException;

    public ListHostsResp listHosts(ListHostsReq req) throws TException;

    public GetPartsAllocResp getPartsAlloc(GetPartsAllocReq req) throws TException;

    public ListPartsResp listParts(ListPartsReq req) throws TException;

    public ExecResp multiPut(MultiPutReq req) throws TException;

    public GetResp get(GetReq req) throws TException;

    public MultiGetResp multiGet(MultiGetReq req) throws TException;

    public ExecResp remove(RemoveReq req) throws TException;

    public ExecResp removeRange(RemoveRangeReq req) throws TException;

    public ScanResp scan(ScanReq req) throws TException;

    public ExecResp createTagIndex(CreateTagIndexReq req) throws TException;

    public ExecResp dropTagIndex(DropTagIndexReq req) throws TException;

    public GetTagIndexResp getTagIndex(GetTagIndexReq req) throws TException;

    public ListTagIndexesResp listTagIndexes(ListTagIndexesReq req) throws TException;

    public ExecResp rebuildTagIndex(RebuildIndexReq req) throws TException;

    public ListIndexStatusResp listTagIndexStatus(ListIndexStatusReq req) throws TException;

    public ExecResp createEdgeIndex(CreateEdgeIndexReq req) throws TException;

    public ExecResp dropEdgeIndex(DropEdgeIndexReq req) throws TException;

    public GetEdgeIndexResp getEdgeIndex(GetEdgeIndexReq req) throws TException;

    public ListEdgeIndexesResp listEdgeIndexes(ListEdgeIndexesReq req) throws TException;

    public ExecResp rebuildEdgeIndex(RebuildIndexReq req) throws TException;

    public ListIndexStatusResp listEdgeIndexStatus(ListIndexStatusReq req) throws TException;

    public ExecResp createUser(CreateUserReq req) throws TException;

    public ExecResp dropUser(DropUserReq req) throws TException;

    public ExecResp alterUser(AlterUserReq req) throws TException;

    public ExecResp grantRole(GrantRoleReq req) throws TException;

    public ExecResp revokeRole(RevokeRoleReq req) throws TException;

    public ListUsersResp listUsers(ListUsersReq req) throws TException;

    public ListRolesResp listRoles(ListRolesReq req) throws TException;

    public ListRolesResp getUserRoles(GetUserRolesReq req) throws TException;

    public ExecResp changePassword(ChangePasswordReq req) throws TException;

    public HBResp heartBeat(HBReq req) throws TException;

    public BalanceResp balance(BalanceReq req) throws TException;

    public ExecResp leaderBalance(LeaderBalanceReq req) throws TException;

    public ExecResp regConfig(RegConfigReq req) throws TException;

    public GetConfigResp getConfig(GetConfigReq req) throws TException;

    public ExecResp setConfig(SetConfigReq req) throws TException;

    public ListConfigsResp listConfigs(ListConfigsReq req) throws TException;

    public ExecResp createSnapshot(CreateSnapshotReq req) throws TException;

    public ExecResp dropSnapshot(DropSnapshotReq req) throws TException;

    public ListSnapshotsResp listSnapshots(ListSnapshotsReq req) throws TException;

    public AdminJobResp runAdminJob(AdminJobReq req) throws TException;

  }

  public interface AsyncIface {

    public void createSpace(CreateSpaceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropSpace(DropSpaceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getSpace(GetSpaceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listSpaces(ListSpacesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createTag(CreateTagReq req, AsyncMethodCallback resultHandler) throws TException;

    public void alterTag(AlterTagReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropTag(DropTagReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getTag(GetTagReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listTags(ListTagsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createEdge(CreateEdgeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void alterEdge(AlterEdgeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropEdge(DropEdgeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getEdge(GetEdgeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listEdges(ListEdgesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listHosts(ListHostsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getPartsAlloc(GetPartsAllocReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listParts(ListPartsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void multiPut(MultiPutReq req, AsyncMethodCallback resultHandler) throws TException;

    public void get(GetReq req, AsyncMethodCallback resultHandler) throws TException;

    public void multiGet(MultiGetReq req, AsyncMethodCallback resultHandler) throws TException;

    public void remove(RemoveReq req, AsyncMethodCallback resultHandler) throws TException;

    public void removeRange(RemoveRangeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void scan(ScanReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createTagIndex(CreateTagIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropTagIndex(DropTagIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getTagIndex(GetTagIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listTagIndexes(ListTagIndexesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void rebuildTagIndex(RebuildIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listTagIndexStatus(ListIndexStatusReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createEdgeIndex(CreateEdgeIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropEdgeIndex(DropEdgeIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getEdgeIndex(GetEdgeIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listEdgeIndexes(ListEdgeIndexesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void rebuildEdgeIndex(RebuildIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listEdgeIndexStatus(ListIndexStatusReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createUser(CreateUserReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropUser(DropUserReq req, AsyncMethodCallback resultHandler) throws TException;

    public void alterUser(AlterUserReq req, AsyncMethodCallback resultHandler) throws TException;

    public void grantRole(GrantRoleReq req, AsyncMethodCallback resultHandler) throws TException;

    public void revokeRole(RevokeRoleReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listUsers(ListUsersReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listRoles(ListRolesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getUserRoles(GetUserRolesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void changePassword(ChangePasswordReq req, AsyncMethodCallback resultHandler) throws TException;

    public void heartBeat(HBReq req, AsyncMethodCallback resultHandler) throws TException;

    public void balance(BalanceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void leaderBalance(LeaderBalanceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void regConfig(RegConfigReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getConfig(GetConfigReq req, AsyncMethodCallback resultHandler) throws TException;

    public void setConfig(SetConfigReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listConfigs(ListConfigsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createSnapshot(CreateSnapshotReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropSnapshot(DropSnapshotReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listSnapshots(ListSnapshotsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void runAdminJob(AdminJobReq req, AsyncMethodCallback resultHandler) throws TException;

  }

  public static class Client extends EventHandlerBase implements Iface, TClientIf {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    @Override
    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    @Override
    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public ExecResp createSpace(CreateSpaceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createSpace", null);
      this.setContextStack(ctx);
      send_createSpace(req);
      return recv_createSpace();
    }

    public void send_createSpace(CreateSpaceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createSpace", null);
      oprot_.writeMessageBegin(new TMessage("createSpace", TMessageType.CALL, seqid_));
      createSpace_args args = new createSpace_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createSpace", args);
      return;
    }

    public ExecResp recv_createSpace() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createSpace");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createSpace_result result = new createSpace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createSpace", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createSpace failed: unknown result");
    }

    public ExecResp dropSpace(DropSpaceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropSpace", null);
      this.setContextStack(ctx);
      send_dropSpace(req);
      return recv_dropSpace();
    }

    public void send_dropSpace(DropSpaceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropSpace", null);
      oprot_.writeMessageBegin(new TMessage("dropSpace", TMessageType.CALL, seqid_));
      dropSpace_args args = new dropSpace_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropSpace", args);
      return;
    }

    public ExecResp recv_dropSpace() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropSpace");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropSpace_result result = new dropSpace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropSpace", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropSpace failed: unknown result");
    }

    public GetSpaceResp getSpace(GetSpaceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getSpace", null);
      this.setContextStack(ctx);
      send_getSpace(req);
      return recv_getSpace();
    }

    public void send_getSpace(GetSpaceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getSpace", null);
      oprot_.writeMessageBegin(new TMessage("getSpace", TMessageType.CALL, seqid_));
      getSpace_args args = new getSpace_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getSpace", args);
      return;
    }

    public GetSpaceResp recv_getSpace() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getSpace");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getSpace_result result = new getSpace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getSpace", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getSpace failed: unknown result");
    }

    public ListSpacesResp listSpaces(ListSpacesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listSpaces", null);
      this.setContextStack(ctx);
      send_listSpaces(req);
      return recv_listSpaces();
    }

    public void send_listSpaces(ListSpacesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listSpaces", null);
      oprot_.writeMessageBegin(new TMessage("listSpaces", TMessageType.CALL, seqid_));
      listSpaces_args args = new listSpaces_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listSpaces", args);
      return;
    }

    public ListSpacesResp recv_listSpaces() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listSpaces");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listSpaces_result result = new listSpaces_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listSpaces", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listSpaces failed: unknown result");
    }

    public ExecResp createTag(CreateTagReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createTag", null);
      this.setContextStack(ctx);
      send_createTag(req);
      return recv_createTag();
    }

    public void send_createTag(CreateTagReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createTag", null);
      oprot_.writeMessageBegin(new TMessage("createTag", TMessageType.CALL, seqid_));
      createTag_args args = new createTag_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createTag", args);
      return;
    }

    public ExecResp recv_createTag() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createTag");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createTag_result result = new createTag_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createTag", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createTag failed: unknown result");
    }

    public ExecResp alterTag(AlterTagReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.alterTag", null);
      this.setContextStack(ctx);
      send_alterTag(req);
      return recv_alterTag();
    }

    public void send_alterTag(AlterTagReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.alterTag", null);
      oprot_.writeMessageBegin(new TMessage("alterTag", TMessageType.CALL, seqid_));
      alterTag_args args = new alterTag_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.alterTag", args);
      return;
    }

    public ExecResp recv_alterTag() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.alterTag");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      alterTag_result result = new alterTag_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.alterTag", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "alterTag failed: unknown result");
    }

    public ExecResp dropTag(DropTagReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropTag", null);
      this.setContextStack(ctx);
      send_dropTag(req);
      return recv_dropTag();
    }

    public void send_dropTag(DropTagReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropTag", null);
      oprot_.writeMessageBegin(new TMessage("dropTag", TMessageType.CALL, seqid_));
      dropTag_args args = new dropTag_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropTag", args);
      return;
    }

    public ExecResp recv_dropTag() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropTag");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropTag_result result = new dropTag_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropTag", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropTag failed: unknown result");
    }

    public GetTagResp getTag(GetTagReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getTag", null);
      this.setContextStack(ctx);
      send_getTag(req);
      return recv_getTag();
    }

    public void send_getTag(GetTagReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getTag", null);
      oprot_.writeMessageBegin(new TMessage("getTag", TMessageType.CALL, seqid_));
      getTag_args args = new getTag_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getTag", args);
      return;
    }

    public GetTagResp recv_getTag() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getTag");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getTag_result result = new getTag_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getTag", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTag failed: unknown result");
    }

    public ListTagsResp listTags(ListTagsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listTags", null);
      this.setContextStack(ctx);
      send_listTags(req);
      return recv_listTags();
    }

    public void send_listTags(ListTagsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listTags", null);
      oprot_.writeMessageBegin(new TMessage("listTags", TMessageType.CALL, seqid_));
      listTags_args args = new listTags_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listTags", args);
      return;
    }

    public ListTagsResp recv_listTags() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listTags");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listTags_result result = new listTags_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listTags", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listTags failed: unknown result");
    }

    public ExecResp createEdge(CreateEdgeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createEdge", null);
      this.setContextStack(ctx);
      send_createEdge(req);
      return recv_createEdge();
    }

    public void send_createEdge(CreateEdgeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createEdge", null);
      oprot_.writeMessageBegin(new TMessage("createEdge", TMessageType.CALL, seqid_));
      createEdge_args args = new createEdge_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createEdge", args);
      return;
    }

    public ExecResp recv_createEdge() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createEdge");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createEdge_result result = new createEdge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createEdge", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createEdge failed: unknown result");
    }

    public ExecResp alterEdge(AlterEdgeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.alterEdge", null);
      this.setContextStack(ctx);
      send_alterEdge(req);
      return recv_alterEdge();
    }

    public void send_alterEdge(AlterEdgeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.alterEdge", null);
      oprot_.writeMessageBegin(new TMessage("alterEdge", TMessageType.CALL, seqid_));
      alterEdge_args args = new alterEdge_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.alterEdge", args);
      return;
    }

    public ExecResp recv_alterEdge() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.alterEdge");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      alterEdge_result result = new alterEdge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.alterEdge", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "alterEdge failed: unknown result");
    }

    public ExecResp dropEdge(DropEdgeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropEdge", null);
      this.setContextStack(ctx);
      send_dropEdge(req);
      return recv_dropEdge();
    }

    public void send_dropEdge(DropEdgeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropEdge", null);
      oprot_.writeMessageBegin(new TMessage("dropEdge", TMessageType.CALL, seqid_));
      dropEdge_args args = new dropEdge_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropEdge", args);
      return;
    }

    public ExecResp recv_dropEdge() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropEdge");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropEdge_result result = new dropEdge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropEdge", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropEdge failed: unknown result");
    }

    public GetEdgeResp getEdge(GetEdgeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getEdge", null);
      this.setContextStack(ctx);
      send_getEdge(req);
      return recv_getEdge();
    }

    public void send_getEdge(GetEdgeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getEdge", null);
      oprot_.writeMessageBegin(new TMessage("getEdge", TMessageType.CALL, seqid_));
      getEdge_args args = new getEdge_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getEdge", args);
      return;
    }

    public GetEdgeResp recv_getEdge() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getEdge");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getEdge_result result = new getEdge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getEdge", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getEdge failed: unknown result");
    }

    public ListEdgesResp listEdges(ListEdgesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listEdges", null);
      this.setContextStack(ctx);
      send_listEdges(req);
      return recv_listEdges();
    }

    public void send_listEdges(ListEdgesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listEdges", null);
      oprot_.writeMessageBegin(new TMessage("listEdges", TMessageType.CALL, seqid_));
      listEdges_args args = new listEdges_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listEdges", args);
      return;
    }

    public ListEdgesResp recv_listEdges() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listEdges");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listEdges_result result = new listEdges_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listEdges", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listEdges failed: unknown result");
    }

    public ListHostsResp listHosts(ListHostsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listHosts", null);
      this.setContextStack(ctx);
      send_listHosts(req);
      return recv_listHosts();
    }

    public void send_listHosts(ListHostsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listHosts", null);
      oprot_.writeMessageBegin(new TMessage("listHosts", TMessageType.CALL, seqid_));
      listHosts_args args = new listHosts_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listHosts", args);
      return;
    }

    public ListHostsResp recv_listHosts() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listHosts");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listHosts_result result = new listHosts_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listHosts", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listHosts failed: unknown result");
    }

    public GetPartsAllocResp getPartsAlloc(GetPartsAllocReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getPartsAlloc", null);
      this.setContextStack(ctx);
      send_getPartsAlloc(req);
      return recv_getPartsAlloc();
    }

    public void send_getPartsAlloc(GetPartsAllocReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getPartsAlloc", null);
      oprot_.writeMessageBegin(new TMessage("getPartsAlloc", TMessageType.CALL, seqid_));
      getPartsAlloc_args args = new getPartsAlloc_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getPartsAlloc", args);
      return;
    }

    public GetPartsAllocResp recv_getPartsAlloc() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getPartsAlloc");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getPartsAlloc_result result = new getPartsAlloc_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getPartsAlloc", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getPartsAlloc failed: unknown result");
    }

    public ListPartsResp listParts(ListPartsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listParts", null);
      this.setContextStack(ctx);
      send_listParts(req);
      return recv_listParts();
    }

    public void send_listParts(ListPartsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listParts", null);
      oprot_.writeMessageBegin(new TMessage("listParts", TMessageType.CALL, seqid_));
      listParts_args args = new listParts_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listParts", args);
      return;
    }

    public ListPartsResp recv_listParts() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listParts");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listParts_result result = new listParts_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listParts", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listParts failed: unknown result");
    }

    public ExecResp multiPut(MultiPutReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.multiPut", null);
      this.setContextStack(ctx);
      send_multiPut(req);
      return recv_multiPut();
    }

    public void send_multiPut(MultiPutReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.multiPut", null);
      oprot_.writeMessageBegin(new TMessage("multiPut", TMessageType.CALL, seqid_));
      multiPut_args args = new multiPut_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.multiPut", args);
      return;
    }

    public ExecResp recv_multiPut() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.multiPut");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      multiPut_result result = new multiPut_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.multiPut", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiPut failed: unknown result");
    }

    public GetResp get(GetReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.get", null);
      this.setContextStack(ctx);
      send_get(req);
      return recv_get();
    }

    public void send_get(GetReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.get", null);
      oprot_.writeMessageBegin(new TMessage("get", TMessageType.CALL, seqid_));
      get_args args = new get_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.get", args);
      return;
    }

    public GetResp recv_get() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.get");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_result result = new get_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.get", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result");
    }

    public MultiGetResp multiGet(MultiGetReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.multiGet", null);
      this.setContextStack(ctx);
      send_multiGet(req);
      return recv_multiGet();
    }

    public void send_multiGet(MultiGetReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.multiGet", null);
      oprot_.writeMessageBegin(new TMessage("multiGet", TMessageType.CALL, seqid_));
      multiGet_args args = new multiGet_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.multiGet", args);
      return;
    }

    public MultiGetResp recv_multiGet() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.multiGet");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      multiGet_result result = new multiGet_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.multiGet", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiGet failed: unknown result");
    }

    public ExecResp remove(RemoveReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.remove", null);
      this.setContextStack(ctx);
      send_remove(req);
      return recv_remove();
    }

    public void send_remove(RemoveReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.remove", null);
      oprot_.writeMessageBegin(new TMessage("remove", TMessageType.CALL, seqid_));
      remove_args args = new remove_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.remove", args);
      return;
    }

    public ExecResp recv_remove() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.remove");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      remove_result result = new remove_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.remove", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "remove failed: unknown result");
    }

    public ExecResp removeRange(RemoveRangeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.removeRange", null);
      this.setContextStack(ctx);
      send_removeRange(req);
      return recv_removeRange();
    }

    public void send_removeRange(RemoveRangeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.removeRange", null);
      oprot_.writeMessageBegin(new TMessage("removeRange", TMessageType.CALL, seqid_));
      removeRange_args args = new removeRange_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.removeRange", args);
      return;
    }

    public ExecResp recv_removeRange() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.removeRange");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      removeRange_result result = new removeRange_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.removeRange", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "removeRange failed: unknown result");
    }

    public ScanResp scan(ScanReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.scan", null);
      this.setContextStack(ctx);
      send_scan(req);
      return recv_scan();
    }

    public void send_scan(ScanReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.scan", null);
      oprot_.writeMessageBegin(new TMessage("scan", TMessageType.CALL, seqid_));
      scan_args args = new scan_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.scan", args);
      return;
    }

    public ScanResp recv_scan() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.scan");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      scan_result result = new scan_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.scan", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "scan failed: unknown result");
    }

    public ExecResp createTagIndex(CreateTagIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createTagIndex", null);
      this.setContextStack(ctx);
      send_createTagIndex(req);
      return recv_createTagIndex();
    }

    public void send_createTagIndex(CreateTagIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createTagIndex", null);
      oprot_.writeMessageBegin(new TMessage("createTagIndex", TMessageType.CALL, seqid_));
      createTagIndex_args args = new createTagIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createTagIndex", args);
      return;
    }

    public ExecResp recv_createTagIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createTagIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createTagIndex_result result = new createTagIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createTagIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createTagIndex failed: unknown result");
    }

    public ExecResp dropTagIndex(DropTagIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropTagIndex", null);
      this.setContextStack(ctx);
      send_dropTagIndex(req);
      return recv_dropTagIndex();
    }

    public void send_dropTagIndex(DropTagIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropTagIndex", null);
      oprot_.writeMessageBegin(new TMessage("dropTagIndex", TMessageType.CALL, seqid_));
      dropTagIndex_args args = new dropTagIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropTagIndex", args);
      return;
    }

    public ExecResp recv_dropTagIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropTagIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropTagIndex_result result = new dropTagIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropTagIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropTagIndex failed: unknown result");
    }

    public GetTagIndexResp getTagIndex(GetTagIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getTagIndex", null);
      this.setContextStack(ctx);
      send_getTagIndex(req);
      return recv_getTagIndex();
    }

    public void send_getTagIndex(GetTagIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getTagIndex", null);
      oprot_.writeMessageBegin(new TMessage("getTagIndex", TMessageType.CALL, seqid_));
      getTagIndex_args args = new getTagIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getTagIndex", args);
      return;
    }

    public GetTagIndexResp recv_getTagIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getTagIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getTagIndex_result result = new getTagIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getTagIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTagIndex failed: unknown result");
    }

    public ListTagIndexesResp listTagIndexes(ListTagIndexesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listTagIndexes", null);
      this.setContextStack(ctx);
      send_listTagIndexes(req);
      return recv_listTagIndexes();
    }

    public void send_listTagIndexes(ListTagIndexesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listTagIndexes", null);
      oprot_.writeMessageBegin(new TMessage("listTagIndexes", TMessageType.CALL, seqid_));
      listTagIndexes_args args = new listTagIndexes_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listTagIndexes", args);
      return;
    }

    public ListTagIndexesResp recv_listTagIndexes() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listTagIndexes");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listTagIndexes_result result = new listTagIndexes_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listTagIndexes", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listTagIndexes failed: unknown result");
    }

    public ExecResp rebuildTagIndex(RebuildIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.rebuildTagIndex", null);
      this.setContextStack(ctx);
      send_rebuildTagIndex(req);
      return recv_rebuildTagIndex();
    }

    public void send_rebuildTagIndex(RebuildIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.rebuildTagIndex", null);
      oprot_.writeMessageBegin(new TMessage("rebuildTagIndex", TMessageType.CALL, seqid_));
      rebuildTagIndex_args args = new rebuildTagIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.rebuildTagIndex", args);
      return;
    }

    public ExecResp recv_rebuildTagIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.rebuildTagIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      rebuildTagIndex_result result = new rebuildTagIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.rebuildTagIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "rebuildTagIndex failed: unknown result");
    }

    public ListIndexStatusResp listTagIndexStatus(ListIndexStatusReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listTagIndexStatus", null);
      this.setContextStack(ctx);
      send_listTagIndexStatus(req);
      return recv_listTagIndexStatus();
    }

    public void send_listTagIndexStatus(ListIndexStatusReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listTagIndexStatus", null);
      oprot_.writeMessageBegin(new TMessage("listTagIndexStatus", TMessageType.CALL, seqid_));
      listTagIndexStatus_args args = new listTagIndexStatus_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listTagIndexStatus", args);
      return;
    }

    public ListIndexStatusResp recv_listTagIndexStatus() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listTagIndexStatus");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listTagIndexStatus_result result = new listTagIndexStatus_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listTagIndexStatus", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listTagIndexStatus failed: unknown result");
    }

    public ExecResp createEdgeIndex(CreateEdgeIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createEdgeIndex", null);
      this.setContextStack(ctx);
      send_createEdgeIndex(req);
      return recv_createEdgeIndex();
    }

    public void send_createEdgeIndex(CreateEdgeIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createEdgeIndex", null);
      oprot_.writeMessageBegin(new TMessage("createEdgeIndex", TMessageType.CALL, seqid_));
      createEdgeIndex_args args = new createEdgeIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createEdgeIndex", args);
      return;
    }

    public ExecResp recv_createEdgeIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createEdgeIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createEdgeIndex_result result = new createEdgeIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createEdgeIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createEdgeIndex failed: unknown result");
    }

    public ExecResp dropEdgeIndex(DropEdgeIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropEdgeIndex", null);
      this.setContextStack(ctx);
      send_dropEdgeIndex(req);
      return recv_dropEdgeIndex();
    }

    public void send_dropEdgeIndex(DropEdgeIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropEdgeIndex", null);
      oprot_.writeMessageBegin(new TMessage("dropEdgeIndex", TMessageType.CALL, seqid_));
      dropEdgeIndex_args args = new dropEdgeIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropEdgeIndex", args);
      return;
    }

    public ExecResp recv_dropEdgeIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropEdgeIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropEdgeIndex_result result = new dropEdgeIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropEdgeIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropEdgeIndex failed: unknown result");
    }

    public GetEdgeIndexResp getEdgeIndex(GetEdgeIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getEdgeIndex", null);
      this.setContextStack(ctx);
      send_getEdgeIndex(req);
      return recv_getEdgeIndex();
    }

    public void send_getEdgeIndex(GetEdgeIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getEdgeIndex", null);
      oprot_.writeMessageBegin(new TMessage("getEdgeIndex", TMessageType.CALL, seqid_));
      getEdgeIndex_args args = new getEdgeIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getEdgeIndex", args);
      return;
    }

    public GetEdgeIndexResp recv_getEdgeIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getEdgeIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getEdgeIndex_result result = new getEdgeIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getEdgeIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getEdgeIndex failed: unknown result");
    }

    public ListEdgeIndexesResp listEdgeIndexes(ListEdgeIndexesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listEdgeIndexes", null);
      this.setContextStack(ctx);
      send_listEdgeIndexes(req);
      return recv_listEdgeIndexes();
    }

    public void send_listEdgeIndexes(ListEdgeIndexesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listEdgeIndexes", null);
      oprot_.writeMessageBegin(new TMessage("listEdgeIndexes", TMessageType.CALL, seqid_));
      listEdgeIndexes_args args = new listEdgeIndexes_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listEdgeIndexes", args);
      return;
    }

    public ListEdgeIndexesResp recv_listEdgeIndexes() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listEdgeIndexes");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listEdgeIndexes_result result = new listEdgeIndexes_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listEdgeIndexes", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listEdgeIndexes failed: unknown result");
    }

    public ExecResp rebuildEdgeIndex(RebuildIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.rebuildEdgeIndex", null);
      this.setContextStack(ctx);
      send_rebuildEdgeIndex(req);
      return recv_rebuildEdgeIndex();
    }

    public void send_rebuildEdgeIndex(RebuildIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.rebuildEdgeIndex", null);
      oprot_.writeMessageBegin(new TMessage("rebuildEdgeIndex", TMessageType.CALL, seqid_));
      rebuildEdgeIndex_args args = new rebuildEdgeIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.rebuildEdgeIndex", args);
      return;
    }

    public ExecResp recv_rebuildEdgeIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.rebuildEdgeIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      rebuildEdgeIndex_result result = new rebuildEdgeIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.rebuildEdgeIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "rebuildEdgeIndex failed: unknown result");
    }

    public ListIndexStatusResp listEdgeIndexStatus(ListIndexStatusReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listEdgeIndexStatus", null);
      this.setContextStack(ctx);
      send_listEdgeIndexStatus(req);
      return recv_listEdgeIndexStatus();
    }

    public void send_listEdgeIndexStatus(ListIndexStatusReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listEdgeIndexStatus", null);
      oprot_.writeMessageBegin(new TMessage("listEdgeIndexStatus", TMessageType.CALL, seqid_));
      listEdgeIndexStatus_args args = new listEdgeIndexStatus_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listEdgeIndexStatus", args);
      return;
    }

    public ListIndexStatusResp recv_listEdgeIndexStatus() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listEdgeIndexStatus");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listEdgeIndexStatus_result result = new listEdgeIndexStatus_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listEdgeIndexStatus", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listEdgeIndexStatus failed: unknown result");
    }

    public ExecResp createUser(CreateUserReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createUser", null);
      this.setContextStack(ctx);
      send_createUser(req);
      return recv_createUser();
    }

    public void send_createUser(CreateUserReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createUser", null);
      oprot_.writeMessageBegin(new TMessage("createUser", TMessageType.CALL, seqid_));
      createUser_args args = new createUser_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createUser", args);
      return;
    }

    public ExecResp recv_createUser() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createUser");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createUser_result result = new createUser_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createUser", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createUser failed: unknown result");
    }

    public ExecResp dropUser(DropUserReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropUser", null);
      this.setContextStack(ctx);
      send_dropUser(req);
      return recv_dropUser();
    }

    public void send_dropUser(DropUserReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropUser", null);
      oprot_.writeMessageBegin(new TMessage("dropUser", TMessageType.CALL, seqid_));
      dropUser_args args = new dropUser_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropUser", args);
      return;
    }

    public ExecResp recv_dropUser() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropUser");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropUser_result result = new dropUser_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropUser", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropUser failed: unknown result");
    }

    public ExecResp alterUser(AlterUserReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.alterUser", null);
      this.setContextStack(ctx);
      send_alterUser(req);
      return recv_alterUser();
    }

    public void send_alterUser(AlterUserReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.alterUser", null);
      oprot_.writeMessageBegin(new TMessage("alterUser", TMessageType.CALL, seqid_));
      alterUser_args args = new alterUser_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.alterUser", args);
      return;
    }

    public ExecResp recv_alterUser() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.alterUser");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      alterUser_result result = new alterUser_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.alterUser", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "alterUser failed: unknown result");
    }

    public ExecResp grantRole(GrantRoleReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.grantRole", null);
      this.setContextStack(ctx);
      send_grantRole(req);
      return recv_grantRole();
    }

    public void send_grantRole(GrantRoleReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.grantRole", null);
      oprot_.writeMessageBegin(new TMessage("grantRole", TMessageType.CALL, seqid_));
      grantRole_args args = new grantRole_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.grantRole", args);
      return;
    }

    public ExecResp recv_grantRole() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.grantRole");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      grantRole_result result = new grantRole_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.grantRole", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "grantRole failed: unknown result");
    }

    public ExecResp revokeRole(RevokeRoleReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.revokeRole", null);
      this.setContextStack(ctx);
      send_revokeRole(req);
      return recv_revokeRole();
    }

    public void send_revokeRole(RevokeRoleReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.revokeRole", null);
      oprot_.writeMessageBegin(new TMessage("revokeRole", TMessageType.CALL, seqid_));
      revokeRole_args args = new revokeRole_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.revokeRole", args);
      return;
    }

    public ExecResp recv_revokeRole() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.revokeRole");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      revokeRole_result result = new revokeRole_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.revokeRole", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "revokeRole failed: unknown result");
    }

    public ListUsersResp listUsers(ListUsersReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listUsers", null);
      this.setContextStack(ctx);
      send_listUsers(req);
      return recv_listUsers();
    }

    public void send_listUsers(ListUsersReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listUsers", null);
      oprot_.writeMessageBegin(new TMessage("listUsers", TMessageType.CALL, seqid_));
      listUsers_args args = new listUsers_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listUsers", args);
      return;
    }

    public ListUsersResp recv_listUsers() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listUsers");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listUsers_result result = new listUsers_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listUsers", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listUsers failed: unknown result");
    }

    public ListRolesResp listRoles(ListRolesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listRoles", null);
      this.setContextStack(ctx);
      send_listRoles(req);
      return recv_listRoles();
    }

    public void send_listRoles(ListRolesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listRoles", null);
      oprot_.writeMessageBegin(new TMessage("listRoles", TMessageType.CALL, seqid_));
      listRoles_args args = new listRoles_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listRoles", args);
      return;
    }

    public ListRolesResp recv_listRoles() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listRoles");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listRoles_result result = new listRoles_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listRoles", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listRoles failed: unknown result");
    }

    public ListRolesResp getUserRoles(GetUserRolesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getUserRoles", null);
      this.setContextStack(ctx);
      send_getUserRoles(req);
      return recv_getUserRoles();
    }

    public void send_getUserRoles(GetUserRolesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getUserRoles", null);
      oprot_.writeMessageBegin(new TMessage("getUserRoles", TMessageType.CALL, seqid_));
      getUserRoles_args args = new getUserRoles_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getUserRoles", args);
      return;
    }

    public ListRolesResp recv_getUserRoles() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getUserRoles");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getUserRoles_result result = new getUserRoles_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getUserRoles", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getUserRoles failed: unknown result");
    }

    public ExecResp changePassword(ChangePasswordReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.changePassword", null);
      this.setContextStack(ctx);
      send_changePassword(req);
      return recv_changePassword();
    }

    public void send_changePassword(ChangePasswordReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.changePassword", null);
      oprot_.writeMessageBegin(new TMessage("changePassword", TMessageType.CALL, seqid_));
      changePassword_args args = new changePassword_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.changePassword", args);
      return;
    }

    public ExecResp recv_changePassword() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.changePassword");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      changePassword_result result = new changePassword_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.changePassword", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "changePassword failed: unknown result");
    }

    public HBResp heartBeat(HBReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.heartBeat", null);
      this.setContextStack(ctx);
      send_heartBeat(req);
      return recv_heartBeat();
    }

    public void send_heartBeat(HBReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.heartBeat", null);
      oprot_.writeMessageBegin(new TMessage("heartBeat", TMessageType.CALL, seqid_));
      heartBeat_args args = new heartBeat_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.heartBeat", args);
      return;
    }

    public HBResp recv_heartBeat() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.heartBeat");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      heartBeat_result result = new heartBeat_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.heartBeat", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "heartBeat failed: unknown result");
    }

    public BalanceResp balance(BalanceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.balance", null);
      this.setContextStack(ctx);
      send_balance(req);
      return recv_balance();
    }

    public void send_balance(BalanceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.balance", null);
      oprot_.writeMessageBegin(new TMessage("balance", TMessageType.CALL, seqid_));
      balance_args args = new balance_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.balance", args);
      return;
    }

    public BalanceResp recv_balance() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.balance");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      balance_result result = new balance_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.balance", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "balance failed: unknown result");
    }

    public ExecResp leaderBalance(LeaderBalanceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.leaderBalance", null);
      this.setContextStack(ctx);
      send_leaderBalance(req);
      return recv_leaderBalance();
    }

    public void send_leaderBalance(LeaderBalanceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.leaderBalance", null);
      oprot_.writeMessageBegin(new TMessage("leaderBalance", TMessageType.CALL, seqid_));
      leaderBalance_args args = new leaderBalance_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.leaderBalance", args);
      return;
    }

    public ExecResp recv_leaderBalance() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.leaderBalance");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      leaderBalance_result result = new leaderBalance_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.leaderBalance", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "leaderBalance failed: unknown result");
    }

    public ExecResp regConfig(RegConfigReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.regConfig", null);
      this.setContextStack(ctx);
      send_regConfig(req);
      return recv_regConfig();
    }

    public void send_regConfig(RegConfigReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.regConfig", null);
      oprot_.writeMessageBegin(new TMessage("regConfig", TMessageType.CALL, seqid_));
      regConfig_args args = new regConfig_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.regConfig", args);
      return;
    }

    public ExecResp recv_regConfig() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.regConfig");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      regConfig_result result = new regConfig_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.regConfig", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "regConfig failed: unknown result");
    }

    public GetConfigResp getConfig(GetConfigReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getConfig", null);
      this.setContextStack(ctx);
      send_getConfig(req);
      return recv_getConfig();
    }

    public void send_getConfig(GetConfigReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getConfig", null);
      oprot_.writeMessageBegin(new TMessage("getConfig", TMessageType.CALL, seqid_));
      getConfig_args args = new getConfig_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getConfig", args);
      return;
    }

    public GetConfigResp recv_getConfig() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getConfig");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getConfig_result result = new getConfig_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getConfig", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getConfig failed: unknown result");
    }

    public ExecResp setConfig(SetConfigReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.setConfig", null);
      this.setContextStack(ctx);
      send_setConfig(req);
      return recv_setConfig();
    }

    public void send_setConfig(SetConfigReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.setConfig", null);
      oprot_.writeMessageBegin(new TMessage("setConfig", TMessageType.CALL, seqid_));
      setConfig_args args = new setConfig_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.setConfig", args);
      return;
    }

    public ExecResp recv_setConfig() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.setConfig");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      setConfig_result result = new setConfig_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.setConfig", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "setConfig failed: unknown result");
    }

    public ListConfigsResp listConfigs(ListConfigsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listConfigs", null);
      this.setContextStack(ctx);
      send_listConfigs(req);
      return recv_listConfigs();
    }

    public void send_listConfigs(ListConfigsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listConfigs", null);
      oprot_.writeMessageBegin(new TMessage("listConfigs", TMessageType.CALL, seqid_));
      listConfigs_args args = new listConfigs_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listConfigs", args);
      return;
    }

    public ListConfigsResp recv_listConfigs() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listConfigs");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listConfigs_result result = new listConfigs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listConfigs", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listConfigs failed: unknown result");
    }

    public ExecResp createSnapshot(CreateSnapshotReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createSnapshot", null);
      this.setContextStack(ctx);
      send_createSnapshot(req);
      return recv_createSnapshot();
    }

    public void send_createSnapshot(CreateSnapshotReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createSnapshot", null);
      oprot_.writeMessageBegin(new TMessage("createSnapshot", TMessageType.CALL, seqid_));
      createSnapshot_args args = new createSnapshot_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createSnapshot", args);
      return;
    }

    public ExecResp recv_createSnapshot() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createSnapshot");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createSnapshot_result result = new createSnapshot_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createSnapshot", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createSnapshot failed: unknown result");
    }

    public ExecResp dropSnapshot(DropSnapshotReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropSnapshot", null);
      this.setContextStack(ctx);
      send_dropSnapshot(req);
      return recv_dropSnapshot();
    }

    public void send_dropSnapshot(DropSnapshotReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropSnapshot", null);
      oprot_.writeMessageBegin(new TMessage("dropSnapshot", TMessageType.CALL, seqid_));
      dropSnapshot_args args = new dropSnapshot_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropSnapshot", args);
      return;
    }

    public ExecResp recv_dropSnapshot() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropSnapshot");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropSnapshot_result result = new dropSnapshot_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropSnapshot", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropSnapshot failed: unknown result");
    }

    public ListSnapshotsResp listSnapshots(ListSnapshotsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listSnapshots", null);
      this.setContextStack(ctx);
      send_listSnapshots(req);
      return recv_listSnapshots();
    }

    public void send_listSnapshots(ListSnapshotsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listSnapshots", null);
      oprot_.writeMessageBegin(new TMessage("listSnapshots", TMessageType.CALL, seqid_));
      listSnapshots_args args = new listSnapshots_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listSnapshots", args);
      return;
    }

    public ListSnapshotsResp recv_listSnapshots() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listSnapshots");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listSnapshots_result result = new listSnapshots_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listSnapshots", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listSnapshots failed: unknown result");
    }

    public AdminJobResp runAdminJob(AdminJobReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.runAdminJob", null);
      this.setContextStack(ctx);
      send_runAdminJob(req);
      return recv_runAdminJob();
    }

    public void send_runAdminJob(AdminJobReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.runAdminJob", null);
      oprot_.writeMessageBegin(new TMessage("runAdminJob", TMessageType.CALL, seqid_));
      runAdminJob_args args = new runAdminJob_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.runAdminJob", args);
      return;
    }

    public AdminJobResp recv_runAdminJob() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.runAdminJob");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      runAdminJob_result result = new runAdminJob_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.runAdminJob", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "runAdminJob failed: unknown result");
    }

  }
  public static class AsyncClient extends TAsyncClient implements AsyncIface {
    public static class Factory implements TAsyncClientFactory<AsyncClient> {
      private TAsyncClientManager clientManager;
      private TProtocolFactory protocolFactory;
      public Factory(TAsyncClientManager clientManager, TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(TProtocolFactory protocolFactory, TAsyncClientManager clientManager, TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void createSpace(CreateSpaceReq req, AsyncMethodCallback resultHandler219) throws TException {
      checkReady();
      createSpace_call method_call = new createSpace_call(req, resultHandler219, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createSpace_call extends TAsyncMethodCall {
      private CreateSpaceReq req;
      public createSpace_call(CreateSpaceReq req, AsyncMethodCallback resultHandler220, TAsyncClient client216, TProtocolFactory protocolFactory217, TNonblockingTransport transport218) throws TException {
        super(client216, protocolFactory217, transport218, resultHandler220, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createSpace", TMessageType.CALL, 0));
        createSpace_args args = new createSpace_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createSpace();
      }
    }

    public void dropSpace(DropSpaceReq req, AsyncMethodCallback resultHandler224) throws TException {
      checkReady();
      dropSpace_call method_call = new dropSpace_call(req, resultHandler224, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropSpace_call extends TAsyncMethodCall {
      private DropSpaceReq req;
      public dropSpace_call(DropSpaceReq req, AsyncMethodCallback resultHandler225, TAsyncClient client221, TProtocolFactory protocolFactory222, TNonblockingTransport transport223) throws TException {
        super(client221, protocolFactory222, transport223, resultHandler225, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropSpace", TMessageType.CALL, 0));
        dropSpace_args args = new dropSpace_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropSpace();
      }
    }

    public void getSpace(GetSpaceReq req, AsyncMethodCallback resultHandler229) throws TException {
      checkReady();
      getSpace_call method_call = new getSpace_call(req, resultHandler229, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getSpace_call extends TAsyncMethodCall {
      private GetSpaceReq req;
      public getSpace_call(GetSpaceReq req, AsyncMethodCallback resultHandler230, TAsyncClient client226, TProtocolFactory protocolFactory227, TNonblockingTransport transport228) throws TException {
        super(client226, protocolFactory227, transport228, resultHandler230, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getSpace", TMessageType.CALL, 0));
        getSpace_args args = new getSpace_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetSpaceResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getSpace();
      }
    }

    public void listSpaces(ListSpacesReq req, AsyncMethodCallback resultHandler234) throws TException {
      checkReady();
      listSpaces_call method_call = new listSpaces_call(req, resultHandler234, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listSpaces_call extends TAsyncMethodCall {
      private ListSpacesReq req;
      public listSpaces_call(ListSpacesReq req, AsyncMethodCallback resultHandler235, TAsyncClient client231, TProtocolFactory protocolFactory232, TNonblockingTransport transport233) throws TException {
        super(client231, protocolFactory232, transport233, resultHandler235, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listSpaces", TMessageType.CALL, 0));
        listSpaces_args args = new listSpaces_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListSpacesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listSpaces();
      }
    }

    public void createTag(CreateTagReq req, AsyncMethodCallback resultHandler239) throws TException {
      checkReady();
      createTag_call method_call = new createTag_call(req, resultHandler239, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createTag_call extends TAsyncMethodCall {
      private CreateTagReq req;
      public createTag_call(CreateTagReq req, AsyncMethodCallback resultHandler240, TAsyncClient client236, TProtocolFactory protocolFactory237, TNonblockingTransport transport238) throws TException {
        super(client236, protocolFactory237, transport238, resultHandler240, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createTag", TMessageType.CALL, 0));
        createTag_args args = new createTag_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createTag();
      }
    }

    public void alterTag(AlterTagReq req, AsyncMethodCallback resultHandler244) throws TException {
      checkReady();
      alterTag_call method_call = new alterTag_call(req, resultHandler244, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class alterTag_call extends TAsyncMethodCall {
      private AlterTagReq req;
      public alterTag_call(AlterTagReq req, AsyncMethodCallback resultHandler245, TAsyncClient client241, TProtocolFactory protocolFactory242, TNonblockingTransport transport243) throws TException {
        super(client241, protocolFactory242, transport243, resultHandler245, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("alterTag", TMessageType.CALL, 0));
        alterTag_args args = new alterTag_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_alterTag();
      }
    }

    public void dropTag(DropTagReq req, AsyncMethodCallback resultHandler249) throws TException {
      checkReady();
      dropTag_call method_call = new dropTag_call(req, resultHandler249, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropTag_call extends TAsyncMethodCall {
      private DropTagReq req;
      public dropTag_call(DropTagReq req, AsyncMethodCallback resultHandler250, TAsyncClient client246, TProtocolFactory protocolFactory247, TNonblockingTransport transport248) throws TException {
        super(client246, protocolFactory247, transport248, resultHandler250, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropTag", TMessageType.CALL, 0));
        dropTag_args args = new dropTag_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropTag();
      }
    }

    public void getTag(GetTagReq req, AsyncMethodCallback resultHandler254) throws TException {
      checkReady();
      getTag_call method_call = new getTag_call(req, resultHandler254, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getTag_call extends TAsyncMethodCall {
      private GetTagReq req;
      public getTag_call(GetTagReq req, AsyncMethodCallback resultHandler255, TAsyncClient client251, TProtocolFactory protocolFactory252, TNonblockingTransport transport253) throws TException {
        super(client251, protocolFactory252, transport253, resultHandler255, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTag", TMessageType.CALL, 0));
        getTag_args args = new getTag_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetTagResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTag();
      }
    }

    public void listTags(ListTagsReq req, AsyncMethodCallback resultHandler259) throws TException {
      checkReady();
      listTags_call method_call = new listTags_call(req, resultHandler259, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listTags_call extends TAsyncMethodCall {
      private ListTagsReq req;
      public listTags_call(ListTagsReq req, AsyncMethodCallback resultHandler260, TAsyncClient client256, TProtocolFactory protocolFactory257, TNonblockingTransport transport258) throws TException {
        super(client256, protocolFactory257, transport258, resultHandler260, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listTags", TMessageType.CALL, 0));
        listTags_args args = new listTags_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListTagsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listTags();
      }
    }

    public void createEdge(CreateEdgeReq req, AsyncMethodCallback resultHandler264) throws TException {
      checkReady();
      createEdge_call method_call = new createEdge_call(req, resultHandler264, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createEdge_call extends TAsyncMethodCall {
      private CreateEdgeReq req;
      public createEdge_call(CreateEdgeReq req, AsyncMethodCallback resultHandler265, TAsyncClient client261, TProtocolFactory protocolFactory262, TNonblockingTransport transport263) throws TException {
        super(client261, protocolFactory262, transport263, resultHandler265, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createEdge", TMessageType.CALL, 0));
        createEdge_args args = new createEdge_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createEdge();
      }
    }

    public void alterEdge(AlterEdgeReq req, AsyncMethodCallback resultHandler269) throws TException {
      checkReady();
      alterEdge_call method_call = new alterEdge_call(req, resultHandler269, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class alterEdge_call extends TAsyncMethodCall {
      private AlterEdgeReq req;
      public alterEdge_call(AlterEdgeReq req, AsyncMethodCallback resultHandler270, TAsyncClient client266, TProtocolFactory protocolFactory267, TNonblockingTransport transport268) throws TException {
        super(client266, protocolFactory267, transport268, resultHandler270, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("alterEdge", TMessageType.CALL, 0));
        alterEdge_args args = new alterEdge_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_alterEdge();
      }
    }

    public void dropEdge(DropEdgeReq req, AsyncMethodCallback resultHandler274) throws TException {
      checkReady();
      dropEdge_call method_call = new dropEdge_call(req, resultHandler274, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropEdge_call extends TAsyncMethodCall {
      private DropEdgeReq req;
      public dropEdge_call(DropEdgeReq req, AsyncMethodCallback resultHandler275, TAsyncClient client271, TProtocolFactory protocolFactory272, TNonblockingTransport transport273) throws TException {
        super(client271, protocolFactory272, transport273, resultHandler275, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropEdge", TMessageType.CALL, 0));
        dropEdge_args args = new dropEdge_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropEdge();
      }
    }

    public void getEdge(GetEdgeReq req, AsyncMethodCallback resultHandler279) throws TException {
      checkReady();
      getEdge_call method_call = new getEdge_call(req, resultHandler279, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getEdge_call extends TAsyncMethodCall {
      private GetEdgeReq req;
      public getEdge_call(GetEdgeReq req, AsyncMethodCallback resultHandler280, TAsyncClient client276, TProtocolFactory protocolFactory277, TNonblockingTransport transport278) throws TException {
        super(client276, protocolFactory277, transport278, resultHandler280, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getEdge", TMessageType.CALL, 0));
        getEdge_args args = new getEdge_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetEdgeResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getEdge();
      }
    }

    public void listEdges(ListEdgesReq req, AsyncMethodCallback resultHandler284) throws TException {
      checkReady();
      listEdges_call method_call = new listEdges_call(req, resultHandler284, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listEdges_call extends TAsyncMethodCall {
      private ListEdgesReq req;
      public listEdges_call(ListEdgesReq req, AsyncMethodCallback resultHandler285, TAsyncClient client281, TProtocolFactory protocolFactory282, TNonblockingTransport transport283) throws TException {
        super(client281, protocolFactory282, transport283, resultHandler285, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listEdges", TMessageType.CALL, 0));
        listEdges_args args = new listEdges_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListEdgesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listEdges();
      }
    }

    public void listHosts(ListHostsReq req, AsyncMethodCallback resultHandler289) throws TException {
      checkReady();
      listHosts_call method_call = new listHosts_call(req, resultHandler289, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listHosts_call extends TAsyncMethodCall {
      private ListHostsReq req;
      public listHosts_call(ListHostsReq req, AsyncMethodCallback resultHandler290, TAsyncClient client286, TProtocolFactory protocolFactory287, TNonblockingTransport transport288) throws TException {
        super(client286, protocolFactory287, transport288, resultHandler290, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listHosts", TMessageType.CALL, 0));
        listHosts_args args = new listHosts_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListHostsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listHosts();
      }
    }

    public void getPartsAlloc(GetPartsAllocReq req, AsyncMethodCallback resultHandler294) throws TException {
      checkReady();
      getPartsAlloc_call method_call = new getPartsAlloc_call(req, resultHandler294, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getPartsAlloc_call extends TAsyncMethodCall {
      private GetPartsAllocReq req;
      public getPartsAlloc_call(GetPartsAllocReq req, AsyncMethodCallback resultHandler295, TAsyncClient client291, TProtocolFactory protocolFactory292, TNonblockingTransport transport293) throws TException {
        super(client291, protocolFactory292, transport293, resultHandler295, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getPartsAlloc", TMessageType.CALL, 0));
        getPartsAlloc_args args = new getPartsAlloc_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetPartsAllocResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getPartsAlloc();
      }
    }

    public void listParts(ListPartsReq req, AsyncMethodCallback resultHandler299) throws TException {
      checkReady();
      listParts_call method_call = new listParts_call(req, resultHandler299, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listParts_call extends TAsyncMethodCall {
      private ListPartsReq req;
      public listParts_call(ListPartsReq req, AsyncMethodCallback resultHandler300, TAsyncClient client296, TProtocolFactory protocolFactory297, TNonblockingTransport transport298) throws TException {
        super(client296, protocolFactory297, transport298, resultHandler300, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listParts", TMessageType.CALL, 0));
        listParts_args args = new listParts_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListPartsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listParts();
      }
    }

    public void multiPut(MultiPutReq req, AsyncMethodCallback resultHandler304) throws TException {
      checkReady();
      multiPut_call method_call = new multiPut_call(req, resultHandler304, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class multiPut_call extends TAsyncMethodCall {
      private MultiPutReq req;
      public multiPut_call(MultiPutReq req, AsyncMethodCallback resultHandler305, TAsyncClient client301, TProtocolFactory protocolFactory302, TNonblockingTransport transport303) throws TException {
        super(client301, protocolFactory302, transport303, resultHandler305, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("multiPut", TMessageType.CALL, 0));
        multiPut_args args = new multiPut_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_multiPut();
      }
    }

    public void get(GetReq req, AsyncMethodCallback resultHandler309) throws TException {
      checkReady();
      get_call method_call = new get_call(req, resultHandler309, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class get_call extends TAsyncMethodCall {
      private GetReq req;
      public get_call(GetReq req, AsyncMethodCallback resultHandler310, TAsyncClient client306, TProtocolFactory protocolFactory307, TNonblockingTransport transport308) throws TException {
        super(client306, protocolFactory307, transport308, resultHandler310, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get", TMessageType.CALL, 0));
        get_args args = new get_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get();
      }
    }

    public void multiGet(MultiGetReq req, AsyncMethodCallback resultHandler314) throws TException {
      checkReady();
      multiGet_call method_call = new multiGet_call(req, resultHandler314, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class multiGet_call extends TAsyncMethodCall {
      private MultiGetReq req;
      public multiGet_call(MultiGetReq req, AsyncMethodCallback resultHandler315, TAsyncClient client311, TProtocolFactory protocolFactory312, TNonblockingTransport transport313) throws TException {
        super(client311, protocolFactory312, transport313, resultHandler315, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("multiGet", TMessageType.CALL, 0));
        multiGet_args args = new multiGet_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public MultiGetResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_multiGet();
      }
    }

    public void remove(RemoveReq req, AsyncMethodCallback resultHandler319) throws TException {
      checkReady();
      remove_call method_call = new remove_call(req, resultHandler319, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class remove_call extends TAsyncMethodCall {
      private RemoveReq req;
      public remove_call(RemoveReq req, AsyncMethodCallback resultHandler320, TAsyncClient client316, TProtocolFactory protocolFactory317, TNonblockingTransport transport318) throws TException {
        super(client316, protocolFactory317, transport318, resultHandler320, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("remove", TMessageType.CALL, 0));
        remove_args args = new remove_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_remove();
      }
    }

    public void removeRange(RemoveRangeReq req, AsyncMethodCallback resultHandler324) throws TException {
      checkReady();
      removeRange_call method_call = new removeRange_call(req, resultHandler324, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class removeRange_call extends TAsyncMethodCall {
      private RemoveRangeReq req;
      public removeRange_call(RemoveRangeReq req, AsyncMethodCallback resultHandler325, TAsyncClient client321, TProtocolFactory protocolFactory322, TNonblockingTransport transport323) throws TException {
        super(client321, protocolFactory322, transport323, resultHandler325, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("removeRange", TMessageType.CALL, 0));
        removeRange_args args = new removeRange_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_removeRange();
      }
    }

    public void scan(ScanReq req, AsyncMethodCallback resultHandler329) throws TException {
      checkReady();
      scan_call method_call = new scan_call(req, resultHandler329, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class scan_call extends TAsyncMethodCall {
      private ScanReq req;
      public scan_call(ScanReq req, AsyncMethodCallback resultHandler330, TAsyncClient client326, TProtocolFactory protocolFactory327, TNonblockingTransport transport328) throws TException {
        super(client326, protocolFactory327, transport328, resultHandler330, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("scan", TMessageType.CALL, 0));
        scan_args args = new scan_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ScanResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_scan();
      }
    }

    public void createTagIndex(CreateTagIndexReq req, AsyncMethodCallback resultHandler334) throws TException {
      checkReady();
      createTagIndex_call method_call = new createTagIndex_call(req, resultHandler334, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createTagIndex_call extends TAsyncMethodCall {
      private CreateTagIndexReq req;
      public createTagIndex_call(CreateTagIndexReq req, AsyncMethodCallback resultHandler335, TAsyncClient client331, TProtocolFactory protocolFactory332, TNonblockingTransport transport333) throws TException {
        super(client331, protocolFactory332, transport333, resultHandler335, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createTagIndex", TMessageType.CALL, 0));
        createTagIndex_args args = new createTagIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createTagIndex();
      }
    }

    public void dropTagIndex(DropTagIndexReq req, AsyncMethodCallback resultHandler339) throws TException {
      checkReady();
      dropTagIndex_call method_call = new dropTagIndex_call(req, resultHandler339, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropTagIndex_call extends TAsyncMethodCall {
      private DropTagIndexReq req;
      public dropTagIndex_call(DropTagIndexReq req, AsyncMethodCallback resultHandler340, TAsyncClient client336, TProtocolFactory protocolFactory337, TNonblockingTransport transport338) throws TException {
        super(client336, protocolFactory337, transport338, resultHandler340, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropTagIndex", TMessageType.CALL, 0));
        dropTagIndex_args args = new dropTagIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropTagIndex();
      }
    }

    public void getTagIndex(GetTagIndexReq req, AsyncMethodCallback resultHandler344) throws TException {
      checkReady();
      getTagIndex_call method_call = new getTagIndex_call(req, resultHandler344, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getTagIndex_call extends TAsyncMethodCall {
      private GetTagIndexReq req;
      public getTagIndex_call(GetTagIndexReq req, AsyncMethodCallback resultHandler345, TAsyncClient client341, TProtocolFactory protocolFactory342, TNonblockingTransport transport343) throws TException {
        super(client341, protocolFactory342, transport343, resultHandler345, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTagIndex", TMessageType.CALL, 0));
        getTagIndex_args args = new getTagIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetTagIndexResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTagIndex();
      }
    }

    public void listTagIndexes(ListTagIndexesReq req, AsyncMethodCallback resultHandler349) throws TException {
      checkReady();
      listTagIndexes_call method_call = new listTagIndexes_call(req, resultHandler349, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listTagIndexes_call extends TAsyncMethodCall {
      private ListTagIndexesReq req;
      public listTagIndexes_call(ListTagIndexesReq req, AsyncMethodCallback resultHandler350, TAsyncClient client346, TProtocolFactory protocolFactory347, TNonblockingTransport transport348) throws TException {
        super(client346, protocolFactory347, transport348, resultHandler350, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listTagIndexes", TMessageType.CALL, 0));
        listTagIndexes_args args = new listTagIndexes_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListTagIndexesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listTagIndexes();
      }
    }

    public void rebuildTagIndex(RebuildIndexReq req, AsyncMethodCallback resultHandler354) throws TException {
      checkReady();
      rebuildTagIndex_call method_call = new rebuildTagIndex_call(req, resultHandler354, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class rebuildTagIndex_call extends TAsyncMethodCall {
      private RebuildIndexReq req;
      public rebuildTagIndex_call(RebuildIndexReq req, AsyncMethodCallback resultHandler355, TAsyncClient client351, TProtocolFactory protocolFactory352, TNonblockingTransport transport353) throws TException {
        super(client351, protocolFactory352, transport353, resultHandler355, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("rebuildTagIndex", TMessageType.CALL, 0));
        rebuildTagIndex_args args = new rebuildTagIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_rebuildTagIndex();
      }
    }

    public void listTagIndexStatus(ListIndexStatusReq req, AsyncMethodCallback resultHandler359) throws TException {
      checkReady();
      listTagIndexStatus_call method_call = new listTagIndexStatus_call(req, resultHandler359, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listTagIndexStatus_call extends TAsyncMethodCall {
      private ListIndexStatusReq req;
      public listTagIndexStatus_call(ListIndexStatusReq req, AsyncMethodCallback resultHandler360, TAsyncClient client356, TProtocolFactory protocolFactory357, TNonblockingTransport transport358) throws TException {
        super(client356, protocolFactory357, transport358, resultHandler360, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listTagIndexStatus", TMessageType.CALL, 0));
        listTagIndexStatus_args args = new listTagIndexStatus_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListIndexStatusResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listTagIndexStatus();
      }
    }

    public void createEdgeIndex(CreateEdgeIndexReq req, AsyncMethodCallback resultHandler364) throws TException {
      checkReady();
      createEdgeIndex_call method_call = new createEdgeIndex_call(req, resultHandler364, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createEdgeIndex_call extends TAsyncMethodCall {
      private CreateEdgeIndexReq req;
      public createEdgeIndex_call(CreateEdgeIndexReq req, AsyncMethodCallback resultHandler365, TAsyncClient client361, TProtocolFactory protocolFactory362, TNonblockingTransport transport363) throws TException {
        super(client361, protocolFactory362, transport363, resultHandler365, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createEdgeIndex", TMessageType.CALL, 0));
        createEdgeIndex_args args = new createEdgeIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createEdgeIndex();
      }
    }

    public void dropEdgeIndex(DropEdgeIndexReq req, AsyncMethodCallback resultHandler369) throws TException {
      checkReady();
      dropEdgeIndex_call method_call = new dropEdgeIndex_call(req, resultHandler369, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropEdgeIndex_call extends TAsyncMethodCall {
      private DropEdgeIndexReq req;
      public dropEdgeIndex_call(DropEdgeIndexReq req, AsyncMethodCallback resultHandler370, TAsyncClient client366, TProtocolFactory protocolFactory367, TNonblockingTransport transport368) throws TException {
        super(client366, protocolFactory367, transport368, resultHandler370, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropEdgeIndex", TMessageType.CALL, 0));
        dropEdgeIndex_args args = new dropEdgeIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropEdgeIndex();
      }
    }

    public void getEdgeIndex(GetEdgeIndexReq req, AsyncMethodCallback resultHandler374) throws TException {
      checkReady();
      getEdgeIndex_call method_call = new getEdgeIndex_call(req, resultHandler374, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getEdgeIndex_call extends TAsyncMethodCall {
      private GetEdgeIndexReq req;
      public getEdgeIndex_call(GetEdgeIndexReq req, AsyncMethodCallback resultHandler375, TAsyncClient client371, TProtocolFactory protocolFactory372, TNonblockingTransport transport373) throws TException {
        super(client371, protocolFactory372, transport373, resultHandler375, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getEdgeIndex", TMessageType.CALL, 0));
        getEdgeIndex_args args = new getEdgeIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetEdgeIndexResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getEdgeIndex();
      }
    }

    public void listEdgeIndexes(ListEdgeIndexesReq req, AsyncMethodCallback resultHandler379) throws TException {
      checkReady();
      listEdgeIndexes_call method_call = new listEdgeIndexes_call(req, resultHandler379, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listEdgeIndexes_call extends TAsyncMethodCall {
      private ListEdgeIndexesReq req;
      public listEdgeIndexes_call(ListEdgeIndexesReq req, AsyncMethodCallback resultHandler380, TAsyncClient client376, TProtocolFactory protocolFactory377, TNonblockingTransport transport378) throws TException {
        super(client376, protocolFactory377, transport378, resultHandler380, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listEdgeIndexes", TMessageType.CALL, 0));
        listEdgeIndexes_args args = new listEdgeIndexes_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListEdgeIndexesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listEdgeIndexes();
      }
    }

    public void rebuildEdgeIndex(RebuildIndexReq req, AsyncMethodCallback resultHandler384) throws TException {
      checkReady();
      rebuildEdgeIndex_call method_call = new rebuildEdgeIndex_call(req, resultHandler384, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class rebuildEdgeIndex_call extends TAsyncMethodCall {
      private RebuildIndexReq req;
      public rebuildEdgeIndex_call(RebuildIndexReq req, AsyncMethodCallback resultHandler385, TAsyncClient client381, TProtocolFactory protocolFactory382, TNonblockingTransport transport383) throws TException {
        super(client381, protocolFactory382, transport383, resultHandler385, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("rebuildEdgeIndex", TMessageType.CALL, 0));
        rebuildEdgeIndex_args args = new rebuildEdgeIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_rebuildEdgeIndex();
      }
    }

    public void listEdgeIndexStatus(ListIndexStatusReq req, AsyncMethodCallback resultHandler389) throws TException {
      checkReady();
      listEdgeIndexStatus_call method_call = new listEdgeIndexStatus_call(req, resultHandler389, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listEdgeIndexStatus_call extends TAsyncMethodCall {
      private ListIndexStatusReq req;
      public listEdgeIndexStatus_call(ListIndexStatusReq req, AsyncMethodCallback resultHandler390, TAsyncClient client386, TProtocolFactory protocolFactory387, TNonblockingTransport transport388) throws TException {
        super(client386, protocolFactory387, transport388, resultHandler390, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listEdgeIndexStatus", TMessageType.CALL, 0));
        listEdgeIndexStatus_args args = new listEdgeIndexStatus_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListIndexStatusResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listEdgeIndexStatus();
      }
    }

    public void createUser(CreateUserReq req, AsyncMethodCallback resultHandler394) throws TException {
      checkReady();
      createUser_call method_call = new createUser_call(req, resultHandler394, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createUser_call extends TAsyncMethodCall {
      private CreateUserReq req;
      public createUser_call(CreateUserReq req, AsyncMethodCallback resultHandler395, TAsyncClient client391, TProtocolFactory protocolFactory392, TNonblockingTransport transport393) throws TException {
        super(client391, protocolFactory392, transport393, resultHandler395, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createUser", TMessageType.CALL, 0));
        createUser_args args = new createUser_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createUser();
      }
    }

    public void dropUser(DropUserReq req, AsyncMethodCallback resultHandler399) throws TException {
      checkReady();
      dropUser_call method_call = new dropUser_call(req, resultHandler399, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropUser_call extends TAsyncMethodCall {
      private DropUserReq req;
      public dropUser_call(DropUserReq req, AsyncMethodCallback resultHandler400, TAsyncClient client396, TProtocolFactory protocolFactory397, TNonblockingTransport transport398) throws TException {
        super(client396, protocolFactory397, transport398, resultHandler400, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropUser", TMessageType.CALL, 0));
        dropUser_args args = new dropUser_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropUser();
      }
    }

    public void alterUser(AlterUserReq req, AsyncMethodCallback resultHandler404) throws TException {
      checkReady();
      alterUser_call method_call = new alterUser_call(req, resultHandler404, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class alterUser_call extends TAsyncMethodCall {
      private AlterUserReq req;
      public alterUser_call(AlterUserReq req, AsyncMethodCallback resultHandler405, TAsyncClient client401, TProtocolFactory protocolFactory402, TNonblockingTransport transport403) throws TException {
        super(client401, protocolFactory402, transport403, resultHandler405, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("alterUser", TMessageType.CALL, 0));
        alterUser_args args = new alterUser_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_alterUser();
      }
    }

    public void grantRole(GrantRoleReq req, AsyncMethodCallback resultHandler409) throws TException {
      checkReady();
      grantRole_call method_call = new grantRole_call(req, resultHandler409, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class grantRole_call extends TAsyncMethodCall {
      private GrantRoleReq req;
      public grantRole_call(GrantRoleReq req, AsyncMethodCallback resultHandler410, TAsyncClient client406, TProtocolFactory protocolFactory407, TNonblockingTransport transport408) throws TException {
        super(client406, protocolFactory407, transport408, resultHandler410, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("grantRole", TMessageType.CALL, 0));
        grantRole_args args = new grantRole_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_grantRole();
      }
    }

    public void revokeRole(RevokeRoleReq req, AsyncMethodCallback resultHandler414) throws TException {
      checkReady();
      revokeRole_call method_call = new revokeRole_call(req, resultHandler414, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class revokeRole_call extends TAsyncMethodCall {
      private RevokeRoleReq req;
      public revokeRole_call(RevokeRoleReq req, AsyncMethodCallback resultHandler415, TAsyncClient client411, TProtocolFactory protocolFactory412, TNonblockingTransport transport413) throws TException {
        super(client411, protocolFactory412, transport413, resultHandler415, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("revokeRole", TMessageType.CALL, 0));
        revokeRole_args args = new revokeRole_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_revokeRole();
      }
    }

    public void listUsers(ListUsersReq req, AsyncMethodCallback resultHandler419) throws TException {
      checkReady();
      listUsers_call method_call = new listUsers_call(req, resultHandler419, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listUsers_call extends TAsyncMethodCall {
      private ListUsersReq req;
      public listUsers_call(ListUsersReq req, AsyncMethodCallback resultHandler420, TAsyncClient client416, TProtocolFactory protocolFactory417, TNonblockingTransport transport418) throws TException {
        super(client416, protocolFactory417, transport418, resultHandler420, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listUsers", TMessageType.CALL, 0));
        listUsers_args args = new listUsers_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListUsersResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listUsers();
      }
    }

    public void listRoles(ListRolesReq req, AsyncMethodCallback resultHandler424) throws TException {
      checkReady();
      listRoles_call method_call = new listRoles_call(req, resultHandler424, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listRoles_call extends TAsyncMethodCall {
      private ListRolesReq req;
      public listRoles_call(ListRolesReq req, AsyncMethodCallback resultHandler425, TAsyncClient client421, TProtocolFactory protocolFactory422, TNonblockingTransport transport423) throws TException {
        super(client421, protocolFactory422, transport423, resultHandler425, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listRoles", TMessageType.CALL, 0));
        listRoles_args args = new listRoles_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListRolesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listRoles();
      }
    }

    public void getUserRoles(GetUserRolesReq req, AsyncMethodCallback resultHandler429) throws TException {
      checkReady();
      getUserRoles_call method_call = new getUserRoles_call(req, resultHandler429, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getUserRoles_call extends TAsyncMethodCall {
      private GetUserRolesReq req;
      public getUserRoles_call(GetUserRolesReq req, AsyncMethodCallback resultHandler430, TAsyncClient client426, TProtocolFactory protocolFactory427, TNonblockingTransport transport428) throws TException {
        super(client426, protocolFactory427, transport428, resultHandler430, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getUserRoles", TMessageType.CALL, 0));
        getUserRoles_args args = new getUserRoles_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListRolesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getUserRoles();
      }
    }

    public void changePassword(ChangePasswordReq req, AsyncMethodCallback resultHandler434) throws TException {
      checkReady();
      changePassword_call method_call = new changePassword_call(req, resultHandler434, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class changePassword_call extends TAsyncMethodCall {
      private ChangePasswordReq req;
      public changePassword_call(ChangePasswordReq req, AsyncMethodCallback resultHandler435, TAsyncClient client431, TProtocolFactory protocolFactory432, TNonblockingTransport transport433) throws TException {
        super(client431, protocolFactory432, transport433, resultHandler435, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("changePassword", TMessageType.CALL, 0));
        changePassword_args args = new changePassword_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_changePassword();
      }
    }

    public void heartBeat(HBReq req, AsyncMethodCallback resultHandler439) throws TException {
      checkReady();
      heartBeat_call method_call = new heartBeat_call(req, resultHandler439, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class heartBeat_call extends TAsyncMethodCall {
      private HBReq req;
      public heartBeat_call(HBReq req, AsyncMethodCallback resultHandler440, TAsyncClient client436, TProtocolFactory protocolFactory437, TNonblockingTransport transport438) throws TException {
        super(client436, protocolFactory437, transport438, resultHandler440, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("heartBeat", TMessageType.CALL, 0));
        heartBeat_args args = new heartBeat_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public HBResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_heartBeat();
      }
    }

    public void balance(BalanceReq req, AsyncMethodCallback resultHandler444) throws TException {
      checkReady();
      balance_call method_call = new balance_call(req, resultHandler444, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class balance_call extends TAsyncMethodCall {
      private BalanceReq req;
      public balance_call(BalanceReq req, AsyncMethodCallback resultHandler445, TAsyncClient client441, TProtocolFactory protocolFactory442, TNonblockingTransport transport443) throws TException {
        super(client441, protocolFactory442, transport443, resultHandler445, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("balance", TMessageType.CALL, 0));
        balance_args args = new balance_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public BalanceResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_balance();
      }
    }

    public void leaderBalance(LeaderBalanceReq req, AsyncMethodCallback resultHandler449) throws TException {
      checkReady();
      leaderBalance_call method_call = new leaderBalance_call(req, resultHandler449, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class leaderBalance_call extends TAsyncMethodCall {
      private LeaderBalanceReq req;
      public leaderBalance_call(LeaderBalanceReq req, AsyncMethodCallback resultHandler450, TAsyncClient client446, TProtocolFactory protocolFactory447, TNonblockingTransport transport448) throws TException {
        super(client446, protocolFactory447, transport448, resultHandler450, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("leaderBalance", TMessageType.CALL, 0));
        leaderBalance_args args = new leaderBalance_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_leaderBalance();
      }
    }

    public void regConfig(RegConfigReq req, AsyncMethodCallback resultHandler454) throws TException {
      checkReady();
      regConfig_call method_call = new regConfig_call(req, resultHandler454, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class regConfig_call extends TAsyncMethodCall {
      private RegConfigReq req;
      public regConfig_call(RegConfigReq req, AsyncMethodCallback resultHandler455, TAsyncClient client451, TProtocolFactory protocolFactory452, TNonblockingTransport transport453) throws TException {
        super(client451, protocolFactory452, transport453, resultHandler455, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("regConfig", TMessageType.CALL, 0));
        regConfig_args args = new regConfig_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_regConfig();
      }
    }

    public void getConfig(GetConfigReq req, AsyncMethodCallback resultHandler459) throws TException {
      checkReady();
      getConfig_call method_call = new getConfig_call(req, resultHandler459, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getConfig_call extends TAsyncMethodCall {
      private GetConfigReq req;
      public getConfig_call(GetConfigReq req, AsyncMethodCallback resultHandler460, TAsyncClient client456, TProtocolFactory protocolFactory457, TNonblockingTransport transport458) throws TException {
        super(client456, protocolFactory457, transport458, resultHandler460, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getConfig", TMessageType.CALL, 0));
        getConfig_args args = new getConfig_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetConfigResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getConfig();
      }
    }

    public void setConfig(SetConfigReq req, AsyncMethodCallback resultHandler464) throws TException {
      checkReady();
      setConfig_call method_call = new setConfig_call(req, resultHandler464, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class setConfig_call extends TAsyncMethodCall {
      private SetConfigReq req;
      public setConfig_call(SetConfigReq req, AsyncMethodCallback resultHandler465, TAsyncClient client461, TProtocolFactory protocolFactory462, TNonblockingTransport transport463) throws TException {
        super(client461, protocolFactory462, transport463, resultHandler465, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("setConfig", TMessageType.CALL, 0));
        setConfig_args args = new setConfig_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_setConfig();
      }
    }

    public void listConfigs(ListConfigsReq req, AsyncMethodCallback resultHandler469) throws TException {
      checkReady();
      listConfigs_call method_call = new listConfigs_call(req, resultHandler469, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listConfigs_call extends TAsyncMethodCall {
      private ListConfigsReq req;
      public listConfigs_call(ListConfigsReq req, AsyncMethodCallback resultHandler470, TAsyncClient client466, TProtocolFactory protocolFactory467, TNonblockingTransport transport468) throws TException {
        super(client466, protocolFactory467, transport468, resultHandler470, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listConfigs", TMessageType.CALL, 0));
        listConfigs_args args = new listConfigs_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListConfigsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listConfigs();
      }
    }

    public void createSnapshot(CreateSnapshotReq req, AsyncMethodCallback resultHandler474) throws TException {
      checkReady();
      createSnapshot_call method_call = new createSnapshot_call(req, resultHandler474, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createSnapshot_call extends TAsyncMethodCall {
      private CreateSnapshotReq req;
      public createSnapshot_call(CreateSnapshotReq req, AsyncMethodCallback resultHandler475, TAsyncClient client471, TProtocolFactory protocolFactory472, TNonblockingTransport transport473) throws TException {
        super(client471, protocolFactory472, transport473, resultHandler475, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createSnapshot", TMessageType.CALL, 0));
        createSnapshot_args args = new createSnapshot_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createSnapshot();
      }
    }

    public void dropSnapshot(DropSnapshotReq req, AsyncMethodCallback resultHandler479) throws TException {
      checkReady();
      dropSnapshot_call method_call = new dropSnapshot_call(req, resultHandler479, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropSnapshot_call extends TAsyncMethodCall {
      private DropSnapshotReq req;
      public dropSnapshot_call(DropSnapshotReq req, AsyncMethodCallback resultHandler480, TAsyncClient client476, TProtocolFactory protocolFactory477, TNonblockingTransport transport478) throws TException {
        super(client476, protocolFactory477, transport478, resultHandler480, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropSnapshot", TMessageType.CALL, 0));
        dropSnapshot_args args = new dropSnapshot_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropSnapshot();
      }
    }

    public void listSnapshots(ListSnapshotsReq req, AsyncMethodCallback resultHandler484) throws TException {
      checkReady();
      listSnapshots_call method_call = new listSnapshots_call(req, resultHandler484, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listSnapshots_call extends TAsyncMethodCall {
      private ListSnapshotsReq req;
      public listSnapshots_call(ListSnapshotsReq req, AsyncMethodCallback resultHandler485, TAsyncClient client481, TProtocolFactory protocolFactory482, TNonblockingTransport transport483) throws TException {
        super(client481, protocolFactory482, transport483, resultHandler485, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listSnapshots", TMessageType.CALL, 0));
        listSnapshots_args args = new listSnapshots_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListSnapshotsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listSnapshots();
      }
    }

    public void runAdminJob(AdminJobReq req, AsyncMethodCallback resultHandler489) throws TException {
      checkReady();
      runAdminJob_call method_call = new runAdminJob_call(req, resultHandler489, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class runAdminJob_call extends TAsyncMethodCall {
      private AdminJobReq req;
      public runAdminJob_call(AdminJobReq req, AsyncMethodCallback resultHandler490, TAsyncClient client486, TProtocolFactory protocolFactory487, TNonblockingTransport transport488) throws TException {
        super(client486, protocolFactory487, transport488, resultHandler490, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("runAdminJob", TMessageType.CALL, 0));
        runAdminJob_args args = new runAdminJob_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public AdminJobResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_runAdminJob();
      }
    }

  }

  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      event_handler_ = new TProcessorEventHandler(); // Empty handler
      processMap_.put("createSpace", new createSpace());
      processMap_.put("dropSpace", new dropSpace());
      processMap_.put("getSpace", new getSpace());
      processMap_.put("listSpaces", new listSpaces());
      processMap_.put("createTag", new createTag());
      processMap_.put("alterTag", new alterTag());
      processMap_.put("dropTag", new dropTag());
      processMap_.put("getTag", new getTag());
      processMap_.put("listTags", new listTags());
      processMap_.put("createEdge", new createEdge());
      processMap_.put("alterEdge", new alterEdge());
      processMap_.put("dropEdge", new dropEdge());
      processMap_.put("getEdge", new getEdge());
      processMap_.put("listEdges", new listEdges());
      processMap_.put("listHosts", new listHosts());
      processMap_.put("getPartsAlloc", new getPartsAlloc());
      processMap_.put("listParts", new listParts());
      processMap_.put("multiPut", new multiPut());
      processMap_.put("get", new get());
      processMap_.put("multiGet", new multiGet());
      processMap_.put("remove", new remove());
      processMap_.put("removeRange", new removeRange());
      processMap_.put("scan", new scan());
      processMap_.put("createTagIndex", new createTagIndex());
      processMap_.put("dropTagIndex", new dropTagIndex());
      processMap_.put("getTagIndex", new getTagIndex());
      processMap_.put("listTagIndexes", new listTagIndexes());
      processMap_.put("rebuildTagIndex", new rebuildTagIndex());
      processMap_.put("listTagIndexStatus", new listTagIndexStatus());
      processMap_.put("createEdgeIndex", new createEdgeIndex());
      processMap_.put("dropEdgeIndex", new dropEdgeIndex());
      processMap_.put("getEdgeIndex", new getEdgeIndex());
      processMap_.put("listEdgeIndexes", new listEdgeIndexes());
      processMap_.put("rebuildEdgeIndex", new rebuildEdgeIndex());
      processMap_.put("listEdgeIndexStatus", new listEdgeIndexStatus());
      processMap_.put("createUser", new createUser());
      processMap_.put("dropUser", new dropUser());
      processMap_.put("alterUser", new alterUser());
      processMap_.put("grantRole", new grantRole());
      processMap_.put("revokeRole", new revokeRole());
      processMap_.put("listUsers", new listUsers());
      processMap_.put("listRoles", new listRoles());
      processMap_.put("getUserRoles", new getUserRoles());
      processMap_.put("changePassword", new changePassword());
      processMap_.put("heartBeat", new heartBeat());
      processMap_.put("balance", new balance());
      processMap_.put("leaderBalance", new leaderBalance());
      processMap_.put("regConfig", new regConfig());
      processMap_.put("getConfig", new getConfig());
      processMap_.put("setConfig", new setConfig());
      processMap_.put("listConfigs", new listConfigs());
      processMap_.put("createSnapshot", new createSnapshot());
      processMap_.put("dropSnapshot", new dropSnapshot());
      processMap_.put("listSnapshots", new listSnapshots());
      processMap_.put("runAdminJob", new runAdminJob());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException;
    }

    public void setEventHandler(TProcessorEventHandler handler) {
      this.event_handler_ = handler;
    }

    private Iface iface_;
    protected TProcessorEventHandler event_handler_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot, server_ctx);
      return true;
    }

    private class createSpace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createSpace", server_ctx);
        createSpace_args args = new createSpace_args();
        event_handler_.preRead(handler_ctx, "MetaService.createSpace");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createSpace", args);
        createSpace_result result = new createSpace_result();
        result.success = iface_.createSpace(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createSpace", result);
        oprot.writeMessageBegin(new TMessage("createSpace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createSpace", result);
      }

    }

    private class dropSpace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropSpace", server_ctx);
        dropSpace_args args = new dropSpace_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropSpace");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropSpace", args);
        dropSpace_result result = new dropSpace_result();
        result.success = iface_.dropSpace(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropSpace", result);
        oprot.writeMessageBegin(new TMessage("dropSpace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropSpace", result);
      }

    }

    private class getSpace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getSpace", server_ctx);
        getSpace_args args = new getSpace_args();
        event_handler_.preRead(handler_ctx, "MetaService.getSpace");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getSpace", args);
        getSpace_result result = new getSpace_result();
        result.success = iface_.getSpace(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getSpace", result);
        oprot.writeMessageBegin(new TMessage("getSpace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getSpace", result);
      }

    }

    private class listSpaces implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listSpaces", server_ctx);
        listSpaces_args args = new listSpaces_args();
        event_handler_.preRead(handler_ctx, "MetaService.listSpaces");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listSpaces", args);
        listSpaces_result result = new listSpaces_result();
        result.success = iface_.listSpaces(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listSpaces", result);
        oprot.writeMessageBegin(new TMessage("listSpaces", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listSpaces", result);
      }

    }

    private class createTag implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createTag", server_ctx);
        createTag_args args = new createTag_args();
        event_handler_.preRead(handler_ctx, "MetaService.createTag");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createTag", args);
        createTag_result result = new createTag_result();
        result.success = iface_.createTag(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createTag", result);
        oprot.writeMessageBegin(new TMessage("createTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createTag", result);
      }

    }

    private class alterTag implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.alterTag", server_ctx);
        alterTag_args args = new alterTag_args();
        event_handler_.preRead(handler_ctx, "MetaService.alterTag");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.alterTag", args);
        alterTag_result result = new alterTag_result();
        result.success = iface_.alterTag(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.alterTag", result);
        oprot.writeMessageBegin(new TMessage("alterTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.alterTag", result);
      }

    }

    private class dropTag implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropTag", server_ctx);
        dropTag_args args = new dropTag_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropTag");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropTag", args);
        dropTag_result result = new dropTag_result();
        result.success = iface_.dropTag(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropTag", result);
        oprot.writeMessageBegin(new TMessage("dropTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropTag", result);
      }

    }

    private class getTag implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getTag", server_ctx);
        getTag_args args = new getTag_args();
        event_handler_.preRead(handler_ctx, "MetaService.getTag");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getTag", args);
        getTag_result result = new getTag_result();
        result.success = iface_.getTag(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getTag", result);
        oprot.writeMessageBegin(new TMessage("getTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getTag", result);
      }

    }

    private class listTags implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listTags", server_ctx);
        listTags_args args = new listTags_args();
        event_handler_.preRead(handler_ctx, "MetaService.listTags");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listTags", args);
        listTags_result result = new listTags_result();
        result.success = iface_.listTags(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listTags", result);
        oprot.writeMessageBegin(new TMessage("listTags", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listTags", result);
      }

    }

    private class createEdge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createEdge", server_ctx);
        createEdge_args args = new createEdge_args();
        event_handler_.preRead(handler_ctx, "MetaService.createEdge");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createEdge", args);
        createEdge_result result = new createEdge_result();
        result.success = iface_.createEdge(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createEdge", result);
        oprot.writeMessageBegin(new TMessage("createEdge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createEdge", result);
      }

    }

    private class alterEdge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.alterEdge", server_ctx);
        alterEdge_args args = new alterEdge_args();
        event_handler_.preRead(handler_ctx, "MetaService.alterEdge");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.alterEdge", args);
        alterEdge_result result = new alterEdge_result();
        result.success = iface_.alterEdge(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.alterEdge", result);
        oprot.writeMessageBegin(new TMessage("alterEdge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.alterEdge", result);
      }

    }

    private class dropEdge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropEdge", server_ctx);
        dropEdge_args args = new dropEdge_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropEdge");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropEdge", args);
        dropEdge_result result = new dropEdge_result();
        result.success = iface_.dropEdge(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropEdge", result);
        oprot.writeMessageBegin(new TMessage("dropEdge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropEdge", result);
      }

    }

    private class getEdge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getEdge", server_ctx);
        getEdge_args args = new getEdge_args();
        event_handler_.preRead(handler_ctx, "MetaService.getEdge");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getEdge", args);
        getEdge_result result = new getEdge_result();
        result.success = iface_.getEdge(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getEdge", result);
        oprot.writeMessageBegin(new TMessage("getEdge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getEdge", result);
      }

    }

    private class listEdges implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listEdges", server_ctx);
        listEdges_args args = new listEdges_args();
        event_handler_.preRead(handler_ctx, "MetaService.listEdges");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listEdges", args);
        listEdges_result result = new listEdges_result();
        result.success = iface_.listEdges(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listEdges", result);
        oprot.writeMessageBegin(new TMessage("listEdges", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listEdges", result);
      }

    }

    private class listHosts implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listHosts", server_ctx);
        listHosts_args args = new listHosts_args();
        event_handler_.preRead(handler_ctx, "MetaService.listHosts");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listHosts", args);
        listHosts_result result = new listHosts_result();
        result.success = iface_.listHosts(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listHosts", result);
        oprot.writeMessageBegin(new TMessage("listHosts", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listHosts", result);
      }

    }

    private class getPartsAlloc implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getPartsAlloc", server_ctx);
        getPartsAlloc_args args = new getPartsAlloc_args();
        event_handler_.preRead(handler_ctx, "MetaService.getPartsAlloc");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getPartsAlloc", args);
        getPartsAlloc_result result = new getPartsAlloc_result();
        result.success = iface_.getPartsAlloc(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getPartsAlloc", result);
        oprot.writeMessageBegin(new TMessage("getPartsAlloc", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getPartsAlloc", result);
      }

    }

    private class listParts implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listParts", server_ctx);
        listParts_args args = new listParts_args();
        event_handler_.preRead(handler_ctx, "MetaService.listParts");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listParts", args);
        listParts_result result = new listParts_result();
        result.success = iface_.listParts(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listParts", result);
        oprot.writeMessageBegin(new TMessage("listParts", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listParts", result);
      }

    }

    private class multiPut implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.multiPut", server_ctx);
        multiPut_args args = new multiPut_args();
        event_handler_.preRead(handler_ctx, "MetaService.multiPut");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.multiPut", args);
        multiPut_result result = new multiPut_result();
        result.success = iface_.multiPut(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.multiPut", result);
        oprot.writeMessageBegin(new TMessage("multiPut", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.multiPut", result);
      }

    }

    private class get implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.get", server_ctx);
        get_args args = new get_args();
        event_handler_.preRead(handler_ctx, "MetaService.get");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.get", args);
        get_result result = new get_result();
        result.success = iface_.get(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.get", result);
        oprot.writeMessageBegin(new TMessage("get", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.get", result);
      }

    }

    private class multiGet implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.multiGet", server_ctx);
        multiGet_args args = new multiGet_args();
        event_handler_.preRead(handler_ctx, "MetaService.multiGet");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.multiGet", args);
        multiGet_result result = new multiGet_result();
        result.success = iface_.multiGet(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.multiGet", result);
        oprot.writeMessageBegin(new TMessage("multiGet", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.multiGet", result);
      }

    }

    private class remove implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.remove", server_ctx);
        remove_args args = new remove_args();
        event_handler_.preRead(handler_ctx, "MetaService.remove");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.remove", args);
        remove_result result = new remove_result();
        result.success = iface_.remove(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.remove", result);
        oprot.writeMessageBegin(new TMessage("remove", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.remove", result);
      }

    }

    private class removeRange implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.removeRange", server_ctx);
        removeRange_args args = new removeRange_args();
        event_handler_.preRead(handler_ctx, "MetaService.removeRange");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.removeRange", args);
        removeRange_result result = new removeRange_result();
        result.success = iface_.removeRange(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.removeRange", result);
        oprot.writeMessageBegin(new TMessage("removeRange", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.removeRange", result);
      }

    }

    private class scan implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.scan", server_ctx);
        scan_args args = new scan_args();
        event_handler_.preRead(handler_ctx, "MetaService.scan");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.scan", args);
        scan_result result = new scan_result();
        result.success = iface_.scan(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.scan", result);
        oprot.writeMessageBegin(new TMessage("scan", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.scan", result);
      }

    }

    private class createTagIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createTagIndex", server_ctx);
        createTagIndex_args args = new createTagIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.createTagIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createTagIndex", args);
        createTagIndex_result result = new createTagIndex_result();
        result.success = iface_.createTagIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createTagIndex", result);
        oprot.writeMessageBegin(new TMessage("createTagIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createTagIndex", result);
      }

    }

    private class dropTagIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropTagIndex", server_ctx);
        dropTagIndex_args args = new dropTagIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropTagIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropTagIndex", args);
        dropTagIndex_result result = new dropTagIndex_result();
        result.success = iface_.dropTagIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropTagIndex", result);
        oprot.writeMessageBegin(new TMessage("dropTagIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropTagIndex", result);
      }

    }

    private class getTagIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getTagIndex", server_ctx);
        getTagIndex_args args = new getTagIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.getTagIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getTagIndex", args);
        getTagIndex_result result = new getTagIndex_result();
        result.success = iface_.getTagIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getTagIndex", result);
        oprot.writeMessageBegin(new TMessage("getTagIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getTagIndex", result);
      }

    }

    private class listTagIndexes implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listTagIndexes", server_ctx);
        listTagIndexes_args args = new listTagIndexes_args();
        event_handler_.preRead(handler_ctx, "MetaService.listTagIndexes");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listTagIndexes", args);
        listTagIndexes_result result = new listTagIndexes_result();
        result.success = iface_.listTagIndexes(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listTagIndexes", result);
        oprot.writeMessageBegin(new TMessage("listTagIndexes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listTagIndexes", result);
      }

    }

    private class rebuildTagIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.rebuildTagIndex", server_ctx);
        rebuildTagIndex_args args = new rebuildTagIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.rebuildTagIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.rebuildTagIndex", args);
        rebuildTagIndex_result result = new rebuildTagIndex_result();
        result.success = iface_.rebuildTagIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.rebuildTagIndex", result);
        oprot.writeMessageBegin(new TMessage("rebuildTagIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.rebuildTagIndex", result);
      }

    }

    private class listTagIndexStatus implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listTagIndexStatus", server_ctx);
        listTagIndexStatus_args args = new listTagIndexStatus_args();
        event_handler_.preRead(handler_ctx, "MetaService.listTagIndexStatus");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listTagIndexStatus", args);
        listTagIndexStatus_result result = new listTagIndexStatus_result();
        result.success = iface_.listTagIndexStatus(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listTagIndexStatus", result);
        oprot.writeMessageBegin(new TMessage("listTagIndexStatus", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listTagIndexStatus", result);
      }

    }

    private class createEdgeIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createEdgeIndex", server_ctx);
        createEdgeIndex_args args = new createEdgeIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.createEdgeIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createEdgeIndex", args);
        createEdgeIndex_result result = new createEdgeIndex_result();
        result.success = iface_.createEdgeIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createEdgeIndex", result);
        oprot.writeMessageBegin(new TMessage("createEdgeIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createEdgeIndex", result);
      }

    }

    private class dropEdgeIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropEdgeIndex", server_ctx);
        dropEdgeIndex_args args = new dropEdgeIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropEdgeIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropEdgeIndex", args);
        dropEdgeIndex_result result = new dropEdgeIndex_result();
        result.success = iface_.dropEdgeIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropEdgeIndex", result);
        oprot.writeMessageBegin(new TMessage("dropEdgeIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropEdgeIndex", result);
      }

    }

    private class getEdgeIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getEdgeIndex", server_ctx);
        getEdgeIndex_args args = new getEdgeIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.getEdgeIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getEdgeIndex", args);
        getEdgeIndex_result result = new getEdgeIndex_result();
        result.success = iface_.getEdgeIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getEdgeIndex", result);
        oprot.writeMessageBegin(new TMessage("getEdgeIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getEdgeIndex", result);
      }

    }

    private class listEdgeIndexes implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listEdgeIndexes", server_ctx);
        listEdgeIndexes_args args = new listEdgeIndexes_args();
        event_handler_.preRead(handler_ctx, "MetaService.listEdgeIndexes");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listEdgeIndexes", args);
        listEdgeIndexes_result result = new listEdgeIndexes_result();
        result.success = iface_.listEdgeIndexes(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listEdgeIndexes", result);
        oprot.writeMessageBegin(new TMessage("listEdgeIndexes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listEdgeIndexes", result);
      }

    }

    private class rebuildEdgeIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.rebuildEdgeIndex", server_ctx);
        rebuildEdgeIndex_args args = new rebuildEdgeIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.rebuildEdgeIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.rebuildEdgeIndex", args);
        rebuildEdgeIndex_result result = new rebuildEdgeIndex_result();
        result.success = iface_.rebuildEdgeIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.rebuildEdgeIndex", result);
        oprot.writeMessageBegin(new TMessage("rebuildEdgeIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.rebuildEdgeIndex", result);
      }

    }

    private class listEdgeIndexStatus implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listEdgeIndexStatus", server_ctx);
        listEdgeIndexStatus_args args = new listEdgeIndexStatus_args();
        event_handler_.preRead(handler_ctx, "MetaService.listEdgeIndexStatus");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listEdgeIndexStatus", args);
        listEdgeIndexStatus_result result = new listEdgeIndexStatus_result();
        result.success = iface_.listEdgeIndexStatus(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listEdgeIndexStatus", result);
        oprot.writeMessageBegin(new TMessage("listEdgeIndexStatus", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listEdgeIndexStatus", result);
      }

    }

    private class createUser implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createUser", server_ctx);
        createUser_args args = new createUser_args();
        event_handler_.preRead(handler_ctx, "MetaService.createUser");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createUser", args);
        createUser_result result = new createUser_result();
        result.success = iface_.createUser(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createUser", result);
        oprot.writeMessageBegin(new TMessage("createUser", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createUser", result);
      }

    }

    private class dropUser implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropUser", server_ctx);
        dropUser_args args = new dropUser_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropUser");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropUser", args);
        dropUser_result result = new dropUser_result();
        result.success = iface_.dropUser(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropUser", result);
        oprot.writeMessageBegin(new TMessage("dropUser", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropUser", result);
      }

    }

    private class alterUser implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.alterUser", server_ctx);
        alterUser_args args = new alterUser_args();
        event_handler_.preRead(handler_ctx, "MetaService.alterUser");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.alterUser", args);
        alterUser_result result = new alterUser_result();
        result.success = iface_.alterUser(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.alterUser", result);
        oprot.writeMessageBegin(new TMessage("alterUser", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.alterUser", result);
      }

    }

    private class grantRole implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.grantRole", server_ctx);
        grantRole_args args = new grantRole_args();
        event_handler_.preRead(handler_ctx, "MetaService.grantRole");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.grantRole", args);
        grantRole_result result = new grantRole_result();
        result.success = iface_.grantRole(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.grantRole", result);
        oprot.writeMessageBegin(new TMessage("grantRole", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.grantRole", result);
      }

    }

    private class revokeRole implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.revokeRole", server_ctx);
        revokeRole_args args = new revokeRole_args();
        event_handler_.preRead(handler_ctx, "MetaService.revokeRole");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.revokeRole", args);
        revokeRole_result result = new revokeRole_result();
        result.success = iface_.revokeRole(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.revokeRole", result);
        oprot.writeMessageBegin(new TMessage("revokeRole", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.revokeRole", result);
      }

    }

    private class listUsers implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listUsers", server_ctx);
        listUsers_args args = new listUsers_args();
        event_handler_.preRead(handler_ctx, "MetaService.listUsers");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listUsers", args);
        listUsers_result result = new listUsers_result();
        result.success = iface_.listUsers(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listUsers", result);
        oprot.writeMessageBegin(new TMessage("listUsers", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listUsers", result);
      }

    }

    private class listRoles implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listRoles", server_ctx);
        listRoles_args args = new listRoles_args();
        event_handler_.preRead(handler_ctx, "MetaService.listRoles");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listRoles", args);
        listRoles_result result = new listRoles_result();
        result.success = iface_.listRoles(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listRoles", result);
        oprot.writeMessageBegin(new TMessage("listRoles", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listRoles", result);
      }

    }

    private class getUserRoles implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getUserRoles", server_ctx);
        getUserRoles_args args = new getUserRoles_args();
        event_handler_.preRead(handler_ctx, "MetaService.getUserRoles");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getUserRoles", args);
        getUserRoles_result result = new getUserRoles_result();
        result.success = iface_.getUserRoles(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getUserRoles", result);
        oprot.writeMessageBegin(new TMessage("getUserRoles", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getUserRoles", result);
      }

    }

    private class changePassword implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.changePassword", server_ctx);
        changePassword_args args = new changePassword_args();
        event_handler_.preRead(handler_ctx, "MetaService.changePassword");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.changePassword", args);
        changePassword_result result = new changePassword_result();
        result.success = iface_.changePassword(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.changePassword", result);
        oprot.writeMessageBegin(new TMessage("changePassword", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.changePassword", result);
      }

    }

    private class heartBeat implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.heartBeat", server_ctx);
        heartBeat_args args = new heartBeat_args();
        event_handler_.preRead(handler_ctx, "MetaService.heartBeat");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.heartBeat", args);
        heartBeat_result result = new heartBeat_result();
        result.success = iface_.heartBeat(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.heartBeat", result);
        oprot.writeMessageBegin(new TMessage("heartBeat", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.heartBeat", result);
      }

    }

    private class balance implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.balance", server_ctx);
        balance_args args = new balance_args();
        event_handler_.preRead(handler_ctx, "MetaService.balance");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.balance", args);
        balance_result result = new balance_result();
        result.success = iface_.balance(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.balance", result);
        oprot.writeMessageBegin(new TMessage("balance", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.balance", result);
      }

    }

    private class leaderBalance implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.leaderBalance", server_ctx);
        leaderBalance_args args = new leaderBalance_args();
        event_handler_.preRead(handler_ctx, "MetaService.leaderBalance");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.leaderBalance", args);
        leaderBalance_result result = new leaderBalance_result();
        result.success = iface_.leaderBalance(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.leaderBalance", result);
        oprot.writeMessageBegin(new TMessage("leaderBalance", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.leaderBalance", result);
      }

    }

    private class regConfig implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.regConfig", server_ctx);
        regConfig_args args = new regConfig_args();
        event_handler_.preRead(handler_ctx, "MetaService.regConfig");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.regConfig", args);
        regConfig_result result = new regConfig_result();
        result.success = iface_.regConfig(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.regConfig", result);
        oprot.writeMessageBegin(new TMessage("regConfig", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.regConfig", result);
      }

    }

    private class getConfig implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getConfig", server_ctx);
        getConfig_args args = new getConfig_args();
        event_handler_.preRead(handler_ctx, "MetaService.getConfig");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getConfig", args);
        getConfig_result result = new getConfig_result();
        result.success = iface_.getConfig(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getConfig", result);
        oprot.writeMessageBegin(new TMessage("getConfig", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getConfig", result);
      }

    }

    private class setConfig implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.setConfig", server_ctx);
        setConfig_args args = new setConfig_args();
        event_handler_.preRead(handler_ctx, "MetaService.setConfig");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.setConfig", args);
        setConfig_result result = new setConfig_result();
        result.success = iface_.setConfig(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.setConfig", result);
        oprot.writeMessageBegin(new TMessage("setConfig", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.setConfig", result);
      }

    }

    private class listConfigs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listConfigs", server_ctx);
        listConfigs_args args = new listConfigs_args();
        event_handler_.preRead(handler_ctx, "MetaService.listConfigs");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listConfigs", args);
        listConfigs_result result = new listConfigs_result();
        result.success = iface_.listConfigs(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listConfigs", result);
        oprot.writeMessageBegin(new TMessage("listConfigs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listConfigs", result);
      }

    }

    private class createSnapshot implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createSnapshot", server_ctx);
        createSnapshot_args args = new createSnapshot_args();
        event_handler_.preRead(handler_ctx, "MetaService.createSnapshot");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createSnapshot", args);
        createSnapshot_result result = new createSnapshot_result();
        result.success = iface_.createSnapshot(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createSnapshot", result);
        oprot.writeMessageBegin(new TMessage("createSnapshot", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createSnapshot", result);
      }

    }

    private class dropSnapshot implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropSnapshot", server_ctx);
        dropSnapshot_args args = new dropSnapshot_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropSnapshot");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropSnapshot", args);
        dropSnapshot_result result = new dropSnapshot_result();
        result.success = iface_.dropSnapshot(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropSnapshot", result);
        oprot.writeMessageBegin(new TMessage("dropSnapshot", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropSnapshot", result);
      }

    }

    private class listSnapshots implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listSnapshots", server_ctx);
        listSnapshots_args args = new listSnapshots_args();
        event_handler_.preRead(handler_ctx, "MetaService.listSnapshots");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listSnapshots", args);
        listSnapshots_result result = new listSnapshots_result();
        result.success = iface_.listSnapshots(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listSnapshots", result);
        oprot.writeMessageBegin(new TMessage("listSnapshots", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listSnapshots", result);
      }

    }

    private class runAdminJob implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.runAdminJob", server_ctx);
        runAdminJob_args args = new runAdminJob_args();
        event_handler_.preRead(handler_ctx, "MetaService.runAdminJob");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.runAdminJob", args);
        runAdminJob_result result = new runAdminJob_result();
        result.success = iface_.runAdminJob(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.runAdminJob", result);
        oprot.writeMessageBegin(new TMessage("runAdminJob", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.runAdminJob", result);
      }

    }

  }

  public static class createSpace_args implements TBase, java.io.Serializable, Cloneable, Comparable<createSpace_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSpace_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateSpaceReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateSpaceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSpace_args.class, metaDataMap);
    }

    public createSpace_args() {
    }

    public createSpace_args(
      CreateSpaceReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSpace_args(createSpace_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createSpace_args deepCopy() {
      return new createSpace_args(this);
    }

    @Deprecated
    public createSpace_args clone() {
      return new createSpace_args(this);
    }

    public CreateSpaceReq  getReq() {
      return this.req;
    }

    public createSpace_args setReq(CreateSpaceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((CreateSpaceReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createSpace_args)
        return this.equals((createSpace_args)that);
      return false;
    }

    public boolean equals(createSpace_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createSpace_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new CreateSpaceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSpace_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createSpace_result implements TBase, java.io.Serializable, Cloneable, Comparable<createSpace_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSpace_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSpace_result.class, metaDataMap);
    }

    public createSpace_result() {
    }

    public createSpace_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSpace_result(createSpace_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createSpace_result deepCopy() {
      return new createSpace_result(this);
    }

    @Deprecated
    public createSpace_result clone() {
      return new createSpace_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public createSpace_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createSpace_result)
        return this.equals((createSpace_result)that);
      return false;
    }

    public boolean equals(createSpace_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createSpace_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSpace_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropSpace_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropSpace_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropSpace_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropSpaceReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropSpaceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropSpace_args.class, metaDataMap);
    }

    public dropSpace_args() {
    }

    public dropSpace_args(
      DropSpaceReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropSpace_args(dropSpace_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropSpace_args deepCopy() {
      return new dropSpace_args(this);
    }

    @Deprecated
    public dropSpace_args clone() {
      return new dropSpace_args(this);
    }

    public DropSpaceReq  getReq() {
      return this.req;
    }

    public dropSpace_args setReq(DropSpaceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((DropSpaceReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropSpace_args)
        return this.equals((dropSpace_args)that);
      return false;
    }

    public boolean equals(dropSpace_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropSpace_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new DropSpaceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropSpace_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropSpace_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropSpace_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropSpace_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropSpace_result.class, metaDataMap);
    }

    public dropSpace_result() {
    }

    public dropSpace_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropSpace_result(dropSpace_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropSpace_result deepCopy() {
      return new dropSpace_result(this);
    }

    @Deprecated
    public dropSpace_result clone() {
      return new dropSpace_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public dropSpace_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropSpace_result)
        return this.equals((dropSpace_result)that);
      return false;
    }

    public boolean equals(dropSpace_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropSpace_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropSpace_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getSpace_args implements TBase, java.io.Serializable, Cloneable, Comparable<getSpace_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getSpace_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetSpaceReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetSpaceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getSpace_args.class, metaDataMap);
    }

    public getSpace_args() {
    }

    public getSpace_args(
      GetSpaceReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getSpace_args(getSpace_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getSpace_args deepCopy() {
      return new getSpace_args(this);
    }

    @Deprecated
    public getSpace_args clone() {
      return new getSpace_args(this);
    }

    public GetSpaceReq  getReq() {
      return this.req;
    }

    public getSpace_args setReq(GetSpaceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetSpaceReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getSpace_args)
        return this.equals((getSpace_args)that);
      return false;
    }

    public boolean equals(getSpace_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getSpace_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetSpaceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getSpace_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getSpace_result implements TBase, java.io.Serializable, Cloneable, Comparable<getSpace_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getSpace_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetSpaceResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetSpaceResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getSpace_result.class, metaDataMap);
    }

    public getSpace_result() {
    }

    public getSpace_result(
      GetSpaceResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getSpace_result(getSpace_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getSpace_result deepCopy() {
      return new getSpace_result(this);
    }

    @Deprecated
    public getSpace_result clone() {
      return new getSpace_result(this);
    }

    public GetSpaceResp  getSuccess() {
      return this.success;
    }

    public getSpace_result setSuccess(GetSpaceResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetSpaceResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getSpace_result)
        return this.equals((getSpace_result)that);
      return false;
    }

    public boolean equals(getSpace_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getSpace_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GetSpaceResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getSpace_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listSpaces_args implements TBase, java.io.Serializable, Cloneable, Comparable<listSpaces_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSpaces_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListSpacesReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSpacesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSpaces_args.class, metaDataMap);
    }

    public listSpaces_args() {
    }

    public listSpaces_args(
      ListSpacesReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSpaces_args(listSpaces_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listSpaces_args deepCopy() {
      return new listSpaces_args(this);
    }

    @Deprecated
    public listSpaces_args clone() {
      return new listSpaces_args(this);
    }

    public ListSpacesReq  getReq() {
      return this.req;
    }

    public listSpaces_args setReq(ListSpacesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListSpacesReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listSpaces_args)
        return this.equals((listSpaces_args)that);
      return false;
    }

    public boolean equals(listSpaces_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listSpaces_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListSpacesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSpaces_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listSpaces_result implements TBase, java.io.Serializable, Cloneable, Comparable<listSpaces_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSpaces_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListSpacesResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSpacesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSpaces_result.class, metaDataMap);
    }

    public listSpaces_result() {
    }

    public listSpaces_result(
      ListSpacesResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSpaces_result(listSpaces_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listSpaces_result deepCopy() {
      return new listSpaces_result(this);
    }

    @Deprecated
    public listSpaces_result clone() {
      return new listSpaces_result(this);
    }

    public ListSpacesResp  getSuccess() {
      return this.success;
    }

    public listSpaces_result setSuccess(ListSpacesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListSpacesResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listSpaces_result)
        return this.equals((listSpaces_result)that);
      return false;
    }

    public boolean equals(listSpaces_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listSpaces_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListSpacesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSpaces_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createTag_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("createTag_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateTagReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateTagReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createTag_args.class, metaDataMap);
    }

    public createTag_args() {
    }

    public createTag_args(
      CreateTagReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTag_args(createTag_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createTag_args deepCopy() {
      return new createTag_args(this);
    }

    @Deprecated
    public createTag_args clone() {
      return new createTag_args(this);
    }

    public CreateTagReq  getReq() {
      return this.req;
    }

    public createTag_args setReq(CreateTagReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((CreateTagReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createTag_args)
        return this.equals((createTag_args)that);
      return false;
    }

    public boolean equals(createTag_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new CreateTagReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createTag_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createTag_result implements TBase, java.io.Serializable, Cloneable, Comparable<createTag_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createTag_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createTag_result.class, metaDataMap);
    }

    public createTag_result() {
    }

    public createTag_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTag_result(createTag_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createTag_result deepCopy() {
      return new createTag_result(this);
    }

    @Deprecated
    public createTag_result clone() {
      return new createTag_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public createTag_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createTag_result)
        return this.equals((createTag_result)that);
      return false;
    }

    public boolean equals(createTag_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createTag_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createTag_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class alterTag_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("alterTag_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AlterTagReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AlterTagReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterTag_args.class, metaDataMap);
    }

    public alterTag_args() {
    }

    public alterTag_args(
      AlterTagReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterTag_args(alterTag_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public alterTag_args deepCopy() {
      return new alterTag_args(this);
    }

    @Deprecated
    public alterTag_args clone() {
      return new alterTag_args(this);
    }

    public AlterTagReq  getReq() {
      return this.req;
    }

    public alterTag_args setReq(AlterTagReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((AlterTagReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alterTag_args)
        return this.equals((alterTag_args)that);
      return false;
    }

    public boolean equals(alterTag_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new AlterTagReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterTag_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class alterTag_result implements TBase, java.io.Serializable, Cloneable, Comparable<alterTag_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterTag_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterTag_result.class, metaDataMap);
    }

    public alterTag_result() {
    }

    public alterTag_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterTag_result(alterTag_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public alterTag_result deepCopy() {
      return new alterTag_result(this);
    }

    @Deprecated
    public alterTag_result clone() {
      return new alterTag_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public alterTag_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alterTag_result)
        return this.equals((alterTag_result)that);
      return false;
    }

    public boolean equals(alterTag_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(alterTag_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterTag_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropTag_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropTag_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTag_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropTagReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropTagReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropTag_args.class, metaDataMap);
    }

    public dropTag_args() {
    }

    public dropTag_args(
      DropTagReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTag_args(dropTag_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropTag_args deepCopy() {
      return new dropTag_args(this);
    }

    @Deprecated
    public dropTag_args clone() {
      return new dropTag_args(this);
    }

    public DropTagReq  getReq() {
      return this.req;
    }

    public dropTag_args setReq(DropTagReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((DropTagReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropTag_args)
        return this.equals((dropTag_args)that);
      return false;
    }

    public boolean equals(dropTag_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropTag_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new DropTagReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropTag_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropTag_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropTag_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTag_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropTag_result.class, metaDataMap);
    }

    public dropTag_result() {
    }

    public dropTag_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTag_result(dropTag_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropTag_result deepCopy() {
      return new dropTag_result(this);
    }

    @Deprecated
    public dropTag_result clone() {
      return new dropTag_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public dropTag_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropTag_result)
        return this.equals((dropTag_result)that);
      return false;
    }

    public boolean equals(dropTag_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropTag_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropTag_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getTag_args implements TBase, java.io.Serializable, Cloneable, Comparable<getTag_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getTag_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetTagReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetTagReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getTag_args.class, metaDataMap);
    }

    public getTag_args() {
    }

    public getTag_args(
      GetTagReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTag_args(getTag_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getTag_args deepCopy() {
      return new getTag_args(this);
    }

    @Deprecated
    public getTag_args clone() {
      return new getTag_args(this);
    }

    public GetTagReq  getReq() {
      return this.req;
    }

    public getTag_args setReq(GetTagReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetTagReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTag_args)
        return this.equals((getTag_args)that);
      return false;
    }

    public boolean equals(getTag_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getTag_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetTagReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getTag_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getTag_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTag_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetTagResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetTagResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getTag_result.class, metaDataMap);
    }

    public getTag_result() {
    }

    public getTag_result(
      GetTagResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTag_result(getTag_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getTag_result deepCopy() {
      return new getTag_result(this);
    }

    @Deprecated
    public getTag_result clone() {
      return new getTag_result(this);
    }

    public GetTagResp  getSuccess() {
      return this.success;
    }

    public getTag_result setSuccess(GetTagResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetTagResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTag_result)
        return this.equals((getTag_result)that);
      return false;
    }

    public boolean equals(getTag_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GetTagResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getTag_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listTags_args implements TBase, java.io.Serializable, Cloneable, Comparable<listTags_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTags_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListTagsReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListTagsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTags_args.class, metaDataMap);
    }

    public listTags_args() {
    }

    public listTags_args(
      ListTagsReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTags_args(listTags_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listTags_args deepCopy() {
      return new listTags_args(this);
    }

    @Deprecated
    public listTags_args clone() {
      return new listTags_args(this);
    }

    public ListTagsReq  getReq() {
      return this.req;
    }

    public listTags_args setReq(ListTagsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListTagsReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listTags_args)
        return this.equals((listTags_args)that);
      return false;
    }

    public boolean equals(listTags_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listTags_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListTagsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTags_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listTags_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("listTags_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListTagsResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListTagsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTags_result.class, metaDataMap);
    }

    public listTags_result() {
    }

    public listTags_result(
      ListTagsResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTags_result(listTags_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listTags_result deepCopy() {
      return new listTags_result(this);
    }

    @Deprecated
    public listTags_result clone() {
      return new listTags_result(this);
    }

    public ListTagsResp  getSuccess() {
      return this.success;
    }

    public listTags_result setSuccess(ListTagsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListTagsResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listTags_result)
        return this.equals((listTags_result)that);
      return false;
    }

    public boolean equals(listTags_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListTagsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTags_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createEdge_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("createEdge_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateEdgeReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateEdgeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createEdge_args.class, metaDataMap);
    }

    public createEdge_args() {
    }

    public createEdge_args(
      CreateEdgeReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createEdge_args(createEdge_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createEdge_args deepCopy() {
      return new createEdge_args(this);
    }

    @Deprecated
    public createEdge_args clone() {
      return new createEdge_args(this);
    }

    public CreateEdgeReq  getReq() {
      return this.req;
    }

    public createEdge_args setReq(CreateEdgeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((CreateEdgeReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createEdge_args)
        return this.equals((createEdge_args)that);
      return false;
    }

    public boolean equals(createEdge_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new CreateEdgeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createEdge_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createEdge_result implements TBase, java.io.Serializable, Cloneable, Comparable<createEdge_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createEdge_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createEdge_result.class, metaDataMap);
    }

    public createEdge_result() {
    }

    public createEdge_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createEdge_result(createEdge_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createEdge_result deepCopy() {
      return new createEdge_result(this);
    }

    @Deprecated
    public createEdge_result clone() {
      return new createEdge_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public createEdge_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createEdge_result)
        return this.equals((createEdge_result)that);
      return false;
    }

    public boolean equals(createEdge_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createEdge_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createEdge_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class alterEdge_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("alterEdge_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AlterEdgeReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AlterEdgeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterEdge_args.class, metaDataMap);
    }

    public alterEdge_args() {
    }

    public alterEdge_args(
      AlterEdgeReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterEdge_args(alterEdge_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public alterEdge_args deepCopy() {
      return new alterEdge_args(this);
    }

    @Deprecated
    public alterEdge_args clone() {
      return new alterEdge_args(this);
    }

    public AlterEdgeReq  getReq() {
      return this.req;
    }

    public alterEdge_args setReq(AlterEdgeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((AlterEdgeReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alterEdge_args)
        return this.equals((alterEdge_args)that);
      return false;
    }

    public boolean equals(alterEdge_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new AlterEdgeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterEdge_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class alterEdge_result implements TBase, java.io.Serializable, Cloneable, Comparable<alterEdge_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterEdge_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterEdge_result.class, metaDataMap);
    }

    public alterEdge_result() {
    }

    public alterEdge_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterEdge_result(alterEdge_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public alterEdge_result deepCopy() {
      return new alterEdge_result(this);
    }

    @Deprecated
    public alterEdge_result clone() {
      return new alterEdge_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public alterEdge_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alterEdge_result)
        return this.equals((alterEdge_result)that);
      return false;
    }

    public boolean equals(alterEdge_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(alterEdge_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterEdge_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropEdge_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropEdge_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropEdge_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropEdgeReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropEdgeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropEdge_args.class, metaDataMap);
    }

    public dropEdge_args() {
    }

    public dropEdge_args(
      DropEdgeReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropEdge_args(dropEdge_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropEdge_args deepCopy() {
      return new dropEdge_args(this);
    }

    @Deprecated
    public dropEdge_args clone() {
      return new dropEdge_args(this);
    }

    public DropEdgeReq  getReq() {
      return this.req;
    }

    public dropEdge_args setReq(DropEdgeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((DropEdgeReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropEdge_args)
        return this.equals((dropEdge_args)that);
      return false;
    }

    public boolean equals(dropEdge_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropEdge_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new DropEdgeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropEdge_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropEdge_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropEdge_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropEdge_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropEdge_result.class, metaDataMap);
    }

    public dropEdge_result() {
    }

    public dropEdge_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropEdge_result(dropEdge_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropEdge_result deepCopy() {
      return new dropEdge_result(this);
    }

    @Deprecated
    public dropEdge_result clone() {
      return new dropEdge_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public dropEdge_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropEdge_result)
        return this.equals((dropEdge_result)that);
      return false;
    }

    public boolean equals(dropEdge_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropEdge_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropEdge_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getEdge_args implements TBase, java.io.Serializable, Cloneable, Comparable<getEdge_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getEdge_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetEdgeReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetEdgeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getEdge_args.class, metaDataMap);
    }

    public getEdge_args() {
    }

    public getEdge_args(
      GetEdgeReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEdge_args(getEdge_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getEdge_args deepCopy() {
      return new getEdge_args(this);
    }

    @Deprecated
    public getEdge_args clone() {
      return new getEdge_args(this);
    }

    public GetEdgeReq  getReq() {
      return this.req;
    }

    public getEdge_args setReq(GetEdgeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetEdgeReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getEdge_args)
        return this.equals((getEdge_args)that);
      return false;
    }

    public boolean equals(getEdge_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getEdge_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetEdgeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getEdge_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getEdge_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getEdge_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetEdgeResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetEdgeResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getEdge_result.class, metaDataMap);
    }

    public getEdge_result() {
    }

    public getEdge_result(
      GetEdgeResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEdge_result(getEdge_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getEdge_result deepCopy() {
      return new getEdge_result(this);
    }

    @Deprecated
    public getEdge_result clone() {
      return new getEdge_result(this);
    }

    public GetEdgeResp  getSuccess() {
      return this.success;
    }

    public getEdge_result setSuccess(GetEdgeResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetEdgeResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getEdge_result)
        return this.equals((getEdge_result)that);
      return false;
    }

    public boolean equals(getEdge_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GetEdgeResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getEdge_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listEdges_args implements TBase, java.io.Serializable, Cloneable, Comparable<listEdges_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdges_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListEdgesReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListEdgesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdges_args.class, metaDataMap);
    }

    public listEdges_args() {
    }

    public listEdges_args(
      ListEdgesReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdges_args(listEdges_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listEdges_args deepCopy() {
      return new listEdges_args(this);
    }

    @Deprecated
    public listEdges_args clone() {
      return new listEdges_args(this);
    }

    public ListEdgesReq  getReq() {
      return this.req;
    }

    public listEdges_args setReq(ListEdgesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListEdgesReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listEdges_args)
        return this.equals((listEdges_args)that);
      return false;
    }

    public boolean equals(listEdges_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listEdges_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListEdgesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdges_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listEdges_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdges_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListEdgesResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListEdgesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdges_result.class, metaDataMap);
    }

    public listEdges_result() {
    }

    public listEdges_result(
      ListEdgesResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdges_result(listEdges_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listEdges_result deepCopy() {
      return new listEdges_result(this);
    }

    @Deprecated
    public listEdges_result clone() {
      return new listEdges_result(this);
    }

    public ListEdgesResp  getSuccess() {
      return this.success;
    }

    public listEdges_result setSuccess(ListEdgesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListEdgesResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listEdges_result)
        return this.equals((listEdges_result)that);
      return false;
    }

    public boolean equals(listEdges_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListEdgesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdges_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listHosts_args implements TBase, java.io.Serializable, Cloneable, Comparable<listHosts_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listHosts_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListHostsReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListHostsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listHosts_args.class, metaDataMap);
    }

    public listHosts_args() {
    }

    public listHosts_args(
      ListHostsReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listHosts_args(listHosts_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listHosts_args deepCopy() {
      return new listHosts_args(this);
    }

    @Deprecated
    public listHosts_args clone() {
      return new listHosts_args(this);
    }

    public ListHostsReq  getReq() {
      return this.req;
    }

    public listHosts_args setReq(ListHostsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListHostsReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listHosts_args)
        return this.equals((listHosts_args)that);
      return false;
    }

    public boolean equals(listHosts_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listHosts_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListHostsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listHosts_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listHosts_result implements TBase, java.io.Serializable, Cloneable, Comparable<listHosts_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listHosts_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListHostsResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListHostsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listHosts_result.class, metaDataMap);
    }

    public listHosts_result() {
    }

    public listHosts_result(
      ListHostsResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listHosts_result(listHosts_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listHosts_result deepCopy() {
      return new listHosts_result(this);
    }

    @Deprecated
    public listHosts_result clone() {
      return new listHosts_result(this);
    }

    public ListHostsResp  getSuccess() {
      return this.success;
    }

    public listHosts_result setSuccess(ListHostsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListHostsResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listHosts_result)
        return this.equals((listHosts_result)that);
      return false;
    }

    public boolean equals(listHosts_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listHosts_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListHostsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listHosts_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getPartsAlloc_args implements TBase, java.io.Serializable, Cloneable, Comparable<getPartsAlloc_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getPartsAlloc_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetPartsAllocReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetPartsAllocReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getPartsAlloc_args.class, metaDataMap);
    }

    public getPartsAlloc_args() {
    }

    public getPartsAlloc_args(
      GetPartsAllocReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPartsAlloc_args(getPartsAlloc_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getPartsAlloc_args deepCopy() {
      return new getPartsAlloc_args(this);
    }

    @Deprecated
    public getPartsAlloc_args clone() {
      return new getPartsAlloc_args(this);
    }

    public GetPartsAllocReq  getReq() {
      return this.req;
    }

    public getPartsAlloc_args setReq(GetPartsAllocReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetPartsAllocReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getPartsAlloc_args)
        return this.equals((getPartsAlloc_args)that);
      return false;
    }

    public boolean equals(getPartsAlloc_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getPartsAlloc_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetPartsAllocReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getPartsAlloc_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getPartsAlloc_result implements TBase, java.io.Serializable, Cloneable, Comparable<getPartsAlloc_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getPartsAlloc_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetPartsAllocResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetPartsAllocResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getPartsAlloc_result.class, metaDataMap);
    }

    public getPartsAlloc_result() {
    }

    public getPartsAlloc_result(
      GetPartsAllocResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPartsAlloc_result(getPartsAlloc_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getPartsAlloc_result deepCopy() {
      return new getPartsAlloc_result(this);
    }

    @Deprecated
    public getPartsAlloc_result clone() {
      return new getPartsAlloc_result(this);
    }

    public GetPartsAllocResp  getSuccess() {
      return this.success;
    }

    public getPartsAlloc_result setSuccess(GetPartsAllocResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetPartsAllocResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getPartsAlloc_result)
        return this.equals((getPartsAlloc_result)that);
      return false;
    }

    public boolean equals(getPartsAlloc_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getPartsAlloc_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GetPartsAllocResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getPartsAlloc_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listParts_args implements TBase, java.io.Serializable, Cloneable, Comparable<listParts_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listParts_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListPartsReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListPartsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listParts_args.class, metaDataMap);
    }

    public listParts_args() {
    }

    public listParts_args(
      ListPartsReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listParts_args(listParts_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listParts_args deepCopy() {
      return new listParts_args(this);
    }

    @Deprecated
    public listParts_args clone() {
      return new listParts_args(this);
    }

    public ListPartsReq  getReq() {
      return this.req;
    }

    public listParts_args setReq(ListPartsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListPartsReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listParts_args)
        return this.equals((listParts_args)that);
      return false;
    }

    public boolean equals(listParts_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listParts_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListPartsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listParts_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listParts_result implements TBase, java.io.Serializable, Cloneable, Comparable<listParts_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listParts_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListPartsResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListPartsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listParts_result.class, metaDataMap);
    }

    public listParts_result() {
    }

    public listParts_result(
      ListPartsResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listParts_result(listParts_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listParts_result deepCopy() {
      return new listParts_result(this);
    }

    @Deprecated
    public listParts_result clone() {
      return new listParts_result(this);
    }

    public ListPartsResp  getSuccess() {
      return this.success;
    }

    public listParts_result setSuccess(ListPartsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListPartsResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listParts_result)
        return this.equals((listParts_result)that);
      return false;
    }

    public boolean equals(listParts_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listParts_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListPartsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listParts_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class multiPut_args implements TBase, java.io.Serializable, Cloneable, Comparable<multiPut_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("multiPut_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public MultiPutReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, MultiPutReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(multiPut_args.class, metaDataMap);
    }

    public multiPut_args() {
    }

    public multiPut_args(
      MultiPutReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiPut_args(multiPut_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public multiPut_args deepCopy() {
      return new multiPut_args(this);
    }

    @Deprecated
    public multiPut_args clone() {
      return new multiPut_args(this);
    }

    public MultiPutReq  getReq() {
      return this.req;
    }

    public multiPut_args setReq(MultiPutReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((MultiPutReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof multiPut_args)
        return this.equals((multiPut_args)that);
      return false;
    }

    public boolean equals(multiPut_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(multiPut_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new MultiPutReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("multiPut_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class multiPut_result implements TBase, java.io.Serializable, Cloneable, Comparable<multiPut_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("multiPut_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(multiPut_result.class, metaDataMap);
    }

    public multiPut_result() {
    }

    public multiPut_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiPut_result(multiPut_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public multiPut_result deepCopy() {
      return new multiPut_result(this);
    }

    @Deprecated
    public multiPut_result clone() {
      return new multiPut_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public multiPut_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof multiPut_result)
        return this.equals((multiPut_result)that);
      return false;
    }

    public boolean equals(multiPut_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(multiPut_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("multiPut_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(get_args.class, metaDataMap);
    }

    public get_args() {
    }

    public get_args(
      GetReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_args(get_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public get_args deepCopy() {
      return new get_args(this);
    }

    @Deprecated
    public get_args clone() {
      return new get_args(this);
    }

    public GetReq  getReq() {
      return this.req;
    }

    public get_args setReq(GetReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_args)
        return this.equals((get_args)that);
      return false;
    }

    public boolean equals(get_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(get_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("get_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(get_result.class, metaDataMap);
    }

    public get_result() {
    }

    public get_result(
      GetResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_result(get_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public get_result deepCopy() {
      return new get_result(this);
    }

    @Deprecated
    public get_result clone() {
      return new get_result(this);
    }

    public GetResp  getSuccess() {
      return this.success;
    }

    public get_result setSuccess(GetResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_result)
        return this.equals((get_result)that);
      return false;
    }

    public boolean equals(get_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(get_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GetResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("get_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class multiGet_args implements TBase, java.io.Serializable, Cloneable, Comparable<multiGet_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("multiGet_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public MultiGetReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, MultiGetReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(multiGet_args.class, metaDataMap);
    }

    public multiGet_args() {
    }

    public multiGet_args(
      MultiGetReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiGet_args(multiGet_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public multiGet_args deepCopy() {
      return new multiGet_args(this);
    }

    @Deprecated
    public multiGet_args clone() {
      return new multiGet_args(this);
    }

    public MultiGetReq  getReq() {
      return this.req;
    }

    public multiGet_args setReq(MultiGetReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((MultiGetReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof multiGet_args)
        return this.equals((multiGet_args)that);
      return false;
    }

    public boolean equals(multiGet_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(multiGet_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new MultiGetReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("multiGet_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class multiGet_result implements TBase, java.io.Serializable, Cloneable, Comparable<multiGet_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("multiGet_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public MultiGetResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, MultiGetResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(multiGet_result.class, metaDataMap);
    }

    public multiGet_result() {
    }

    public multiGet_result(
      MultiGetResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiGet_result(multiGet_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public multiGet_result deepCopy() {
      return new multiGet_result(this);
    }

    @Deprecated
    public multiGet_result clone() {
      return new multiGet_result(this);
    }

    public MultiGetResp  getSuccess() {
      return this.success;
    }

    public multiGet_result setSuccess(MultiGetResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((MultiGetResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof multiGet_result)
        return this.equals((multiGet_result)that);
      return false;
    }

    public boolean equals(multiGet_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(multiGet_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new MultiGetResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("multiGet_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class remove_args implements TBase, java.io.Serializable, Cloneable, Comparable<remove_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RemoveReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RemoveReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(remove_args.class, metaDataMap);
    }

    public remove_args() {
    }

    public remove_args(
      RemoveReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_args(remove_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public remove_args deepCopy() {
      return new remove_args(this);
    }

    @Deprecated
    public remove_args clone() {
      return new remove_args(this);
    }

    public RemoveReq  getReq() {
      return this.req;
    }

    public remove_args setReq(RemoveReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((RemoveReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_args)
        return this.equals((remove_args)that);
      return false;
    }

    public boolean equals(remove_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(remove_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new RemoveReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("remove_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class remove_result implements TBase, java.io.Serializable, Cloneable, Comparable<remove_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(remove_result.class, metaDataMap);
    }

    public remove_result() {
    }

    public remove_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_result(remove_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public remove_result deepCopy() {
      return new remove_result(this);
    }

    @Deprecated
    public remove_result clone() {
      return new remove_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public remove_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_result)
        return this.equals((remove_result)that);
      return false;
    }

    public boolean equals(remove_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(remove_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("remove_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class removeRange_args implements TBase, java.io.Serializable, Cloneable, Comparable<removeRange_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeRange_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RemoveRangeReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RemoveRangeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(removeRange_args.class, metaDataMap);
    }

    public removeRange_args() {
    }

    public removeRange_args(
      RemoveRangeReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeRange_args(removeRange_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public removeRange_args deepCopy() {
      return new removeRange_args(this);
    }

    @Deprecated
    public removeRange_args clone() {
      return new removeRange_args(this);
    }

    public RemoveRangeReq  getReq() {
      return this.req;
    }

    public removeRange_args setReq(RemoveRangeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((RemoveRangeReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof removeRange_args)
        return this.equals((removeRange_args)that);
      return false;
    }

    public boolean equals(removeRange_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(removeRange_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new RemoveRangeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("removeRange_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class removeRange_result implements TBase, java.io.Serializable, Cloneable, Comparable<removeRange_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeRange_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(removeRange_result.class, metaDataMap);
    }

    public removeRange_result() {
    }

    public removeRange_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeRange_result(removeRange_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public removeRange_result deepCopy() {
      return new removeRange_result(this);
    }

    @Deprecated
    public removeRange_result clone() {
      return new removeRange_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public removeRange_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof removeRange_result)
        return this.equals((removeRange_result)that);
      return false;
    }

    public boolean equals(removeRange_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(removeRange_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("removeRange_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class scan_args implements TBase, java.io.Serializable, Cloneable, Comparable<scan_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("scan_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ScanReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ScanReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(scan_args.class, metaDataMap);
    }

    public scan_args() {
    }

    public scan_args(
      ScanReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scan_args(scan_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public scan_args deepCopy() {
      return new scan_args(this);
    }

    @Deprecated
    public scan_args clone() {
      return new scan_args(this);
    }

    public ScanReq  getReq() {
      return this.req;
    }

    public scan_args setReq(ScanReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ScanReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scan_args)
        return this.equals((scan_args)that);
      return false;
    }

    public boolean equals(scan_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(scan_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ScanReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("scan_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class scan_result implements TBase, java.io.Serializable, Cloneable, Comparable<scan_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("scan_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ScanResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ScanResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(scan_result.class, metaDataMap);
    }

    public scan_result() {
    }

    public scan_result(
      ScanResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scan_result(scan_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public scan_result deepCopy() {
      return new scan_result(this);
    }

    @Deprecated
    public scan_result clone() {
      return new scan_result(this);
    }

    public ScanResp  getSuccess() {
      return this.success;
    }

    public scan_result setSuccess(ScanResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ScanResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scan_result)
        return this.equals((scan_result)that);
      return false;
    }

    public boolean equals(scan_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(scan_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ScanResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("scan_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createTagIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<createTagIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createTagIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateTagIndexReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateTagIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createTagIndex_args.class, metaDataMap);
    }

    public createTagIndex_args() {
    }

    public createTagIndex_args(
      CreateTagIndexReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTagIndex_args(createTagIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createTagIndex_args deepCopy() {
      return new createTagIndex_args(this);
    }

    @Deprecated
    public createTagIndex_args clone() {
      return new createTagIndex_args(this);
    }

    public CreateTagIndexReq  getReq() {
      return this.req;
    }

    public createTagIndex_args setReq(CreateTagIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((CreateTagIndexReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createTagIndex_args)
        return this.equals((createTagIndex_args)that);
      return false;
    }

    public boolean equals(createTagIndex_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createTagIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new CreateTagIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createTagIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createTagIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<createTagIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createTagIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createTagIndex_result.class, metaDataMap);
    }

    public createTagIndex_result() {
    }

    public createTagIndex_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTagIndex_result(createTagIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createTagIndex_result deepCopy() {
      return new createTagIndex_result(this);
    }

    @Deprecated
    public createTagIndex_result clone() {
      return new createTagIndex_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public createTagIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createTagIndex_result)
        return this.equals((createTagIndex_result)that);
      return false;
    }

    public boolean equals(createTagIndex_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createTagIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createTagIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropTagIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropTagIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTagIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropTagIndexReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropTagIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropTagIndex_args.class, metaDataMap);
    }

    public dropTagIndex_args() {
    }

    public dropTagIndex_args(
      DropTagIndexReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTagIndex_args(dropTagIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropTagIndex_args deepCopy() {
      return new dropTagIndex_args(this);
    }

    @Deprecated
    public dropTagIndex_args clone() {
      return new dropTagIndex_args(this);
    }

    public DropTagIndexReq  getReq() {
      return this.req;
    }

    public dropTagIndex_args setReq(DropTagIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((DropTagIndexReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropTagIndex_args)
        return this.equals((dropTagIndex_args)that);
      return false;
    }

    public boolean equals(dropTagIndex_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropTagIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new DropTagIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropTagIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropTagIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropTagIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTagIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropTagIndex_result.class, metaDataMap);
    }

    public dropTagIndex_result() {
    }

    public dropTagIndex_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTagIndex_result(dropTagIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropTagIndex_result deepCopy() {
      return new dropTagIndex_result(this);
    }

    @Deprecated
    public dropTagIndex_result clone() {
      return new dropTagIndex_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public dropTagIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropTagIndex_result)
        return this.equals((dropTagIndex_result)that);
      return false;
    }

    public boolean equals(dropTagIndex_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropTagIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropTagIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getTagIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<getTagIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getTagIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetTagIndexReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetTagIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getTagIndex_args.class, metaDataMap);
    }

    public getTagIndex_args() {
    }

    public getTagIndex_args(
      GetTagIndexReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTagIndex_args(getTagIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getTagIndex_args deepCopy() {
      return new getTagIndex_args(this);
    }

    @Deprecated
    public getTagIndex_args clone() {
      return new getTagIndex_args(this);
    }

    public GetTagIndexReq  getReq() {
      return this.req;
    }

    public getTagIndex_args setReq(GetTagIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetTagIndexReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTagIndex_args)
        return this.equals((getTagIndex_args)that);
      return false;
    }

    public boolean equals(getTagIndex_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getTagIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetTagIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getTagIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getTagIndex_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTagIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetTagIndexResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetTagIndexResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getTagIndex_result.class, metaDataMap);
    }

    public getTagIndex_result() {
    }

    public getTagIndex_result(
      GetTagIndexResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTagIndex_result(getTagIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getTagIndex_result deepCopy() {
      return new getTagIndex_result(this);
    }

    @Deprecated
    public getTagIndex_result clone() {
      return new getTagIndex_result(this);
    }

    public GetTagIndexResp  getSuccess() {
      return this.success;
    }

    public getTagIndex_result setSuccess(GetTagIndexResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetTagIndexResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTagIndex_result)
        return this.equals((getTagIndex_result)that);
      return false;
    }

    public boolean equals(getTagIndex_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GetTagIndexResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getTagIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listTagIndexes_args implements TBase, java.io.Serializable, Cloneable, Comparable<listTagIndexes_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTagIndexes_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListTagIndexesReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListTagIndexesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTagIndexes_args.class, metaDataMap);
    }

    public listTagIndexes_args() {
    }

    public listTagIndexes_args(
      ListTagIndexesReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTagIndexes_args(listTagIndexes_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listTagIndexes_args deepCopy() {
      return new listTagIndexes_args(this);
    }

    @Deprecated
    public listTagIndexes_args clone() {
      return new listTagIndexes_args(this);
    }

    public ListTagIndexesReq  getReq() {
      return this.req;
    }

    public listTagIndexes_args setReq(ListTagIndexesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListTagIndexesReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listTagIndexes_args)
        return this.equals((listTagIndexes_args)that);
      return false;
    }

    public boolean equals(listTagIndexes_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listTagIndexes_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListTagIndexesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTagIndexes_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listTagIndexes_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("listTagIndexes_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListTagIndexesResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListTagIndexesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTagIndexes_result.class, metaDataMap);
    }

    public listTagIndexes_result() {
    }

    public listTagIndexes_result(
      ListTagIndexesResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTagIndexes_result(listTagIndexes_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listTagIndexes_result deepCopy() {
      return new listTagIndexes_result(this);
    }

    @Deprecated
    public listTagIndexes_result clone() {
      return new listTagIndexes_result(this);
    }

    public ListTagIndexesResp  getSuccess() {
      return this.success;
    }

    public listTagIndexes_result setSuccess(ListTagIndexesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListTagIndexesResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listTagIndexes_result)
        return this.equals((listTagIndexes_result)that);
      return false;
    }

    public boolean equals(listTagIndexes_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListTagIndexesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTagIndexes_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class rebuildTagIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<rebuildTagIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("rebuildTagIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RebuildIndexReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RebuildIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(rebuildTagIndex_args.class, metaDataMap);
    }

    public rebuildTagIndex_args() {
    }

    public rebuildTagIndex_args(
      RebuildIndexReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rebuildTagIndex_args(rebuildTagIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public rebuildTagIndex_args deepCopy() {
      return new rebuildTagIndex_args(this);
    }

    @Deprecated
    public rebuildTagIndex_args clone() {
      return new rebuildTagIndex_args(this);
    }

    public RebuildIndexReq  getReq() {
      return this.req;
    }

    public rebuildTagIndex_args setReq(RebuildIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((RebuildIndexReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof rebuildTagIndex_args)
        return this.equals((rebuildTagIndex_args)that);
      return false;
    }

    public boolean equals(rebuildTagIndex_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(rebuildTagIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new RebuildIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("rebuildTagIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class rebuildTagIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<rebuildTagIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("rebuildTagIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(rebuildTagIndex_result.class, metaDataMap);
    }

    public rebuildTagIndex_result() {
    }

    public rebuildTagIndex_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rebuildTagIndex_result(rebuildTagIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public rebuildTagIndex_result deepCopy() {
      return new rebuildTagIndex_result(this);
    }

    @Deprecated
    public rebuildTagIndex_result clone() {
      return new rebuildTagIndex_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public rebuildTagIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof rebuildTagIndex_result)
        return this.equals((rebuildTagIndex_result)that);
      return false;
    }

    public boolean equals(rebuildTagIndex_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(rebuildTagIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("rebuildTagIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listTagIndexStatus_args implements TBase, java.io.Serializable, Cloneable, Comparable<listTagIndexStatus_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTagIndexStatus_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListIndexStatusReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListIndexStatusReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTagIndexStatus_args.class, metaDataMap);
    }

    public listTagIndexStatus_args() {
    }

    public listTagIndexStatus_args(
      ListIndexStatusReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTagIndexStatus_args(listTagIndexStatus_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listTagIndexStatus_args deepCopy() {
      return new listTagIndexStatus_args(this);
    }

    @Deprecated
    public listTagIndexStatus_args clone() {
      return new listTagIndexStatus_args(this);
    }

    public ListIndexStatusReq  getReq() {
      return this.req;
    }

    public listTagIndexStatus_args setReq(ListIndexStatusReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListIndexStatusReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listTagIndexStatus_args)
        return this.equals((listTagIndexStatus_args)that);
      return false;
    }

    public boolean equals(listTagIndexStatus_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listTagIndexStatus_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListIndexStatusReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTagIndexStatus_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listTagIndexStatus_result implements TBase, java.io.Serializable, Cloneable, Comparable<listTagIndexStatus_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTagIndexStatus_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListIndexStatusResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListIndexStatusResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTagIndexStatus_result.class, metaDataMap);
    }

    public listTagIndexStatus_result() {
    }

    public listTagIndexStatus_result(
      ListIndexStatusResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTagIndexStatus_result(listTagIndexStatus_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listTagIndexStatus_result deepCopy() {
      return new listTagIndexStatus_result(this);
    }

    @Deprecated
    public listTagIndexStatus_result clone() {
      return new listTagIndexStatus_result(this);
    }

    public ListIndexStatusResp  getSuccess() {
      return this.success;
    }

    public listTagIndexStatus_result setSuccess(ListIndexStatusResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListIndexStatusResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listTagIndexStatus_result)
        return this.equals((listTagIndexStatus_result)that);
      return false;
    }

    public boolean equals(listTagIndexStatus_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listTagIndexStatus_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListIndexStatusResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTagIndexStatus_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createEdgeIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<createEdgeIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createEdgeIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateEdgeIndexReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateEdgeIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createEdgeIndex_args.class, metaDataMap);
    }

    public createEdgeIndex_args() {
    }

    public createEdgeIndex_args(
      CreateEdgeIndexReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createEdgeIndex_args(createEdgeIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createEdgeIndex_args deepCopy() {
      return new createEdgeIndex_args(this);
    }

    @Deprecated
    public createEdgeIndex_args clone() {
      return new createEdgeIndex_args(this);
    }

    public CreateEdgeIndexReq  getReq() {
      return this.req;
    }

    public createEdgeIndex_args setReq(CreateEdgeIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((CreateEdgeIndexReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createEdgeIndex_args)
        return this.equals((createEdgeIndex_args)that);
      return false;
    }

    public boolean equals(createEdgeIndex_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createEdgeIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new CreateEdgeIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createEdgeIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createEdgeIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<createEdgeIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createEdgeIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createEdgeIndex_result.class, metaDataMap);
    }

    public createEdgeIndex_result() {
    }

    public createEdgeIndex_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createEdgeIndex_result(createEdgeIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createEdgeIndex_result deepCopy() {
      return new createEdgeIndex_result(this);
    }

    @Deprecated
    public createEdgeIndex_result clone() {
      return new createEdgeIndex_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public createEdgeIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createEdgeIndex_result)
        return this.equals((createEdgeIndex_result)that);
      return false;
    }

    public boolean equals(createEdgeIndex_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createEdgeIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createEdgeIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropEdgeIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropEdgeIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropEdgeIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropEdgeIndexReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropEdgeIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropEdgeIndex_args.class, metaDataMap);
    }

    public dropEdgeIndex_args() {
    }

    public dropEdgeIndex_args(
      DropEdgeIndexReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropEdgeIndex_args(dropEdgeIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropEdgeIndex_args deepCopy() {
      return new dropEdgeIndex_args(this);
    }

    @Deprecated
    public dropEdgeIndex_args clone() {
      return new dropEdgeIndex_args(this);
    }

    public DropEdgeIndexReq  getReq() {
      return this.req;
    }

    public dropEdgeIndex_args setReq(DropEdgeIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((DropEdgeIndexReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropEdgeIndex_args)
        return this.equals((dropEdgeIndex_args)that);
      return false;
    }

    public boolean equals(dropEdgeIndex_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropEdgeIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new DropEdgeIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropEdgeIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropEdgeIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropEdgeIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropEdgeIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropEdgeIndex_result.class, metaDataMap);
    }

    public dropEdgeIndex_result() {
    }

    public dropEdgeIndex_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropEdgeIndex_result(dropEdgeIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropEdgeIndex_result deepCopy() {
      return new dropEdgeIndex_result(this);
    }

    @Deprecated
    public dropEdgeIndex_result clone() {
      return new dropEdgeIndex_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public dropEdgeIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropEdgeIndex_result)
        return this.equals((dropEdgeIndex_result)that);
      return false;
    }

    public boolean equals(dropEdgeIndex_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropEdgeIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropEdgeIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getEdgeIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<getEdgeIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getEdgeIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetEdgeIndexReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetEdgeIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getEdgeIndex_args.class, metaDataMap);
    }

    public getEdgeIndex_args() {
    }

    public getEdgeIndex_args(
      GetEdgeIndexReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEdgeIndex_args(getEdgeIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getEdgeIndex_args deepCopy() {
      return new getEdgeIndex_args(this);
    }

    @Deprecated
    public getEdgeIndex_args clone() {
      return new getEdgeIndex_args(this);
    }

    public GetEdgeIndexReq  getReq() {
      return this.req;
    }

    public getEdgeIndex_args setReq(GetEdgeIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetEdgeIndexReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getEdgeIndex_args)
        return this.equals((getEdgeIndex_args)that);
      return false;
    }

    public boolean equals(getEdgeIndex_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getEdgeIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetEdgeIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getEdgeIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getEdgeIndex_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getEdgeIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetEdgeIndexResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetEdgeIndexResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getEdgeIndex_result.class, metaDataMap);
    }

    public getEdgeIndex_result() {
    }

    public getEdgeIndex_result(
      GetEdgeIndexResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEdgeIndex_result(getEdgeIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getEdgeIndex_result deepCopy() {
      return new getEdgeIndex_result(this);
    }

    @Deprecated
    public getEdgeIndex_result clone() {
      return new getEdgeIndex_result(this);
    }

    public GetEdgeIndexResp  getSuccess() {
      return this.success;
    }

    public getEdgeIndex_result setSuccess(GetEdgeIndexResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetEdgeIndexResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getEdgeIndex_result)
        return this.equals((getEdgeIndex_result)that);
      return false;
    }

    public boolean equals(getEdgeIndex_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GetEdgeIndexResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getEdgeIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listEdgeIndexes_args implements TBase, java.io.Serializable, Cloneable, Comparable<listEdgeIndexes_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdgeIndexes_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListEdgeIndexesReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListEdgeIndexesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdgeIndexes_args.class, metaDataMap);
    }

    public listEdgeIndexes_args() {
    }

    public listEdgeIndexes_args(
      ListEdgeIndexesReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdgeIndexes_args(listEdgeIndexes_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listEdgeIndexes_args deepCopy() {
      return new listEdgeIndexes_args(this);
    }

    @Deprecated
    public listEdgeIndexes_args clone() {
      return new listEdgeIndexes_args(this);
    }

    public ListEdgeIndexesReq  getReq() {
      return this.req;
    }

    public listEdgeIndexes_args setReq(ListEdgeIndexesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListEdgeIndexesReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listEdgeIndexes_args)
        return this.equals((listEdgeIndexes_args)that);
      return false;
    }

    public boolean equals(listEdgeIndexes_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listEdgeIndexes_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListEdgeIndexesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdgeIndexes_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listEdgeIndexes_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdgeIndexes_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListEdgeIndexesResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListEdgeIndexesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdgeIndexes_result.class, metaDataMap);
    }

    public listEdgeIndexes_result() {
    }

    public listEdgeIndexes_result(
      ListEdgeIndexesResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdgeIndexes_result(listEdgeIndexes_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listEdgeIndexes_result deepCopy() {
      return new listEdgeIndexes_result(this);
    }

    @Deprecated
    public listEdgeIndexes_result clone() {
      return new listEdgeIndexes_result(this);
    }

    public ListEdgeIndexesResp  getSuccess() {
      return this.success;
    }

    public listEdgeIndexes_result setSuccess(ListEdgeIndexesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListEdgeIndexesResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listEdgeIndexes_result)
        return this.equals((listEdgeIndexes_result)that);
      return false;
    }

    public boolean equals(listEdgeIndexes_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListEdgeIndexesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdgeIndexes_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class rebuildEdgeIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<rebuildEdgeIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("rebuildEdgeIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RebuildIndexReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RebuildIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(rebuildEdgeIndex_args.class, metaDataMap);
    }

    public rebuildEdgeIndex_args() {
    }

    public rebuildEdgeIndex_args(
      RebuildIndexReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rebuildEdgeIndex_args(rebuildEdgeIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public rebuildEdgeIndex_args deepCopy() {
      return new rebuildEdgeIndex_args(this);
    }

    @Deprecated
    public rebuildEdgeIndex_args clone() {
      return new rebuildEdgeIndex_args(this);
    }

    public RebuildIndexReq  getReq() {
      return this.req;
    }

    public rebuildEdgeIndex_args setReq(RebuildIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((RebuildIndexReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof rebuildEdgeIndex_args)
        return this.equals((rebuildEdgeIndex_args)that);
      return false;
    }

    public boolean equals(rebuildEdgeIndex_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(rebuildEdgeIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new RebuildIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("rebuildEdgeIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class rebuildEdgeIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<rebuildEdgeIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("rebuildEdgeIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(rebuildEdgeIndex_result.class, metaDataMap);
    }

    public rebuildEdgeIndex_result() {
    }

    public rebuildEdgeIndex_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rebuildEdgeIndex_result(rebuildEdgeIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public rebuildEdgeIndex_result deepCopy() {
      return new rebuildEdgeIndex_result(this);
    }

    @Deprecated
    public rebuildEdgeIndex_result clone() {
      return new rebuildEdgeIndex_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public rebuildEdgeIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof rebuildEdgeIndex_result)
        return this.equals((rebuildEdgeIndex_result)that);
      return false;
    }

    public boolean equals(rebuildEdgeIndex_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(rebuildEdgeIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("rebuildEdgeIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listEdgeIndexStatus_args implements TBase, java.io.Serializable, Cloneable, Comparable<listEdgeIndexStatus_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdgeIndexStatus_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListIndexStatusReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListIndexStatusReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdgeIndexStatus_args.class, metaDataMap);
    }

    public listEdgeIndexStatus_args() {
    }

    public listEdgeIndexStatus_args(
      ListIndexStatusReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdgeIndexStatus_args(listEdgeIndexStatus_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listEdgeIndexStatus_args deepCopy() {
      return new listEdgeIndexStatus_args(this);
    }

    @Deprecated
    public listEdgeIndexStatus_args clone() {
      return new listEdgeIndexStatus_args(this);
    }

    public ListIndexStatusReq  getReq() {
      return this.req;
    }

    public listEdgeIndexStatus_args setReq(ListIndexStatusReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListIndexStatusReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listEdgeIndexStatus_args)
        return this.equals((listEdgeIndexStatus_args)that);
      return false;
    }

    public boolean equals(listEdgeIndexStatus_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listEdgeIndexStatus_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListIndexStatusReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdgeIndexStatus_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listEdgeIndexStatus_result implements TBase, java.io.Serializable, Cloneable, Comparable<listEdgeIndexStatus_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdgeIndexStatus_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListIndexStatusResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListIndexStatusResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdgeIndexStatus_result.class, metaDataMap);
    }

    public listEdgeIndexStatus_result() {
    }

    public listEdgeIndexStatus_result(
      ListIndexStatusResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdgeIndexStatus_result(listEdgeIndexStatus_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listEdgeIndexStatus_result deepCopy() {
      return new listEdgeIndexStatus_result(this);
    }

    @Deprecated
    public listEdgeIndexStatus_result clone() {
      return new listEdgeIndexStatus_result(this);
    }

    public ListIndexStatusResp  getSuccess() {
      return this.success;
    }

    public listEdgeIndexStatus_result setSuccess(ListIndexStatusResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListIndexStatusResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listEdgeIndexStatus_result)
        return this.equals((listEdgeIndexStatus_result)that);
      return false;
    }

    public boolean equals(listEdgeIndexStatus_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listEdgeIndexStatus_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListIndexStatusResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdgeIndexStatus_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createUser_args implements TBase, java.io.Serializable, Cloneable, Comparable<createUser_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createUser_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateUserReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateUserReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createUser_args.class, metaDataMap);
    }

    public createUser_args() {
    }

    public createUser_args(
      CreateUserReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createUser_args(createUser_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createUser_args deepCopy() {
      return new createUser_args(this);
    }

    @Deprecated
    public createUser_args clone() {
      return new createUser_args(this);
    }

    public CreateUserReq  getReq() {
      return this.req;
    }

    public createUser_args setReq(CreateUserReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((CreateUserReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createUser_args)
        return this.equals((createUser_args)that);
      return false;
    }

    public boolean equals(createUser_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createUser_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new CreateUserReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createUser_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createUser_result implements TBase, java.io.Serializable, Cloneable, Comparable<createUser_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createUser_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createUser_result.class, metaDataMap);
    }

    public createUser_result() {
    }

    public createUser_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createUser_result(createUser_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createUser_result deepCopy() {
      return new createUser_result(this);
    }

    @Deprecated
    public createUser_result clone() {
      return new createUser_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public createUser_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createUser_result)
        return this.equals((createUser_result)that);
      return false;
    }

    public boolean equals(createUser_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createUser_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createUser_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropUser_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropUser_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropUser_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropUserReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropUserReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropUser_args.class, metaDataMap);
    }

    public dropUser_args() {
    }

    public dropUser_args(
      DropUserReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropUser_args(dropUser_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropUser_args deepCopy() {
      return new dropUser_args(this);
    }

    @Deprecated
    public dropUser_args clone() {
      return new dropUser_args(this);
    }

    public DropUserReq  getReq() {
      return this.req;
    }

    public dropUser_args setReq(DropUserReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((DropUserReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropUser_args)
        return this.equals((dropUser_args)that);
      return false;
    }

    public boolean equals(dropUser_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropUser_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new DropUserReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropUser_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropUser_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropUser_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropUser_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropUser_result.class, metaDataMap);
    }

    public dropUser_result() {
    }

    public dropUser_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropUser_result(dropUser_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropUser_result deepCopy() {
      return new dropUser_result(this);
    }

    @Deprecated
    public dropUser_result clone() {
      return new dropUser_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public dropUser_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropUser_result)
        return this.equals((dropUser_result)that);
      return false;
    }

    public boolean equals(dropUser_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropUser_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropUser_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class alterUser_args implements TBase, java.io.Serializable, Cloneable, Comparable<alterUser_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterUser_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AlterUserReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AlterUserReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterUser_args.class, metaDataMap);
    }

    public alterUser_args() {
    }

    public alterUser_args(
      AlterUserReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterUser_args(alterUser_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public alterUser_args deepCopy() {
      return new alterUser_args(this);
    }

    @Deprecated
    public alterUser_args clone() {
      return new alterUser_args(this);
    }

    public AlterUserReq  getReq() {
      return this.req;
    }

    public alterUser_args setReq(AlterUserReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((AlterUserReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alterUser_args)
        return this.equals((alterUser_args)that);
      return false;
    }

    public boolean equals(alterUser_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(alterUser_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new AlterUserReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterUser_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class alterUser_result implements TBase, java.io.Serializable, Cloneable, Comparable<alterUser_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterUser_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterUser_result.class, metaDataMap);
    }

    public alterUser_result() {
    }

    public alterUser_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterUser_result(alterUser_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public alterUser_result deepCopy() {
      return new alterUser_result(this);
    }

    @Deprecated
    public alterUser_result clone() {
      return new alterUser_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public alterUser_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alterUser_result)
        return this.equals((alterUser_result)that);
      return false;
    }

    public boolean equals(alterUser_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(alterUser_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterUser_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class grantRole_args implements TBase, java.io.Serializable, Cloneable, Comparable<grantRole_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("grantRole_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GrantRoleReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GrantRoleReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(grantRole_args.class, metaDataMap);
    }

    public grantRole_args() {
    }

    public grantRole_args(
      GrantRoleReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public grantRole_args(grantRole_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public grantRole_args deepCopy() {
      return new grantRole_args(this);
    }

    @Deprecated
    public grantRole_args clone() {
      return new grantRole_args(this);
    }

    public GrantRoleReq  getReq() {
      return this.req;
    }

    public grantRole_args setReq(GrantRoleReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GrantRoleReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof grantRole_args)
        return this.equals((grantRole_args)that);
      return false;
    }

    public boolean equals(grantRole_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(grantRole_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GrantRoleReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("grantRole_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class grantRole_result implements TBase, java.io.Serializable, Cloneable, Comparable<grantRole_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("grantRole_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(grantRole_result.class, metaDataMap);
    }

    public grantRole_result() {
    }

    public grantRole_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public grantRole_result(grantRole_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public grantRole_result deepCopy() {
      return new grantRole_result(this);
    }

    @Deprecated
    public grantRole_result clone() {
      return new grantRole_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public grantRole_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof grantRole_result)
        return this.equals((grantRole_result)that);
      return false;
    }

    public boolean equals(grantRole_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(grantRole_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("grantRole_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class revokeRole_args implements TBase, java.io.Serializable, Cloneable, Comparable<revokeRole_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("revokeRole_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RevokeRoleReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RevokeRoleReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(revokeRole_args.class, metaDataMap);
    }

    public revokeRole_args() {
    }

    public revokeRole_args(
      RevokeRoleReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public revokeRole_args(revokeRole_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public revokeRole_args deepCopy() {
      return new revokeRole_args(this);
    }

    @Deprecated
    public revokeRole_args clone() {
      return new revokeRole_args(this);
    }

    public RevokeRoleReq  getReq() {
      return this.req;
    }

    public revokeRole_args setReq(RevokeRoleReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((RevokeRoleReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof revokeRole_args)
        return this.equals((revokeRole_args)that);
      return false;
    }

    public boolean equals(revokeRole_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(revokeRole_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new RevokeRoleReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("revokeRole_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class revokeRole_result implements TBase, java.io.Serializable, Cloneable, Comparable<revokeRole_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("revokeRole_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(revokeRole_result.class, metaDataMap);
    }

    public revokeRole_result() {
    }

    public revokeRole_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public revokeRole_result(revokeRole_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public revokeRole_result deepCopy() {
      return new revokeRole_result(this);
    }

    @Deprecated
    public revokeRole_result clone() {
      return new revokeRole_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public revokeRole_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof revokeRole_result)
        return this.equals((revokeRole_result)that);
      return false;
    }

    public boolean equals(revokeRole_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(revokeRole_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("revokeRole_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listUsers_args implements TBase, java.io.Serializable, Cloneable, Comparable<listUsers_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listUsers_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListUsersReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListUsersReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listUsers_args.class, metaDataMap);
    }

    public listUsers_args() {
    }

    public listUsers_args(
      ListUsersReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listUsers_args(listUsers_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listUsers_args deepCopy() {
      return new listUsers_args(this);
    }

    @Deprecated
    public listUsers_args clone() {
      return new listUsers_args(this);
    }

    public ListUsersReq  getReq() {
      return this.req;
    }

    public listUsers_args setReq(ListUsersReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListUsersReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listUsers_args)
        return this.equals((listUsers_args)that);
      return false;
    }

    public boolean equals(listUsers_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listUsers_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListUsersReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listUsers_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listUsers_result implements TBase, java.io.Serializable, Cloneable, Comparable<listUsers_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listUsers_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListUsersResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListUsersResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listUsers_result.class, metaDataMap);
    }

    public listUsers_result() {
    }

    public listUsers_result(
      ListUsersResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listUsers_result(listUsers_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listUsers_result deepCopy() {
      return new listUsers_result(this);
    }

    @Deprecated
    public listUsers_result clone() {
      return new listUsers_result(this);
    }

    public ListUsersResp  getSuccess() {
      return this.success;
    }

    public listUsers_result setSuccess(ListUsersResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListUsersResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listUsers_result)
        return this.equals((listUsers_result)that);
      return false;
    }

    public boolean equals(listUsers_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listUsers_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListUsersResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listUsers_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listRoles_args implements TBase, java.io.Serializable, Cloneable, Comparable<listRoles_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listRoles_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListRolesReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListRolesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listRoles_args.class, metaDataMap);
    }

    public listRoles_args() {
    }

    public listRoles_args(
      ListRolesReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listRoles_args(listRoles_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listRoles_args deepCopy() {
      return new listRoles_args(this);
    }

    @Deprecated
    public listRoles_args clone() {
      return new listRoles_args(this);
    }

    public ListRolesReq  getReq() {
      return this.req;
    }

    public listRoles_args setReq(ListRolesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListRolesReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listRoles_args)
        return this.equals((listRoles_args)that);
      return false;
    }

    public boolean equals(listRoles_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listRoles_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListRolesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listRoles_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listRoles_result implements TBase, java.io.Serializable, Cloneable, Comparable<listRoles_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listRoles_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListRolesResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListRolesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listRoles_result.class, metaDataMap);
    }

    public listRoles_result() {
    }

    public listRoles_result(
      ListRolesResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listRoles_result(listRoles_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listRoles_result deepCopy() {
      return new listRoles_result(this);
    }

    @Deprecated
    public listRoles_result clone() {
      return new listRoles_result(this);
    }

    public ListRolesResp  getSuccess() {
      return this.success;
    }

    public listRoles_result setSuccess(ListRolesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListRolesResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listRoles_result)
        return this.equals((listRoles_result)that);
      return false;
    }

    public boolean equals(listRoles_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listRoles_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListRolesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listRoles_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getUserRoles_args implements TBase, java.io.Serializable, Cloneable, Comparable<getUserRoles_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getUserRoles_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetUserRolesReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetUserRolesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getUserRoles_args.class, metaDataMap);
    }

    public getUserRoles_args() {
    }

    public getUserRoles_args(
      GetUserRolesReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getUserRoles_args(getUserRoles_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getUserRoles_args deepCopy() {
      return new getUserRoles_args(this);
    }

    @Deprecated
    public getUserRoles_args clone() {
      return new getUserRoles_args(this);
    }

    public GetUserRolesReq  getReq() {
      return this.req;
    }

    public getUserRoles_args setReq(GetUserRolesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetUserRolesReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getUserRoles_args)
        return this.equals((getUserRoles_args)that);
      return false;
    }

    public boolean equals(getUserRoles_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getUserRoles_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetUserRolesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getUserRoles_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getUserRoles_result implements TBase, java.io.Serializable, Cloneable, Comparable<getUserRoles_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getUserRoles_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListRolesResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListRolesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getUserRoles_result.class, metaDataMap);
    }

    public getUserRoles_result() {
    }

    public getUserRoles_result(
      ListRolesResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getUserRoles_result(getUserRoles_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getUserRoles_result deepCopy() {
      return new getUserRoles_result(this);
    }

    @Deprecated
    public getUserRoles_result clone() {
      return new getUserRoles_result(this);
    }

    public ListRolesResp  getSuccess() {
      return this.success;
    }

    public getUserRoles_result setSuccess(ListRolesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListRolesResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getUserRoles_result)
        return this.equals((getUserRoles_result)that);
      return false;
    }

    public boolean equals(getUserRoles_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getUserRoles_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListRolesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getUserRoles_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class changePassword_args implements TBase, java.io.Serializable, Cloneable, Comparable<changePassword_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("changePassword_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ChangePasswordReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ChangePasswordReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(changePassword_args.class, metaDataMap);
    }

    public changePassword_args() {
    }

    public changePassword_args(
      ChangePasswordReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public changePassword_args(changePassword_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public changePassword_args deepCopy() {
      return new changePassword_args(this);
    }

    @Deprecated
    public changePassword_args clone() {
      return new changePassword_args(this);
    }

    public ChangePasswordReq  getReq() {
      return this.req;
    }

    public changePassword_args setReq(ChangePasswordReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ChangePasswordReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof changePassword_args)
        return this.equals((changePassword_args)that);
      return false;
    }

    public boolean equals(changePassword_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(changePassword_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ChangePasswordReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("changePassword_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class changePassword_result implements TBase, java.io.Serializable, Cloneable, Comparable<changePassword_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("changePassword_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(changePassword_result.class, metaDataMap);
    }

    public changePassword_result() {
    }

    public changePassword_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public changePassword_result(changePassword_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public changePassword_result deepCopy() {
      return new changePassword_result(this);
    }

    @Deprecated
    public changePassword_result clone() {
      return new changePassword_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public changePassword_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof changePassword_result)
        return this.equals((changePassword_result)that);
      return false;
    }

    public boolean equals(changePassword_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(changePassword_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("changePassword_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class heartBeat_args implements TBase, java.io.Serializable, Cloneable, Comparable<heartBeat_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("heartBeat_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public HBReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, HBReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(heartBeat_args.class, metaDataMap);
    }

    public heartBeat_args() {
    }

    public heartBeat_args(
      HBReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public heartBeat_args(heartBeat_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public heartBeat_args deepCopy() {
      return new heartBeat_args(this);
    }

    @Deprecated
    public heartBeat_args clone() {
      return new heartBeat_args(this);
    }

    public HBReq  getReq() {
      return this.req;
    }

    public heartBeat_args setReq(HBReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((HBReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof heartBeat_args)
        return this.equals((heartBeat_args)that);
      return false;
    }

    public boolean equals(heartBeat_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(heartBeat_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new HBReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("heartBeat_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class heartBeat_result implements TBase, java.io.Serializable, Cloneable, Comparable<heartBeat_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("heartBeat_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public HBResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, HBResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(heartBeat_result.class, metaDataMap);
    }

    public heartBeat_result() {
    }

    public heartBeat_result(
      HBResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public heartBeat_result(heartBeat_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public heartBeat_result deepCopy() {
      return new heartBeat_result(this);
    }

    @Deprecated
    public heartBeat_result clone() {
      return new heartBeat_result(this);
    }

    public HBResp  getSuccess() {
      return this.success;
    }

    public heartBeat_result setSuccess(HBResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((HBResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof heartBeat_result)
        return this.equals((heartBeat_result)that);
      return false;
    }

    public boolean equals(heartBeat_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(heartBeat_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new HBResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("heartBeat_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class balance_args implements TBase, java.io.Serializable, Cloneable, Comparable<balance_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("balance_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public BalanceReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, BalanceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(balance_args.class, metaDataMap);
    }

    public balance_args() {
    }

    public balance_args(
      BalanceReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public balance_args(balance_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public balance_args deepCopy() {
      return new balance_args(this);
    }

    @Deprecated
    public balance_args clone() {
      return new balance_args(this);
    }

    public BalanceReq  getReq() {
      return this.req;
    }

    public balance_args setReq(BalanceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((BalanceReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof balance_args)
        return this.equals((balance_args)that);
      return false;
    }

    public boolean equals(balance_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(balance_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new BalanceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("balance_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class balance_result implements TBase, java.io.Serializable, Cloneable, Comparable<balance_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("balance_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public BalanceResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, BalanceResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(balance_result.class, metaDataMap);
    }

    public balance_result() {
    }

    public balance_result(
      BalanceResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public balance_result(balance_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public balance_result deepCopy() {
      return new balance_result(this);
    }

    @Deprecated
    public balance_result clone() {
      return new balance_result(this);
    }

    public BalanceResp  getSuccess() {
      return this.success;
    }

    public balance_result setSuccess(BalanceResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((BalanceResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof balance_result)
        return this.equals((balance_result)that);
      return false;
    }

    public boolean equals(balance_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(balance_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new BalanceResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("balance_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class leaderBalance_args implements TBase, java.io.Serializable, Cloneable, Comparable<leaderBalance_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("leaderBalance_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public LeaderBalanceReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, LeaderBalanceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(leaderBalance_args.class, metaDataMap);
    }

    public leaderBalance_args() {
    }

    public leaderBalance_args(
      LeaderBalanceReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public leaderBalance_args(leaderBalance_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public leaderBalance_args deepCopy() {
      return new leaderBalance_args(this);
    }

    @Deprecated
    public leaderBalance_args clone() {
      return new leaderBalance_args(this);
    }

    public LeaderBalanceReq  getReq() {
      return this.req;
    }

    public leaderBalance_args setReq(LeaderBalanceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((LeaderBalanceReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof leaderBalance_args)
        return this.equals((leaderBalance_args)that);
      return false;
    }

    public boolean equals(leaderBalance_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(leaderBalance_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new LeaderBalanceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("leaderBalance_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class leaderBalance_result implements TBase, java.io.Serializable, Cloneable, Comparable<leaderBalance_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("leaderBalance_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(leaderBalance_result.class, metaDataMap);
    }

    public leaderBalance_result() {
    }

    public leaderBalance_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public leaderBalance_result(leaderBalance_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public leaderBalance_result deepCopy() {
      return new leaderBalance_result(this);
    }

    @Deprecated
    public leaderBalance_result clone() {
      return new leaderBalance_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public leaderBalance_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof leaderBalance_result)
        return this.equals((leaderBalance_result)that);
      return false;
    }

    public boolean equals(leaderBalance_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(leaderBalance_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("leaderBalance_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class regConfig_args implements TBase, java.io.Serializable, Cloneable, Comparable<regConfig_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("regConfig_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RegConfigReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RegConfigReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(regConfig_args.class, metaDataMap);
    }

    public regConfig_args() {
    }

    public regConfig_args(
      RegConfigReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public regConfig_args(regConfig_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public regConfig_args deepCopy() {
      return new regConfig_args(this);
    }

    @Deprecated
    public regConfig_args clone() {
      return new regConfig_args(this);
    }

    public RegConfigReq  getReq() {
      return this.req;
    }

    public regConfig_args setReq(RegConfigReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((RegConfigReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof regConfig_args)
        return this.equals((regConfig_args)that);
      return false;
    }

    public boolean equals(regConfig_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(regConfig_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new RegConfigReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("regConfig_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class regConfig_result implements TBase, java.io.Serializable, Cloneable, Comparable<regConfig_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("regConfig_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(regConfig_result.class, metaDataMap);
    }

    public regConfig_result() {
    }

    public regConfig_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public regConfig_result(regConfig_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public regConfig_result deepCopy() {
      return new regConfig_result(this);
    }

    @Deprecated
    public regConfig_result clone() {
      return new regConfig_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public regConfig_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof regConfig_result)
        return this.equals((regConfig_result)that);
      return false;
    }

    public boolean equals(regConfig_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(regConfig_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("regConfig_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getConfig_args implements TBase, java.io.Serializable, Cloneable, Comparable<getConfig_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getConfig_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetConfigReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetConfigReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getConfig_args.class, metaDataMap);
    }

    public getConfig_args() {
    }

    public getConfig_args(
      GetConfigReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConfig_args(getConfig_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getConfig_args deepCopy() {
      return new getConfig_args(this);
    }

    @Deprecated
    public getConfig_args clone() {
      return new getConfig_args(this);
    }

    public GetConfigReq  getReq() {
      return this.req;
    }

    public getConfig_args setReq(GetConfigReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetConfigReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getConfig_args)
        return this.equals((getConfig_args)that);
      return false;
    }

    public boolean equals(getConfig_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getConfig_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetConfigReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getConfig_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getConfig_result implements TBase, java.io.Serializable, Cloneable, Comparable<getConfig_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getConfig_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetConfigResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetConfigResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getConfig_result.class, metaDataMap);
    }

    public getConfig_result() {
    }

    public getConfig_result(
      GetConfigResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConfig_result(getConfig_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getConfig_result deepCopy() {
      return new getConfig_result(this);
    }

    @Deprecated
    public getConfig_result clone() {
      return new getConfig_result(this);
    }

    public GetConfigResp  getSuccess() {
      return this.success;
    }

    public getConfig_result setSuccess(GetConfigResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetConfigResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getConfig_result)
        return this.equals((getConfig_result)that);
      return false;
    }

    public boolean equals(getConfig_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getConfig_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GetConfigResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getConfig_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class setConfig_args implements TBase, java.io.Serializable, Cloneable, Comparable<setConfig_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("setConfig_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public SetConfigReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, SetConfigReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(setConfig_args.class, metaDataMap);
    }

    public setConfig_args() {
    }

    public setConfig_args(
      SetConfigReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setConfig_args(setConfig_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public setConfig_args deepCopy() {
      return new setConfig_args(this);
    }

    @Deprecated
    public setConfig_args clone() {
      return new setConfig_args(this);
    }

    public SetConfigReq  getReq() {
      return this.req;
    }

    public setConfig_args setReq(SetConfigReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((SetConfigReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setConfig_args)
        return this.equals((setConfig_args)that);
      return false;
    }

    public boolean equals(setConfig_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(setConfig_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new SetConfigReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("setConfig_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class setConfig_result implements TBase, java.io.Serializable, Cloneable, Comparable<setConfig_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("setConfig_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(setConfig_result.class, metaDataMap);
    }

    public setConfig_result() {
    }

    public setConfig_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setConfig_result(setConfig_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public setConfig_result deepCopy() {
      return new setConfig_result(this);
    }

    @Deprecated
    public setConfig_result clone() {
      return new setConfig_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public setConfig_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setConfig_result)
        return this.equals((setConfig_result)that);
      return false;
    }

    public boolean equals(setConfig_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(setConfig_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("setConfig_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listConfigs_args implements TBase, java.io.Serializable, Cloneable, Comparable<listConfigs_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listConfigs_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListConfigsReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListConfigsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listConfigs_args.class, metaDataMap);
    }

    public listConfigs_args() {
    }

    public listConfigs_args(
      ListConfigsReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listConfigs_args(listConfigs_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listConfigs_args deepCopy() {
      return new listConfigs_args(this);
    }

    @Deprecated
    public listConfigs_args clone() {
      return new listConfigs_args(this);
    }

    public ListConfigsReq  getReq() {
      return this.req;
    }

    public listConfigs_args setReq(ListConfigsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListConfigsReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listConfigs_args)
        return this.equals((listConfigs_args)that);
      return false;
    }

    public boolean equals(listConfigs_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listConfigs_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListConfigsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listConfigs_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listConfigs_result implements TBase, java.io.Serializable, Cloneable, Comparable<listConfigs_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listConfigs_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListConfigsResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListConfigsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listConfigs_result.class, metaDataMap);
    }

    public listConfigs_result() {
    }

    public listConfigs_result(
      ListConfigsResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listConfigs_result(listConfigs_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listConfigs_result deepCopy() {
      return new listConfigs_result(this);
    }

    @Deprecated
    public listConfigs_result clone() {
      return new listConfigs_result(this);
    }

    public ListConfigsResp  getSuccess() {
      return this.success;
    }

    public listConfigs_result setSuccess(ListConfigsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListConfigsResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listConfigs_result)
        return this.equals((listConfigs_result)that);
      return false;
    }

    public boolean equals(listConfigs_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listConfigs_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListConfigsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listConfigs_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createSnapshot_args implements TBase, java.io.Serializable, Cloneable, Comparable<createSnapshot_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSnapshot_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateSnapshotReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateSnapshotReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSnapshot_args.class, metaDataMap);
    }

    public createSnapshot_args() {
    }

    public createSnapshot_args(
      CreateSnapshotReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSnapshot_args(createSnapshot_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createSnapshot_args deepCopy() {
      return new createSnapshot_args(this);
    }

    @Deprecated
    public createSnapshot_args clone() {
      return new createSnapshot_args(this);
    }

    public CreateSnapshotReq  getReq() {
      return this.req;
    }

    public createSnapshot_args setReq(CreateSnapshotReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((CreateSnapshotReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createSnapshot_args)
        return this.equals((createSnapshot_args)that);
      return false;
    }

    public boolean equals(createSnapshot_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createSnapshot_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new CreateSnapshotReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSnapshot_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createSnapshot_result implements TBase, java.io.Serializable, Cloneable, Comparable<createSnapshot_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSnapshot_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSnapshot_result.class, metaDataMap);
    }

    public createSnapshot_result() {
    }

    public createSnapshot_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSnapshot_result(createSnapshot_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createSnapshot_result deepCopy() {
      return new createSnapshot_result(this);
    }

    @Deprecated
    public createSnapshot_result clone() {
      return new createSnapshot_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public createSnapshot_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createSnapshot_result)
        return this.equals((createSnapshot_result)that);
      return false;
    }

    public boolean equals(createSnapshot_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createSnapshot_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSnapshot_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropSnapshot_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropSnapshot_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropSnapshot_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropSnapshotReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropSnapshotReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropSnapshot_args.class, metaDataMap);
    }

    public dropSnapshot_args() {
    }

    public dropSnapshot_args(
      DropSnapshotReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropSnapshot_args(dropSnapshot_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropSnapshot_args deepCopy() {
      return new dropSnapshot_args(this);
    }

    @Deprecated
    public dropSnapshot_args clone() {
      return new dropSnapshot_args(this);
    }

    public DropSnapshotReq  getReq() {
      return this.req;
    }

    public dropSnapshot_args setReq(DropSnapshotReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((DropSnapshotReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropSnapshot_args)
        return this.equals((dropSnapshot_args)that);
      return false;
    }

    public boolean equals(dropSnapshot_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropSnapshot_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new DropSnapshotReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropSnapshot_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropSnapshot_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropSnapshot_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropSnapshot_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropSnapshot_result.class, metaDataMap);
    }

    public dropSnapshot_result() {
    }

    public dropSnapshot_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropSnapshot_result(dropSnapshot_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropSnapshot_result deepCopy() {
      return new dropSnapshot_result(this);
    }

    @Deprecated
    public dropSnapshot_result clone() {
      return new dropSnapshot_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public dropSnapshot_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropSnapshot_result)
        return this.equals((dropSnapshot_result)that);
      return false;
    }

    public boolean equals(dropSnapshot_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropSnapshot_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropSnapshot_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listSnapshots_args implements TBase, java.io.Serializable, Cloneable, Comparable<listSnapshots_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSnapshots_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListSnapshotsReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSnapshotsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSnapshots_args.class, metaDataMap);
    }

    public listSnapshots_args() {
    }

    public listSnapshots_args(
      ListSnapshotsReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSnapshots_args(listSnapshots_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listSnapshots_args deepCopy() {
      return new listSnapshots_args(this);
    }

    @Deprecated
    public listSnapshots_args clone() {
      return new listSnapshots_args(this);
    }

    public ListSnapshotsReq  getReq() {
      return this.req;
    }

    public listSnapshots_args setReq(ListSnapshotsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListSnapshotsReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listSnapshots_args)
        return this.equals((listSnapshots_args)that);
      return false;
    }

    public boolean equals(listSnapshots_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listSnapshots_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListSnapshotsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSnapshots_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listSnapshots_result implements TBase, java.io.Serializable, Cloneable, Comparable<listSnapshots_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSnapshots_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListSnapshotsResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSnapshotsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSnapshots_result.class, metaDataMap);
    }

    public listSnapshots_result() {
    }

    public listSnapshots_result(
      ListSnapshotsResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSnapshots_result(listSnapshots_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listSnapshots_result deepCopy() {
      return new listSnapshots_result(this);
    }

    @Deprecated
    public listSnapshots_result clone() {
      return new listSnapshots_result(this);
    }

    public ListSnapshotsResp  getSuccess() {
      return this.success;
    }

    public listSnapshots_result setSuccess(ListSnapshotsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListSnapshotsResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listSnapshots_result)
        return this.equals((listSnapshots_result)that);
      return false;
    }

    public boolean equals(listSnapshots_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listSnapshots_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListSnapshotsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSnapshots_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class runAdminJob_args implements TBase, java.io.Serializable, Cloneable, Comparable<runAdminJob_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("runAdminJob_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AdminJobReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AdminJobReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(runAdminJob_args.class, metaDataMap);
    }

    public runAdminJob_args() {
    }

    public runAdminJob_args(
      AdminJobReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public runAdminJob_args(runAdminJob_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public runAdminJob_args deepCopy() {
      return new runAdminJob_args(this);
    }

    @Deprecated
    public runAdminJob_args clone() {
      return new runAdminJob_args(this);
    }

    public AdminJobReq  getReq() {
      return this.req;
    }

    public runAdminJob_args setReq(AdminJobReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((AdminJobReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof runAdminJob_args)
        return this.equals((runAdminJob_args)that);
      return false;
    }

    public boolean equals(runAdminJob_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(runAdminJob_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new AdminJobReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("runAdminJob_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class runAdminJob_result implements TBase, java.io.Serializable, Cloneable, Comparable<runAdminJob_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("runAdminJob_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public AdminJobResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AdminJobResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(runAdminJob_result.class, metaDataMap);
    }

    public runAdminJob_result() {
    }

    public runAdminJob_result(
      AdminJobResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public runAdminJob_result(runAdminJob_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public runAdminJob_result deepCopy() {
      return new runAdminJob_result(this);
    }

    @Deprecated
    public runAdminJob_result clone() {
      return new runAdminJob_result(this);
    }

    public AdminJobResp  getSuccess() {
      return this.success;
    }

    public runAdminJob_result setSuccess(AdminJobResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((AdminJobResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof runAdminJob_result)
        return this.equals((runAdminJob_result)that);
      return false;
    }

    public boolean equals(runAdminJob_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(runAdminJob_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new AdminJobResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("runAdminJob_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

}
