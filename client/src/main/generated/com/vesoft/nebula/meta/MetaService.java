/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package com.vesoft.nebula.meta;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import java.util.BitSet;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.facebook.thrift.*;
import com.facebook.thrift.annotations.*;
import com.facebook.thrift.async.*;
import com.facebook.thrift.meta_data.*;
import com.facebook.thrift.server.*;
import com.facebook.thrift.transport.*;
import com.facebook.thrift.protocol.*;

@SuppressWarnings({ "unused", "serial" })
public class MetaService {

  public interface Iface {

    public ExecResp createSpace(CreateSpaceReq req) throws TException;

    public ExecResp dropSpace(DropSpaceReq req) throws TException;

    public ExecResp clearSpace(ClearSpaceReq req) throws TException;

    public GetSpaceResp getSpace(GetSpaceReq req) throws TException;

    public ListSpacesResp listSpaces(ListSpacesReq req) throws TException;

    public ExecResp alterSpace(AlterSpaceReq req) throws TException;

    public ExecResp createSpaceAs(CreateSpaceAsReq req) throws TException;

    public ExecResp createTag(CreateTagReq req) throws TException;

    public ExecResp alterTag(AlterTagReq req) throws TException;

    public ExecResp dropTag(DropTagReq req) throws TException;

    public GetTagResp getTag(GetTagReq req) throws TException;

    public ListTagsResp listTags(ListTagsReq req) throws TException;

    public ExecResp createEdge(CreateEdgeReq req) throws TException;

    public ExecResp alterEdge(AlterEdgeReq req) throws TException;

    public ExecResp dropEdge(DropEdgeReq req) throws TException;

    public GetEdgeResp getEdge(GetEdgeReq req) throws TException;

    public ListEdgesResp listEdges(ListEdgesReq req) throws TException;

    public ExecResp addHosts(AddHostsReq req) throws TException;

    public ExecResp addHostsIntoZone(AddHostsIntoZoneReq req) throws TException;

    public ExecResp dropHosts(DropHostsReq req) throws TException;

    public ListHostsResp listHosts(ListHostsReq req) throws TException;

    public GetPartsAllocResp getPartsAlloc(GetPartsAllocReq req) throws TException;

    public ListPartsResp listParts(ListPartsReq req) throws TException;

    public GetWorkerIdResp getWorkerId(GetWorkerIdReq req) throws TException;

    public ExecResp createTagIndex(CreateTagIndexReq req) throws TException;

    public ExecResp dropTagIndex(DropTagIndexReq req) throws TException;

    public GetTagIndexResp getTagIndex(GetTagIndexReq req) throws TException;

    public ListTagIndexesResp listTagIndexes(ListTagIndexesReq req) throws TException;

    public ExecResp rebuildTagIndex(RebuildIndexReq req) throws TException;

    public ListIndexStatusResp listTagIndexStatus(ListIndexStatusReq req) throws TException;

    public ExecResp createEdgeIndex(CreateEdgeIndexReq req) throws TException;

    public ExecResp dropEdgeIndex(DropEdgeIndexReq req) throws TException;

    public GetEdgeIndexResp getEdgeIndex(GetEdgeIndexReq req) throws TException;

    public ListEdgeIndexesResp listEdgeIndexes(ListEdgeIndexesReq req) throws TException;

    public ExecResp rebuildEdgeIndex(RebuildIndexReq req) throws TException;

    public ListIndexStatusResp listEdgeIndexStatus(ListIndexStatusReq req) throws TException;

    public ExecResp createUser(CreateUserReq req) throws TException;

    public ExecResp dropUser(DropUserReq req) throws TException;

    public ExecResp alterUser(AlterUserReq req) throws TException;

    public ExecResp grantRole(GrantRoleReq req) throws TException;

    public ExecResp revokeRole(RevokeRoleReq req) throws TException;

    public ListUsersResp listUsers(ListUsersReq req) throws TException;

    public ListRolesResp listRoles(ListRolesReq req) throws TException;

    public ListRolesResp getUserRoles(GetUserRolesReq req) throws TException;

    public ExecResp changePassword(ChangePasswordReq req) throws TException;

    public HBResp heartBeat(HBReq req) throws TException;

    public AgentHBResp agentHeartbeat(AgentHBReq req) throws TException;

    public ExecResp regConfig(RegConfigReq req) throws TException;

    public GetConfigResp getConfig(GetConfigReq req) throws TException;

    public ExecResp setConfig(SetConfigReq req) throws TException;

    public ListConfigsResp listConfigs(ListConfigsReq req) throws TException;

    public ExecResp createSnapshot(CreateSnapshotReq req) throws TException;

    public ExecResp dropSnapshot(DropSnapshotReq req) throws TException;

    public ListSnapshotsResp listSnapshots(ListSnapshotsReq req) throws TException;

    public AdminJobResp runAdminJob(AdminJobReq req) throws TException;

    public ExecResp mergeZone(MergeZoneReq req) throws TException;

    public ExecResp dropZone(DropZoneReq req) throws TException;

    public ExecResp divideZone(DivideZoneReq req) throws TException;

    public ExecResp renameZone(RenameZoneReq req) throws TException;

    public GetZoneResp getZone(GetZoneReq req) throws TException;

    public ListZonesResp listZones(ListZonesReq req) throws TException;

    public ExecResp addListener(AddListenerReq req) throws TException;

    public ExecResp removeListener(RemoveListenerReq req) throws TException;

    public ListListenerResp listListener(ListListenerReq req) throws TException;

    public GetStatsResp getStats(GetStatsReq req) throws TException;

    public ExecResp signInService(SignInServiceReq req) throws TException;

    public ExecResp signOutService(SignOutServiceReq req) throws TException;

    public ListServiceClientsResp listServiceClients(ListServiceClientsReq req) throws TException;

    public ExecResp createFTIndex(CreateFTIndexReq req) throws TException;

    public ExecResp dropFTIndex(DropFTIndexReq req) throws TException;

    public ListFTIndexesResp listFTIndexes(ListFTIndexesReq req) throws TException;

    public CreateSessionResp createSession(CreateSessionReq req) throws TException;

    public UpdateSessionsResp updateSessions(UpdateSessionsReq req) throws TException;

    public ListSessionsResp listSessions(ListSessionsReq req) throws TException;

    public GetSessionResp getSession(GetSessionReq req) throws TException;

    public RemoveSessionResp removeSession(RemoveSessionReq req) throws TException;

    public ExecResp killQuery(KillQueryReq req) throws TException;

    public ExecResp reportTaskFinish(ReportTaskReq req) throws TException;

    public CreateBackupResp createBackup(CreateBackupReq req) throws TException;

    public RestoreMetaResp restoreMeta(RestoreMetaReq req) throws TException;

    public ListClusterInfoResp listCluster(ListClusterInfoReq req) throws TException;

    public GetMetaDirInfoResp getMetaDirInfo(GetMetaDirInfoReq req) throws TException;

    public VerifyClientVersionResp verifyClientVersion(VerifyClientVersionReq req) throws TException;

    public SaveGraphVersionResp saveGraphVersion(SaveGraphVersionReq req) throws TException;

    public GetSegmentIdResp getSegmentId(GetSegmentIdReq req) throws TException;

  }

  public interface AsyncIface {

    public void createSpace(CreateSpaceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropSpace(DropSpaceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void clearSpace(ClearSpaceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getSpace(GetSpaceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listSpaces(ListSpacesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void alterSpace(AlterSpaceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createSpaceAs(CreateSpaceAsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createTag(CreateTagReq req, AsyncMethodCallback resultHandler) throws TException;

    public void alterTag(AlterTagReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropTag(DropTagReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getTag(GetTagReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listTags(ListTagsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createEdge(CreateEdgeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void alterEdge(AlterEdgeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropEdge(DropEdgeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getEdge(GetEdgeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listEdges(ListEdgesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void addHosts(AddHostsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void addHostsIntoZone(AddHostsIntoZoneReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropHosts(DropHostsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listHosts(ListHostsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getPartsAlloc(GetPartsAllocReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listParts(ListPartsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getWorkerId(GetWorkerIdReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createTagIndex(CreateTagIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropTagIndex(DropTagIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getTagIndex(GetTagIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listTagIndexes(ListTagIndexesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void rebuildTagIndex(RebuildIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listTagIndexStatus(ListIndexStatusReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createEdgeIndex(CreateEdgeIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropEdgeIndex(DropEdgeIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getEdgeIndex(GetEdgeIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listEdgeIndexes(ListEdgeIndexesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void rebuildEdgeIndex(RebuildIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listEdgeIndexStatus(ListIndexStatusReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createUser(CreateUserReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropUser(DropUserReq req, AsyncMethodCallback resultHandler) throws TException;

    public void alterUser(AlterUserReq req, AsyncMethodCallback resultHandler) throws TException;

    public void grantRole(GrantRoleReq req, AsyncMethodCallback resultHandler) throws TException;

    public void revokeRole(RevokeRoleReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listUsers(ListUsersReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listRoles(ListRolesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getUserRoles(GetUserRolesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void changePassword(ChangePasswordReq req, AsyncMethodCallback resultHandler) throws TException;

    public void heartBeat(HBReq req, AsyncMethodCallback resultHandler) throws TException;

    public void agentHeartbeat(AgentHBReq req, AsyncMethodCallback resultHandler) throws TException;

    public void regConfig(RegConfigReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getConfig(GetConfigReq req, AsyncMethodCallback resultHandler) throws TException;

    public void setConfig(SetConfigReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listConfigs(ListConfigsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createSnapshot(CreateSnapshotReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropSnapshot(DropSnapshotReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listSnapshots(ListSnapshotsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void runAdminJob(AdminJobReq req, AsyncMethodCallback resultHandler) throws TException;

    public void mergeZone(MergeZoneReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropZone(DropZoneReq req, AsyncMethodCallback resultHandler) throws TException;

    public void divideZone(DivideZoneReq req, AsyncMethodCallback resultHandler) throws TException;

    public void renameZone(RenameZoneReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getZone(GetZoneReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listZones(ListZonesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void addListener(AddListenerReq req, AsyncMethodCallback resultHandler) throws TException;

    public void removeListener(RemoveListenerReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listListener(ListListenerReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getStats(GetStatsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void signInService(SignInServiceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void signOutService(SignOutServiceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listServiceClients(ListServiceClientsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createFTIndex(CreateFTIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropFTIndex(DropFTIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listFTIndexes(ListFTIndexesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createSession(CreateSessionReq req, AsyncMethodCallback resultHandler) throws TException;

    public void updateSessions(UpdateSessionsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listSessions(ListSessionsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getSession(GetSessionReq req, AsyncMethodCallback resultHandler) throws TException;

    public void removeSession(RemoveSessionReq req, AsyncMethodCallback resultHandler) throws TException;

    public void killQuery(KillQueryReq req, AsyncMethodCallback resultHandler) throws TException;

    public void reportTaskFinish(ReportTaskReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createBackup(CreateBackupReq req, AsyncMethodCallback resultHandler) throws TException;

    public void restoreMeta(RestoreMetaReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listCluster(ListClusterInfoReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getMetaDirInfo(GetMetaDirInfoReq req, AsyncMethodCallback resultHandler) throws TException;

    public void verifyClientVersion(VerifyClientVersionReq req, AsyncMethodCallback resultHandler) throws TException;

    public void saveGraphVersion(SaveGraphVersionReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getSegmentId(GetSegmentIdReq req, AsyncMethodCallback resultHandler) throws TException;

  }

  public static class Client extends EventHandlerBase implements Iface, TClientIf {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    @Override
    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    @Override
    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public ExecResp createSpace(CreateSpaceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createSpace", null);
      this.setContextStack(ctx);
      send_createSpace(req);
      return recv_createSpace();
    }

    public void send_createSpace(CreateSpaceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createSpace", null);
      oprot_.writeMessageBegin(new TMessage("createSpace", TMessageType.CALL, seqid_));
      createSpace_args args = new createSpace_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createSpace", args);
      return;
    }

    public ExecResp recv_createSpace() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createSpace");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createSpace_result result = new createSpace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createSpace", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createSpace failed: unknown result");
    }

    public ExecResp dropSpace(DropSpaceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropSpace", null);
      this.setContextStack(ctx);
      send_dropSpace(req);
      return recv_dropSpace();
    }

    public void send_dropSpace(DropSpaceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropSpace", null);
      oprot_.writeMessageBegin(new TMessage("dropSpace", TMessageType.CALL, seqid_));
      dropSpace_args args = new dropSpace_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropSpace", args);
      return;
    }

    public ExecResp recv_dropSpace() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropSpace");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropSpace_result result = new dropSpace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropSpace", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropSpace failed: unknown result");
    }

    public ExecResp clearSpace(ClearSpaceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.clearSpace", null);
      this.setContextStack(ctx);
      send_clearSpace(req);
      return recv_clearSpace();
    }

    public void send_clearSpace(ClearSpaceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.clearSpace", null);
      oprot_.writeMessageBegin(new TMessage("clearSpace", TMessageType.CALL, seqid_));
      clearSpace_args args = new clearSpace_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.clearSpace", args);
      return;
    }

    public ExecResp recv_clearSpace() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.clearSpace");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      clearSpace_result result = new clearSpace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.clearSpace", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "clearSpace failed: unknown result");
    }

    public GetSpaceResp getSpace(GetSpaceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getSpace", null);
      this.setContextStack(ctx);
      send_getSpace(req);
      return recv_getSpace();
    }

    public void send_getSpace(GetSpaceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getSpace", null);
      oprot_.writeMessageBegin(new TMessage("getSpace", TMessageType.CALL, seqid_));
      getSpace_args args = new getSpace_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getSpace", args);
      return;
    }

    public GetSpaceResp recv_getSpace() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getSpace");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getSpace_result result = new getSpace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getSpace", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getSpace failed: unknown result");
    }

    public ListSpacesResp listSpaces(ListSpacesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listSpaces", null);
      this.setContextStack(ctx);
      send_listSpaces(req);
      return recv_listSpaces();
    }

    public void send_listSpaces(ListSpacesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listSpaces", null);
      oprot_.writeMessageBegin(new TMessage("listSpaces", TMessageType.CALL, seqid_));
      listSpaces_args args = new listSpaces_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listSpaces", args);
      return;
    }

    public ListSpacesResp recv_listSpaces() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listSpaces");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listSpaces_result result = new listSpaces_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listSpaces", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listSpaces failed: unknown result");
    }

    public ExecResp alterSpace(AlterSpaceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.alterSpace", null);
      this.setContextStack(ctx);
      send_alterSpace(req);
      return recv_alterSpace();
    }

    public void send_alterSpace(AlterSpaceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.alterSpace", null);
      oprot_.writeMessageBegin(new TMessage("alterSpace", TMessageType.CALL, seqid_));
      alterSpace_args args = new alterSpace_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.alterSpace", args);
      return;
    }

    public ExecResp recv_alterSpace() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.alterSpace");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      alterSpace_result result = new alterSpace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.alterSpace", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "alterSpace failed: unknown result");
    }

    public ExecResp createSpaceAs(CreateSpaceAsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createSpaceAs", null);
      this.setContextStack(ctx);
      send_createSpaceAs(req);
      return recv_createSpaceAs();
    }

    public void send_createSpaceAs(CreateSpaceAsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createSpaceAs", null);
      oprot_.writeMessageBegin(new TMessage("createSpaceAs", TMessageType.CALL, seqid_));
      createSpaceAs_args args = new createSpaceAs_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createSpaceAs", args);
      return;
    }

    public ExecResp recv_createSpaceAs() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createSpaceAs");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createSpaceAs_result result = new createSpaceAs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createSpaceAs", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createSpaceAs failed: unknown result");
    }

    public ExecResp createTag(CreateTagReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createTag", null);
      this.setContextStack(ctx);
      send_createTag(req);
      return recv_createTag();
    }

    public void send_createTag(CreateTagReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createTag", null);
      oprot_.writeMessageBegin(new TMessage("createTag", TMessageType.CALL, seqid_));
      createTag_args args = new createTag_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createTag", args);
      return;
    }

    public ExecResp recv_createTag() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createTag");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createTag_result result = new createTag_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createTag", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createTag failed: unknown result");
    }

    public ExecResp alterTag(AlterTagReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.alterTag", null);
      this.setContextStack(ctx);
      send_alterTag(req);
      return recv_alterTag();
    }

    public void send_alterTag(AlterTagReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.alterTag", null);
      oprot_.writeMessageBegin(new TMessage("alterTag", TMessageType.CALL, seqid_));
      alterTag_args args = new alterTag_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.alterTag", args);
      return;
    }

    public ExecResp recv_alterTag() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.alterTag");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      alterTag_result result = new alterTag_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.alterTag", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "alterTag failed: unknown result");
    }

    public ExecResp dropTag(DropTagReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropTag", null);
      this.setContextStack(ctx);
      send_dropTag(req);
      return recv_dropTag();
    }

    public void send_dropTag(DropTagReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropTag", null);
      oprot_.writeMessageBegin(new TMessage("dropTag", TMessageType.CALL, seqid_));
      dropTag_args args = new dropTag_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropTag", args);
      return;
    }

    public ExecResp recv_dropTag() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropTag");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropTag_result result = new dropTag_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropTag", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropTag failed: unknown result");
    }

    public GetTagResp getTag(GetTagReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getTag", null);
      this.setContextStack(ctx);
      send_getTag(req);
      return recv_getTag();
    }

    public void send_getTag(GetTagReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getTag", null);
      oprot_.writeMessageBegin(new TMessage("getTag", TMessageType.CALL, seqid_));
      getTag_args args = new getTag_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getTag", args);
      return;
    }

    public GetTagResp recv_getTag() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getTag");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getTag_result result = new getTag_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getTag", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTag failed: unknown result");
    }

    public ListTagsResp listTags(ListTagsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listTags", null);
      this.setContextStack(ctx);
      send_listTags(req);
      return recv_listTags();
    }

    public void send_listTags(ListTagsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listTags", null);
      oprot_.writeMessageBegin(new TMessage("listTags", TMessageType.CALL, seqid_));
      listTags_args args = new listTags_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listTags", args);
      return;
    }

    public ListTagsResp recv_listTags() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listTags");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listTags_result result = new listTags_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listTags", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listTags failed: unknown result");
    }

    public ExecResp createEdge(CreateEdgeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createEdge", null);
      this.setContextStack(ctx);
      send_createEdge(req);
      return recv_createEdge();
    }

    public void send_createEdge(CreateEdgeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createEdge", null);
      oprot_.writeMessageBegin(new TMessage("createEdge", TMessageType.CALL, seqid_));
      createEdge_args args = new createEdge_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createEdge", args);
      return;
    }

    public ExecResp recv_createEdge() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createEdge");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createEdge_result result = new createEdge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createEdge", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createEdge failed: unknown result");
    }

    public ExecResp alterEdge(AlterEdgeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.alterEdge", null);
      this.setContextStack(ctx);
      send_alterEdge(req);
      return recv_alterEdge();
    }

    public void send_alterEdge(AlterEdgeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.alterEdge", null);
      oprot_.writeMessageBegin(new TMessage("alterEdge", TMessageType.CALL, seqid_));
      alterEdge_args args = new alterEdge_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.alterEdge", args);
      return;
    }

    public ExecResp recv_alterEdge() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.alterEdge");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      alterEdge_result result = new alterEdge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.alterEdge", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "alterEdge failed: unknown result");
    }

    public ExecResp dropEdge(DropEdgeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropEdge", null);
      this.setContextStack(ctx);
      send_dropEdge(req);
      return recv_dropEdge();
    }

    public void send_dropEdge(DropEdgeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropEdge", null);
      oprot_.writeMessageBegin(new TMessage("dropEdge", TMessageType.CALL, seqid_));
      dropEdge_args args = new dropEdge_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropEdge", args);
      return;
    }

    public ExecResp recv_dropEdge() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropEdge");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropEdge_result result = new dropEdge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropEdge", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropEdge failed: unknown result");
    }

    public GetEdgeResp getEdge(GetEdgeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getEdge", null);
      this.setContextStack(ctx);
      send_getEdge(req);
      return recv_getEdge();
    }

    public void send_getEdge(GetEdgeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getEdge", null);
      oprot_.writeMessageBegin(new TMessage("getEdge", TMessageType.CALL, seqid_));
      getEdge_args args = new getEdge_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getEdge", args);
      return;
    }

    public GetEdgeResp recv_getEdge() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getEdge");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getEdge_result result = new getEdge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getEdge", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getEdge failed: unknown result");
    }

    public ListEdgesResp listEdges(ListEdgesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listEdges", null);
      this.setContextStack(ctx);
      send_listEdges(req);
      return recv_listEdges();
    }

    public void send_listEdges(ListEdgesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listEdges", null);
      oprot_.writeMessageBegin(new TMessage("listEdges", TMessageType.CALL, seqid_));
      listEdges_args args = new listEdges_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listEdges", args);
      return;
    }

    public ListEdgesResp recv_listEdges() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listEdges");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listEdges_result result = new listEdges_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listEdges", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listEdges failed: unknown result");
    }

    public ExecResp addHosts(AddHostsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.addHosts", null);
      this.setContextStack(ctx);
      send_addHosts(req);
      return recv_addHosts();
    }

    public void send_addHosts(AddHostsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.addHosts", null);
      oprot_.writeMessageBegin(new TMessage("addHosts", TMessageType.CALL, seqid_));
      addHosts_args args = new addHosts_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.addHosts", args);
      return;
    }

    public ExecResp recv_addHosts() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.addHosts");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      addHosts_result result = new addHosts_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.addHosts", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "addHosts failed: unknown result");
    }

    public ExecResp addHostsIntoZone(AddHostsIntoZoneReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.addHostsIntoZone", null);
      this.setContextStack(ctx);
      send_addHostsIntoZone(req);
      return recv_addHostsIntoZone();
    }

    public void send_addHostsIntoZone(AddHostsIntoZoneReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.addHostsIntoZone", null);
      oprot_.writeMessageBegin(new TMessage("addHostsIntoZone", TMessageType.CALL, seqid_));
      addHostsIntoZone_args args = new addHostsIntoZone_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.addHostsIntoZone", args);
      return;
    }

    public ExecResp recv_addHostsIntoZone() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.addHostsIntoZone");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      addHostsIntoZone_result result = new addHostsIntoZone_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.addHostsIntoZone", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "addHostsIntoZone failed: unknown result");
    }

    public ExecResp dropHosts(DropHostsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropHosts", null);
      this.setContextStack(ctx);
      send_dropHosts(req);
      return recv_dropHosts();
    }

    public void send_dropHosts(DropHostsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropHosts", null);
      oprot_.writeMessageBegin(new TMessage("dropHosts", TMessageType.CALL, seqid_));
      dropHosts_args args = new dropHosts_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropHosts", args);
      return;
    }

    public ExecResp recv_dropHosts() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropHosts");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropHosts_result result = new dropHosts_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropHosts", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropHosts failed: unknown result");
    }

    public ListHostsResp listHosts(ListHostsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listHosts", null);
      this.setContextStack(ctx);
      send_listHosts(req);
      return recv_listHosts();
    }

    public void send_listHosts(ListHostsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listHosts", null);
      oprot_.writeMessageBegin(new TMessage("listHosts", TMessageType.CALL, seqid_));
      listHosts_args args = new listHosts_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listHosts", args);
      return;
    }

    public ListHostsResp recv_listHosts() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listHosts");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listHosts_result result = new listHosts_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listHosts", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listHosts failed: unknown result");
    }

    public GetPartsAllocResp getPartsAlloc(GetPartsAllocReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getPartsAlloc", null);
      this.setContextStack(ctx);
      send_getPartsAlloc(req);
      return recv_getPartsAlloc();
    }

    public void send_getPartsAlloc(GetPartsAllocReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getPartsAlloc", null);
      oprot_.writeMessageBegin(new TMessage("getPartsAlloc", TMessageType.CALL, seqid_));
      getPartsAlloc_args args = new getPartsAlloc_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getPartsAlloc", args);
      return;
    }

    public GetPartsAllocResp recv_getPartsAlloc() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getPartsAlloc");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getPartsAlloc_result result = new getPartsAlloc_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getPartsAlloc", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getPartsAlloc failed: unknown result");
    }

    public ListPartsResp listParts(ListPartsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listParts", null);
      this.setContextStack(ctx);
      send_listParts(req);
      return recv_listParts();
    }

    public void send_listParts(ListPartsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listParts", null);
      oprot_.writeMessageBegin(new TMessage("listParts", TMessageType.CALL, seqid_));
      listParts_args args = new listParts_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listParts", args);
      return;
    }

    public ListPartsResp recv_listParts() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listParts");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listParts_result result = new listParts_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listParts", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listParts failed: unknown result");
    }

    public GetWorkerIdResp getWorkerId(GetWorkerIdReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getWorkerId", null);
      this.setContextStack(ctx);
      send_getWorkerId(req);
      return recv_getWorkerId();
    }

    public void send_getWorkerId(GetWorkerIdReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getWorkerId", null);
      oprot_.writeMessageBegin(new TMessage("getWorkerId", TMessageType.CALL, seqid_));
      getWorkerId_args args = new getWorkerId_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getWorkerId", args);
      return;
    }

    public GetWorkerIdResp recv_getWorkerId() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getWorkerId");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getWorkerId_result result = new getWorkerId_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getWorkerId", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getWorkerId failed: unknown result");
    }

    public ExecResp createTagIndex(CreateTagIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createTagIndex", null);
      this.setContextStack(ctx);
      send_createTagIndex(req);
      return recv_createTagIndex();
    }

    public void send_createTagIndex(CreateTagIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createTagIndex", null);
      oprot_.writeMessageBegin(new TMessage("createTagIndex", TMessageType.CALL, seqid_));
      createTagIndex_args args = new createTagIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createTagIndex", args);
      return;
    }

    public ExecResp recv_createTagIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createTagIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createTagIndex_result result = new createTagIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createTagIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createTagIndex failed: unknown result");
    }

    public ExecResp dropTagIndex(DropTagIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropTagIndex", null);
      this.setContextStack(ctx);
      send_dropTagIndex(req);
      return recv_dropTagIndex();
    }

    public void send_dropTagIndex(DropTagIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropTagIndex", null);
      oprot_.writeMessageBegin(new TMessage("dropTagIndex", TMessageType.CALL, seqid_));
      dropTagIndex_args args = new dropTagIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropTagIndex", args);
      return;
    }

    public ExecResp recv_dropTagIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropTagIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropTagIndex_result result = new dropTagIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropTagIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropTagIndex failed: unknown result");
    }

    public GetTagIndexResp getTagIndex(GetTagIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getTagIndex", null);
      this.setContextStack(ctx);
      send_getTagIndex(req);
      return recv_getTagIndex();
    }

    public void send_getTagIndex(GetTagIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getTagIndex", null);
      oprot_.writeMessageBegin(new TMessage("getTagIndex", TMessageType.CALL, seqid_));
      getTagIndex_args args = new getTagIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getTagIndex", args);
      return;
    }

    public GetTagIndexResp recv_getTagIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getTagIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getTagIndex_result result = new getTagIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getTagIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTagIndex failed: unknown result");
    }

    public ListTagIndexesResp listTagIndexes(ListTagIndexesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listTagIndexes", null);
      this.setContextStack(ctx);
      send_listTagIndexes(req);
      return recv_listTagIndexes();
    }

    public void send_listTagIndexes(ListTagIndexesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listTagIndexes", null);
      oprot_.writeMessageBegin(new TMessage("listTagIndexes", TMessageType.CALL, seqid_));
      listTagIndexes_args args = new listTagIndexes_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listTagIndexes", args);
      return;
    }

    public ListTagIndexesResp recv_listTagIndexes() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listTagIndexes");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listTagIndexes_result result = new listTagIndexes_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listTagIndexes", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listTagIndexes failed: unknown result");
    }

    public ExecResp rebuildTagIndex(RebuildIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.rebuildTagIndex", null);
      this.setContextStack(ctx);
      send_rebuildTagIndex(req);
      return recv_rebuildTagIndex();
    }

    public void send_rebuildTagIndex(RebuildIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.rebuildTagIndex", null);
      oprot_.writeMessageBegin(new TMessage("rebuildTagIndex", TMessageType.CALL, seqid_));
      rebuildTagIndex_args args = new rebuildTagIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.rebuildTagIndex", args);
      return;
    }

    public ExecResp recv_rebuildTagIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.rebuildTagIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      rebuildTagIndex_result result = new rebuildTagIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.rebuildTagIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "rebuildTagIndex failed: unknown result");
    }

    public ListIndexStatusResp listTagIndexStatus(ListIndexStatusReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listTagIndexStatus", null);
      this.setContextStack(ctx);
      send_listTagIndexStatus(req);
      return recv_listTagIndexStatus();
    }

    public void send_listTagIndexStatus(ListIndexStatusReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listTagIndexStatus", null);
      oprot_.writeMessageBegin(new TMessage("listTagIndexStatus", TMessageType.CALL, seqid_));
      listTagIndexStatus_args args = new listTagIndexStatus_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listTagIndexStatus", args);
      return;
    }

    public ListIndexStatusResp recv_listTagIndexStatus() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listTagIndexStatus");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listTagIndexStatus_result result = new listTagIndexStatus_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listTagIndexStatus", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listTagIndexStatus failed: unknown result");
    }

    public ExecResp createEdgeIndex(CreateEdgeIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createEdgeIndex", null);
      this.setContextStack(ctx);
      send_createEdgeIndex(req);
      return recv_createEdgeIndex();
    }

    public void send_createEdgeIndex(CreateEdgeIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createEdgeIndex", null);
      oprot_.writeMessageBegin(new TMessage("createEdgeIndex", TMessageType.CALL, seqid_));
      createEdgeIndex_args args = new createEdgeIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createEdgeIndex", args);
      return;
    }

    public ExecResp recv_createEdgeIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createEdgeIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createEdgeIndex_result result = new createEdgeIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createEdgeIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createEdgeIndex failed: unknown result");
    }

    public ExecResp dropEdgeIndex(DropEdgeIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropEdgeIndex", null);
      this.setContextStack(ctx);
      send_dropEdgeIndex(req);
      return recv_dropEdgeIndex();
    }

    public void send_dropEdgeIndex(DropEdgeIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropEdgeIndex", null);
      oprot_.writeMessageBegin(new TMessage("dropEdgeIndex", TMessageType.CALL, seqid_));
      dropEdgeIndex_args args = new dropEdgeIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropEdgeIndex", args);
      return;
    }

    public ExecResp recv_dropEdgeIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropEdgeIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropEdgeIndex_result result = new dropEdgeIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropEdgeIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropEdgeIndex failed: unknown result");
    }

    public GetEdgeIndexResp getEdgeIndex(GetEdgeIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getEdgeIndex", null);
      this.setContextStack(ctx);
      send_getEdgeIndex(req);
      return recv_getEdgeIndex();
    }

    public void send_getEdgeIndex(GetEdgeIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getEdgeIndex", null);
      oprot_.writeMessageBegin(new TMessage("getEdgeIndex", TMessageType.CALL, seqid_));
      getEdgeIndex_args args = new getEdgeIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getEdgeIndex", args);
      return;
    }

    public GetEdgeIndexResp recv_getEdgeIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getEdgeIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getEdgeIndex_result result = new getEdgeIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getEdgeIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getEdgeIndex failed: unknown result");
    }

    public ListEdgeIndexesResp listEdgeIndexes(ListEdgeIndexesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listEdgeIndexes", null);
      this.setContextStack(ctx);
      send_listEdgeIndexes(req);
      return recv_listEdgeIndexes();
    }

    public void send_listEdgeIndexes(ListEdgeIndexesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listEdgeIndexes", null);
      oprot_.writeMessageBegin(new TMessage("listEdgeIndexes", TMessageType.CALL, seqid_));
      listEdgeIndexes_args args = new listEdgeIndexes_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listEdgeIndexes", args);
      return;
    }

    public ListEdgeIndexesResp recv_listEdgeIndexes() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listEdgeIndexes");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listEdgeIndexes_result result = new listEdgeIndexes_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listEdgeIndexes", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listEdgeIndexes failed: unknown result");
    }

    public ExecResp rebuildEdgeIndex(RebuildIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.rebuildEdgeIndex", null);
      this.setContextStack(ctx);
      send_rebuildEdgeIndex(req);
      return recv_rebuildEdgeIndex();
    }

    public void send_rebuildEdgeIndex(RebuildIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.rebuildEdgeIndex", null);
      oprot_.writeMessageBegin(new TMessage("rebuildEdgeIndex", TMessageType.CALL, seqid_));
      rebuildEdgeIndex_args args = new rebuildEdgeIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.rebuildEdgeIndex", args);
      return;
    }

    public ExecResp recv_rebuildEdgeIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.rebuildEdgeIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      rebuildEdgeIndex_result result = new rebuildEdgeIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.rebuildEdgeIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "rebuildEdgeIndex failed: unknown result");
    }

    public ListIndexStatusResp listEdgeIndexStatus(ListIndexStatusReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listEdgeIndexStatus", null);
      this.setContextStack(ctx);
      send_listEdgeIndexStatus(req);
      return recv_listEdgeIndexStatus();
    }

    public void send_listEdgeIndexStatus(ListIndexStatusReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listEdgeIndexStatus", null);
      oprot_.writeMessageBegin(new TMessage("listEdgeIndexStatus", TMessageType.CALL, seqid_));
      listEdgeIndexStatus_args args = new listEdgeIndexStatus_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listEdgeIndexStatus", args);
      return;
    }

    public ListIndexStatusResp recv_listEdgeIndexStatus() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listEdgeIndexStatus");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listEdgeIndexStatus_result result = new listEdgeIndexStatus_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listEdgeIndexStatus", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listEdgeIndexStatus failed: unknown result");
    }

    public ExecResp createUser(CreateUserReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createUser", null);
      this.setContextStack(ctx);
      send_createUser(req);
      return recv_createUser();
    }

    public void send_createUser(CreateUserReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createUser", null);
      oprot_.writeMessageBegin(new TMessage("createUser", TMessageType.CALL, seqid_));
      createUser_args args = new createUser_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createUser", args);
      return;
    }

    public ExecResp recv_createUser() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createUser");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createUser_result result = new createUser_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createUser", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createUser failed: unknown result");
    }

    public ExecResp dropUser(DropUserReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropUser", null);
      this.setContextStack(ctx);
      send_dropUser(req);
      return recv_dropUser();
    }

    public void send_dropUser(DropUserReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropUser", null);
      oprot_.writeMessageBegin(new TMessage("dropUser", TMessageType.CALL, seqid_));
      dropUser_args args = new dropUser_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropUser", args);
      return;
    }

    public ExecResp recv_dropUser() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropUser");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropUser_result result = new dropUser_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropUser", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropUser failed: unknown result");
    }

    public ExecResp alterUser(AlterUserReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.alterUser", null);
      this.setContextStack(ctx);
      send_alterUser(req);
      return recv_alterUser();
    }

    public void send_alterUser(AlterUserReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.alterUser", null);
      oprot_.writeMessageBegin(new TMessage("alterUser", TMessageType.CALL, seqid_));
      alterUser_args args = new alterUser_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.alterUser", args);
      return;
    }

    public ExecResp recv_alterUser() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.alterUser");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      alterUser_result result = new alterUser_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.alterUser", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "alterUser failed: unknown result");
    }

    public ExecResp grantRole(GrantRoleReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.grantRole", null);
      this.setContextStack(ctx);
      send_grantRole(req);
      return recv_grantRole();
    }

    public void send_grantRole(GrantRoleReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.grantRole", null);
      oprot_.writeMessageBegin(new TMessage("grantRole", TMessageType.CALL, seqid_));
      grantRole_args args = new grantRole_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.grantRole", args);
      return;
    }

    public ExecResp recv_grantRole() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.grantRole");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      grantRole_result result = new grantRole_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.grantRole", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "grantRole failed: unknown result");
    }

    public ExecResp revokeRole(RevokeRoleReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.revokeRole", null);
      this.setContextStack(ctx);
      send_revokeRole(req);
      return recv_revokeRole();
    }

    public void send_revokeRole(RevokeRoleReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.revokeRole", null);
      oprot_.writeMessageBegin(new TMessage("revokeRole", TMessageType.CALL, seqid_));
      revokeRole_args args = new revokeRole_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.revokeRole", args);
      return;
    }

    public ExecResp recv_revokeRole() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.revokeRole");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      revokeRole_result result = new revokeRole_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.revokeRole", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "revokeRole failed: unknown result");
    }

    public ListUsersResp listUsers(ListUsersReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listUsers", null);
      this.setContextStack(ctx);
      send_listUsers(req);
      return recv_listUsers();
    }

    public void send_listUsers(ListUsersReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listUsers", null);
      oprot_.writeMessageBegin(new TMessage("listUsers", TMessageType.CALL, seqid_));
      listUsers_args args = new listUsers_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listUsers", args);
      return;
    }

    public ListUsersResp recv_listUsers() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listUsers");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listUsers_result result = new listUsers_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listUsers", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listUsers failed: unknown result");
    }

    public ListRolesResp listRoles(ListRolesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listRoles", null);
      this.setContextStack(ctx);
      send_listRoles(req);
      return recv_listRoles();
    }

    public void send_listRoles(ListRolesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listRoles", null);
      oprot_.writeMessageBegin(new TMessage("listRoles", TMessageType.CALL, seqid_));
      listRoles_args args = new listRoles_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listRoles", args);
      return;
    }

    public ListRolesResp recv_listRoles() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listRoles");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listRoles_result result = new listRoles_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listRoles", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listRoles failed: unknown result");
    }

    public ListRolesResp getUserRoles(GetUserRolesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getUserRoles", null);
      this.setContextStack(ctx);
      send_getUserRoles(req);
      return recv_getUserRoles();
    }

    public void send_getUserRoles(GetUserRolesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getUserRoles", null);
      oprot_.writeMessageBegin(new TMessage("getUserRoles", TMessageType.CALL, seqid_));
      getUserRoles_args args = new getUserRoles_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getUserRoles", args);
      return;
    }

    public ListRolesResp recv_getUserRoles() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getUserRoles");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getUserRoles_result result = new getUserRoles_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getUserRoles", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getUserRoles failed: unknown result");
    }

    public ExecResp changePassword(ChangePasswordReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.changePassword", null);
      this.setContextStack(ctx);
      send_changePassword(req);
      return recv_changePassword();
    }

    public void send_changePassword(ChangePasswordReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.changePassword", null);
      oprot_.writeMessageBegin(new TMessage("changePassword", TMessageType.CALL, seqid_));
      changePassword_args args = new changePassword_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.changePassword", args);
      return;
    }

    public ExecResp recv_changePassword() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.changePassword");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      changePassword_result result = new changePassword_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.changePassword", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "changePassword failed: unknown result");
    }

    public HBResp heartBeat(HBReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.heartBeat", null);
      this.setContextStack(ctx);
      send_heartBeat(req);
      return recv_heartBeat();
    }

    public void send_heartBeat(HBReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.heartBeat", null);
      oprot_.writeMessageBegin(new TMessage("heartBeat", TMessageType.CALL, seqid_));
      heartBeat_args args = new heartBeat_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.heartBeat", args);
      return;
    }

    public HBResp recv_heartBeat() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.heartBeat");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      heartBeat_result result = new heartBeat_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.heartBeat", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "heartBeat failed: unknown result");
    }

    public AgentHBResp agentHeartbeat(AgentHBReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.agentHeartbeat", null);
      this.setContextStack(ctx);
      send_agentHeartbeat(req);
      return recv_agentHeartbeat();
    }

    public void send_agentHeartbeat(AgentHBReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.agentHeartbeat", null);
      oprot_.writeMessageBegin(new TMessage("agentHeartbeat", TMessageType.CALL, seqid_));
      agentHeartbeat_args args = new agentHeartbeat_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.agentHeartbeat", args);
      return;
    }

    public AgentHBResp recv_agentHeartbeat() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.agentHeartbeat");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      agentHeartbeat_result result = new agentHeartbeat_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.agentHeartbeat", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "agentHeartbeat failed: unknown result");
    }

    public ExecResp regConfig(RegConfigReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.regConfig", null);
      this.setContextStack(ctx);
      send_regConfig(req);
      return recv_regConfig();
    }

    public void send_regConfig(RegConfigReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.regConfig", null);
      oprot_.writeMessageBegin(new TMessage("regConfig", TMessageType.CALL, seqid_));
      regConfig_args args = new regConfig_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.regConfig", args);
      return;
    }

    public ExecResp recv_regConfig() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.regConfig");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      regConfig_result result = new regConfig_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.regConfig", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "regConfig failed: unknown result");
    }

    public GetConfigResp getConfig(GetConfigReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getConfig", null);
      this.setContextStack(ctx);
      send_getConfig(req);
      return recv_getConfig();
    }

    public void send_getConfig(GetConfigReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getConfig", null);
      oprot_.writeMessageBegin(new TMessage("getConfig", TMessageType.CALL, seqid_));
      getConfig_args args = new getConfig_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getConfig", args);
      return;
    }

    public GetConfigResp recv_getConfig() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getConfig");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getConfig_result result = new getConfig_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getConfig", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getConfig failed: unknown result");
    }

    public ExecResp setConfig(SetConfigReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.setConfig", null);
      this.setContextStack(ctx);
      send_setConfig(req);
      return recv_setConfig();
    }

    public void send_setConfig(SetConfigReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.setConfig", null);
      oprot_.writeMessageBegin(new TMessage("setConfig", TMessageType.CALL, seqid_));
      setConfig_args args = new setConfig_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.setConfig", args);
      return;
    }

    public ExecResp recv_setConfig() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.setConfig");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      setConfig_result result = new setConfig_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.setConfig", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "setConfig failed: unknown result");
    }

    public ListConfigsResp listConfigs(ListConfigsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listConfigs", null);
      this.setContextStack(ctx);
      send_listConfigs(req);
      return recv_listConfigs();
    }

    public void send_listConfigs(ListConfigsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listConfigs", null);
      oprot_.writeMessageBegin(new TMessage("listConfigs", TMessageType.CALL, seqid_));
      listConfigs_args args = new listConfigs_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listConfigs", args);
      return;
    }

    public ListConfigsResp recv_listConfigs() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listConfigs");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listConfigs_result result = new listConfigs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listConfigs", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listConfigs failed: unknown result");
    }

    public ExecResp createSnapshot(CreateSnapshotReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createSnapshot", null);
      this.setContextStack(ctx);
      send_createSnapshot(req);
      return recv_createSnapshot();
    }

    public void send_createSnapshot(CreateSnapshotReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createSnapshot", null);
      oprot_.writeMessageBegin(new TMessage("createSnapshot", TMessageType.CALL, seqid_));
      createSnapshot_args args = new createSnapshot_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createSnapshot", args);
      return;
    }

    public ExecResp recv_createSnapshot() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createSnapshot");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createSnapshot_result result = new createSnapshot_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createSnapshot", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createSnapshot failed: unknown result");
    }

    public ExecResp dropSnapshot(DropSnapshotReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropSnapshot", null);
      this.setContextStack(ctx);
      send_dropSnapshot(req);
      return recv_dropSnapshot();
    }

    public void send_dropSnapshot(DropSnapshotReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropSnapshot", null);
      oprot_.writeMessageBegin(new TMessage("dropSnapshot", TMessageType.CALL, seqid_));
      dropSnapshot_args args = new dropSnapshot_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropSnapshot", args);
      return;
    }

    public ExecResp recv_dropSnapshot() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropSnapshot");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropSnapshot_result result = new dropSnapshot_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropSnapshot", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropSnapshot failed: unknown result");
    }

    public ListSnapshotsResp listSnapshots(ListSnapshotsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listSnapshots", null);
      this.setContextStack(ctx);
      send_listSnapshots(req);
      return recv_listSnapshots();
    }

    public void send_listSnapshots(ListSnapshotsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listSnapshots", null);
      oprot_.writeMessageBegin(new TMessage("listSnapshots", TMessageType.CALL, seqid_));
      listSnapshots_args args = new listSnapshots_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listSnapshots", args);
      return;
    }

    public ListSnapshotsResp recv_listSnapshots() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listSnapshots");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listSnapshots_result result = new listSnapshots_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listSnapshots", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listSnapshots failed: unknown result");
    }

    public AdminJobResp runAdminJob(AdminJobReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.runAdminJob", null);
      this.setContextStack(ctx);
      send_runAdminJob(req);
      return recv_runAdminJob();
    }

    public void send_runAdminJob(AdminJobReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.runAdminJob", null);
      oprot_.writeMessageBegin(new TMessage("runAdminJob", TMessageType.CALL, seqid_));
      runAdminJob_args args = new runAdminJob_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.runAdminJob", args);
      return;
    }

    public AdminJobResp recv_runAdminJob() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.runAdminJob");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      runAdminJob_result result = new runAdminJob_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.runAdminJob", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "runAdminJob failed: unknown result");
    }

    public ExecResp mergeZone(MergeZoneReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.mergeZone", null);
      this.setContextStack(ctx);
      send_mergeZone(req);
      return recv_mergeZone();
    }

    public void send_mergeZone(MergeZoneReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.mergeZone", null);
      oprot_.writeMessageBegin(new TMessage("mergeZone", TMessageType.CALL, seqid_));
      mergeZone_args args = new mergeZone_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.mergeZone", args);
      return;
    }

    public ExecResp recv_mergeZone() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.mergeZone");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      mergeZone_result result = new mergeZone_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.mergeZone", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "mergeZone failed: unknown result");
    }

    public ExecResp dropZone(DropZoneReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropZone", null);
      this.setContextStack(ctx);
      send_dropZone(req);
      return recv_dropZone();
    }

    public void send_dropZone(DropZoneReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropZone", null);
      oprot_.writeMessageBegin(new TMessage("dropZone", TMessageType.CALL, seqid_));
      dropZone_args args = new dropZone_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropZone", args);
      return;
    }

    public ExecResp recv_dropZone() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropZone");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropZone_result result = new dropZone_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropZone", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropZone failed: unknown result");
    }

    public ExecResp divideZone(DivideZoneReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.divideZone", null);
      this.setContextStack(ctx);
      send_divideZone(req);
      return recv_divideZone();
    }

    public void send_divideZone(DivideZoneReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.divideZone", null);
      oprot_.writeMessageBegin(new TMessage("divideZone", TMessageType.CALL, seqid_));
      divideZone_args args = new divideZone_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.divideZone", args);
      return;
    }

    public ExecResp recv_divideZone() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.divideZone");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      divideZone_result result = new divideZone_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.divideZone", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "divideZone failed: unknown result");
    }

    public ExecResp renameZone(RenameZoneReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.renameZone", null);
      this.setContextStack(ctx);
      send_renameZone(req);
      return recv_renameZone();
    }

    public void send_renameZone(RenameZoneReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.renameZone", null);
      oprot_.writeMessageBegin(new TMessage("renameZone", TMessageType.CALL, seqid_));
      renameZone_args args = new renameZone_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.renameZone", args);
      return;
    }

    public ExecResp recv_renameZone() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.renameZone");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      renameZone_result result = new renameZone_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.renameZone", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "renameZone failed: unknown result");
    }

    public GetZoneResp getZone(GetZoneReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getZone", null);
      this.setContextStack(ctx);
      send_getZone(req);
      return recv_getZone();
    }

    public void send_getZone(GetZoneReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getZone", null);
      oprot_.writeMessageBegin(new TMessage("getZone", TMessageType.CALL, seqid_));
      getZone_args args = new getZone_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getZone", args);
      return;
    }

    public GetZoneResp recv_getZone() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getZone");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getZone_result result = new getZone_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getZone", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getZone failed: unknown result");
    }

    public ListZonesResp listZones(ListZonesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listZones", null);
      this.setContextStack(ctx);
      send_listZones(req);
      return recv_listZones();
    }

    public void send_listZones(ListZonesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listZones", null);
      oprot_.writeMessageBegin(new TMessage("listZones", TMessageType.CALL, seqid_));
      listZones_args args = new listZones_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listZones", args);
      return;
    }

    public ListZonesResp recv_listZones() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listZones");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listZones_result result = new listZones_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listZones", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listZones failed: unknown result");
    }

    public ExecResp addListener(AddListenerReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.addListener", null);
      this.setContextStack(ctx);
      send_addListener(req);
      return recv_addListener();
    }

    public void send_addListener(AddListenerReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.addListener", null);
      oprot_.writeMessageBegin(new TMessage("addListener", TMessageType.CALL, seqid_));
      addListener_args args = new addListener_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.addListener", args);
      return;
    }

    public ExecResp recv_addListener() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.addListener");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      addListener_result result = new addListener_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.addListener", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "addListener failed: unknown result");
    }

    public ExecResp removeListener(RemoveListenerReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.removeListener", null);
      this.setContextStack(ctx);
      send_removeListener(req);
      return recv_removeListener();
    }

    public void send_removeListener(RemoveListenerReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.removeListener", null);
      oprot_.writeMessageBegin(new TMessage("removeListener", TMessageType.CALL, seqid_));
      removeListener_args args = new removeListener_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.removeListener", args);
      return;
    }

    public ExecResp recv_removeListener() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.removeListener");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      removeListener_result result = new removeListener_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.removeListener", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "removeListener failed: unknown result");
    }

    public ListListenerResp listListener(ListListenerReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listListener", null);
      this.setContextStack(ctx);
      send_listListener(req);
      return recv_listListener();
    }

    public void send_listListener(ListListenerReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listListener", null);
      oprot_.writeMessageBegin(new TMessage("listListener", TMessageType.CALL, seqid_));
      listListener_args args = new listListener_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listListener", args);
      return;
    }

    public ListListenerResp recv_listListener() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listListener");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listListener_result result = new listListener_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listListener", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listListener failed: unknown result");
    }

    public GetStatsResp getStats(GetStatsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getStats", null);
      this.setContextStack(ctx);
      send_getStats(req);
      return recv_getStats();
    }

    public void send_getStats(GetStatsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getStats", null);
      oprot_.writeMessageBegin(new TMessage("getStats", TMessageType.CALL, seqid_));
      getStats_args args = new getStats_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getStats", args);
      return;
    }

    public GetStatsResp recv_getStats() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getStats");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getStats_result result = new getStats_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getStats", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getStats failed: unknown result");
    }

    public ExecResp signInService(SignInServiceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.signInService", null);
      this.setContextStack(ctx);
      send_signInService(req);
      return recv_signInService();
    }

    public void send_signInService(SignInServiceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.signInService", null);
      oprot_.writeMessageBegin(new TMessage("signInService", TMessageType.CALL, seqid_));
      signInService_args args = new signInService_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.signInService", args);
      return;
    }

    public ExecResp recv_signInService() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.signInService");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      signInService_result result = new signInService_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.signInService", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "signInService failed: unknown result");
    }

    public ExecResp signOutService(SignOutServiceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.signOutService", null);
      this.setContextStack(ctx);
      send_signOutService(req);
      return recv_signOutService();
    }

    public void send_signOutService(SignOutServiceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.signOutService", null);
      oprot_.writeMessageBegin(new TMessage("signOutService", TMessageType.CALL, seqid_));
      signOutService_args args = new signOutService_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.signOutService", args);
      return;
    }

    public ExecResp recv_signOutService() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.signOutService");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      signOutService_result result = new signOutService_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.signOutService", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "signOutService failed: unknown result");
    }

    public ListServiceClientsResp listServiceClients(ListServiceClientsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listServiceClients", null);
      this.setContextStack(ctx);
      send_listServiceClients(req);
      return recv_listServiceClients();
    }

    public void send_listServiceClients(ListServiceClientsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listServiceClients", null);
      oprot_.writeMessageBegin(new TMessage("listServiceClients", TMessageType.CALL, seqid_));
      listServiceClients_args args = new listServiceClients_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listServiceClients", args);
      return;
    }

    public ListServiceClientsResp recv_listServiceClients() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listServiceClients");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listServiceClients_result result = new listServiceClients_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listServiceClients", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listServiceClients failed: unknown result");
    }

    public ExecResp createFTIndex(CreateFTIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createFTIndex", null);
      this.setContextStack(ctx);
      send_createFTIndex(req);
      return recv_createFTIndex();
    }

    public void send_createFTIndex(CreateFTIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createFTIndex", null);
      oprot_.writeMessageBegin(new TMessage("createFTIndex", TMessageType.CALL, seqid_));
      createFTIndex_args args = new createFTIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createFTIndex", args);
      return;
    }

    public ExecResp recv_createFTIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createFTIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createFTIndex_result result = new createFTIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createFTIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createFTIndex failed: unknown result");
    }

    public ExecResp dropFTIndex(DropFTIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropFTIndex", null);
      this.setContextStack(ctx);
      send_dropFTIndex(req);
      return recv_dropFTIndex();
    }

    public void send_dropFTIndex(DropFTIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropFTIndex", null);
      oprot_.writeMessageBegin(new TMessage("dropFTIndex", TMessageType.CALL, seqid_));
      dropFTIndex_args args = new dropFTIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropFTIndex", args);
      return;
    }

    public ExecResp recv_dropFTIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropFTIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropFTIndex_result result = new dropFTIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropFTIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropFTIndex failed: unknown result");
    }

    public ListFTIndexesResp listFTIndexes(ListFTIndexesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listFTIndexes", null);
      this.setContextStack(ctx);
      send_listFTIndexes(req);
      return recv_listFTIndexes();
    }

    public void send_listFTIndexes(ListFTIndexesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listFTIndexes", null);
      oprot_.writeMessageBegin(new TMessage("listFTIndexes", TMessageType.CALL, seqid_));
      listFTIndexes_args args = new listFTIndexes_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listFTIndexes", args);
      return;
    }

    public ListFTIndexesResp recv_listFTIndexes() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listFTIndexes");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listFTIndexes_result result = new listFTIndexes_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listFTIndexes", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listFTIndexes failed: unknown result");
    }

    public CreateSessionResp createSession(CreateSessionReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createSession", null);
      this.setContextStack(ctx);
      send_createSession(req);
      return recv_createSession();
    }

    public void send_createSession(CreateSessionReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createSession", null);
      oprot_.writeMessageBegin(new TMessage("createSession", TMessageType.CALL, seqid_));
      createSession_args args = new createSession_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createSession", args);
      return;
    }

    public CreateSessionResp recv_createSession() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createSession");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createSession_result result = new createSession_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createSession", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createSession failed: unknown result");
    }

    public UpdateSessionsResp updateSessions(UpdateSessionsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.updateSessions", null);
      this.setContextStack(ctx);
      send_updateSessions(req);
      return recv_updateSessions();
    }

    public void send_updateSessions(UpdateSessionsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.updateSessions", null);
      oprot_.writeMessageBegin(new TMessage("updateSessions", TMessageType.CALL, seqid_));
      updateSessions_args args = new updateSessions_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.updateSessions", args);
      return;
    }

    public UpdateSessionsResp recv_updateSessions() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.updateSessions");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      updateSessions_result result = new updateSessions_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.updateSessions", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "updateSessions failed: unknown result");
    }

    public ListSessionsResp listSessions(ListSessionsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listSessions", null);
      this.setContextStack(ctx);
      send_listSessions(req);
      return recv_listSessions();
    }

    public void send_listSessions(ListSessionsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listSessions", null);
      oprot_.writeMessageBegin(new TMessage("listSessions", TMessageType.CALL, seqid_));
      listSessions_args args = new listSessions_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listSessions", args);
      return;
    }

    public ListSessionsResp recv_listSessions() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listSessions");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listSessions_result result = new listSessions_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listSessions", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listSessions failed: unknown result");
    }

    public GetSessionResp getSession(GetSessionReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getSession", null);
      this.setContextStack(ctx);
      send_getSession(req);
      return recv_getSession();
    }

    public void send_getSession(GetSessionReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getSession", null);
      oprot_.writeMessageBegin(new TMessage("getSession", TMessageType.CALL, seqid_));
      getSession_args args = new getSession_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getSession", args);
      return;
    }

    public GetSessionResp recv_getSession() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getSession");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getSession_result result = new getSession_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getSession", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getSession failed: unknown result");
    }

    public RemoveSessionResp removeSession(RemoveSessionReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.removeSession", null);
      this.setContextStack(ctx);
      send_removeSession(req);
      return recv_removeSession();
    }

    public void send_removeSession(RemoveSessionReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.removeSession", null);
      oprot_.writeMessageBegin(new TMessage("removeSession", TMessageType.CALL, seqid_));
      removeSession_args args = new removeSession_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.removeSession", args);
      return;
    }

    public RemoveSessionResp recv_removeSession() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.removeSession");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      removeSession_result result = new removeSession_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.removeSession", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "removeSession failed: unknown result");
    }

    public ExecResp killQuery(KillQueryReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.killQuery", null);
      this.setContextStack(ctx);
      send_killQuery(req);
      return recv_killQuery();
    }

    public void send_killQuery(KillQueryReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.killQuery", null);
      oprot_.writeMessageBegin(new TMessage("killQuery", TMessageType.CALL, seqid_));
      killQuery_args args = new killQuery_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.killQuery", args);
      return;
    }

    public ExecResp recv_killQuery() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.killQuery");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      killQuery_result result = new killQuery_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.killQuery", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "killQuery failed: unknown result");
    }

    public ExecResp reportTaskFinish(ReportTaskReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.reportTaskFinish", null);
      this.setContextStack(ctx);
      send_reportTaskFinish(req);
      return recv_reportTaskFinish();
    }

    public void send_reportTaskFinish(ReportTaskReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.reportTaskFinish", null);
      oprot_.writeMessageBegin(new TMessage("reportTaskFinish", TMessageType.CALL, seqid_));
      reportTaskFinish_args args = new reportTaskFinish_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.reportTaskFinish", args);
      return;
    }

    public ExecResp recv_reportTaskFinish() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.reportTaskFinish");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      reportTaskFinish_result result = new reportTaskFinish_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.reportTaskFinish", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "reportTaskFinish failed: unknown result");
    }

    public CreateBackupResp createBackup(CreateBackupReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createBackup", null);
      this.setContextStack(ctx);
      send_createBackup(req);
      return recv_createBackup();
    }

    public void send_createBackup(CreateBackupReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createBackup", null);
      oprot_.writeMessageBegin(new TMessage("createBackup", TMessageType.CALL, seqid_));
      createBackup_args args = new createBackup_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createBackup", args);
      return;
    }

    public CreateBackupResp recv_createBackup() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createBackup");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createBackup_result result = new createBackup_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createBackup", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createBackup failed: unknown result");
    }

    public RestoreMetaResp restoreMeta(RestoreMetaReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.restoreMeta", null);
      this.setContextStack(ctx);
      send_restoreMeta(req);
      return recv_restoreMeta();
    }

    public void send_restoreMeta(RestoreMetaReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.restoreMeta", null);
      oprot_.writeMessageBegin(new TMessage("restoreMeta", TMessageType.CALL, seqid_));
      restoreMeta_args args = new restoreMeta_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.restoreMeta", args);
      return;
    }

    public RestoreMetaResp recv_restoreMeta() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.restoreMeta");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      restoreMeta_result result = new restoreMeta_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.restoreMeta", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "restoreMeta failed: unknown result");
    }

    public ListClusterInfoResp listCluster(ListClusterInfoReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listCluster", null);
      this.setContextStack(ctx);
      send_listCluster(req);
      return recv_listCluster();
    }

    public void send_listCluster(ListClusterInfoReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listCluster", null);
      oprot_.writeMessageBegin(new TMessage("listCluster", TMessageType.CALL, seqid_));
      listCluster_args args = new listCluster_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listCluster", args);
      return;
    }

    public ListClusterInfoResp recv_listCluster() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listCluster");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listCluster_result result = new listCluster_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listCluster", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listCluster failed: unknown result");
    }

    public GetMetaDirInfoResp getMetaDirInfo(GetMetaDirInfoReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getMetaDirInfo", null);
      this.setContextStack(ctx);
      send_getMetaDirInfo(req);
      return recv_getMetaDirInfo();
    }

    public void send_getMetaDirInfo(GetMetaDirInfoReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getMetaDirInfo", null);
      oprot_.writeMessageBegin(new TMessage("getMetaDirInfo", TMessageType.CALL, seqid_));
      getMetaDirInfo_args args = new getMetaDirInfo_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getMetaDirInfo", args);
      return;
    }

    public GetMetaDirInfoResp recv_getMetaDirInfo() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getMetaDirInfo");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getMetaDirInfo_result result = new getMetaDirInfo_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getMetaDirInfo", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getMetaDirInfo failed: unknown result");
    }

    public VerifyClientVersionResp verifyClientVersion(VerifyClientVersionReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.verifyClientVersion", null);
      this.setContextStack(ctx);
      send_verifyClientVersion(req);
      return recv_verifyClientVersion();
    }

    public void send_verifyClientVersion(VerifyClientVersionReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.verifyClientVersion", null);
      oprot_.writeMessageBegin(new TMessage("verifyClientVersion", TMessageType.CALL, seqid_));
      verifyClientVersion_args args = new verifyClientVersion_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.verifyClientVersion", args);
      return;
    }

    public VerifyClientVersionResp recv_verifyClientVersion() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.verifyClientVersion");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      verifyClientVersion_result result = new verifyClientVersion_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.verifyClientVersion", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "verifyClientVersion failed: unknown result");
    }

    public SaveGraphVersionResp saveGraphVersion(SaveGraphVersionReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.saveGraphVersion", null);
      this.setContextStack(ctx);
      send_saveGraphVersion(req);
      return recv_saveGraphVersion();
    }

    public void send_saveGraphVersion(SaveGraphVersionReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.saveGraphVersion", null);
      oprot_.writeMessageBegin(new TMessage("saveGraphVersion", TMessageType.CALL, seqid_));
      saveGraphVersion_args args = new saveGraphVersion_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.saveGraphVersion", args);
      return;
    }

    public SaveGraphVersionResp recv_saveGraphVersion() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.saveGraphVersion");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      saveGraphVersion_result result = new saveGraphVersion_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.saveGraphVersion", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "saveGraphVersion failed: unknown result");
    }

    public GetSegmentIdResp getSegmentId(GetSegmentIdReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getSegmentId", null);
      this.setContextStack(ctx);
      send_getSegmentId(req);
      return recv_getSegmentId();
    }

    public void send_getSegmentId(GetSegmentIdReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getSegmentId", null);
      oprot_.writeMessageBegin(new TMessage("getSegmentId", TMessageType.CALL, seqid_));
      getSegmentId_args args = new getSegmentId_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getSegmentId", args);
      return;
    }

    public GetSegmentIdResp recv_getSegmentId() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getSegmentId");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getSegmentId_result result = new getSegmentId_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getSegmentId", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getSegmentId failed: unknown result");
    }

  }
  public static class AsyncClient extends TAsyncClient implements AsyncIface {
    public static class Factory implements TAsyncClientFactory<AsyncClient> {
      private TAsyncClientManager clientManager;
      private TProtocolFactory protocolFactory;
      public Factory(TAsyncClientManager clientManager, TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(TProtocolFactory protocolFactory, TAsyncClientManager clientManager, TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void createSpace(CreateSpaceReq req, AsyncMethodCallback resultHandler467) throws TException {
      checkReady();
      createSpace_call method_call = new createSpace_call(req, resultHandler467, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createSpace_call extends TAsyncMethodCall {
      private CreateSpaceReq req;
      public createSpace_call(CreateSpaceReq req, AsyncMethodCallback resultHandler468, TAsyncClient client464, TProtocolFactory protocolFactory465, TNonblockingTransport transport466) throws TException {
        super(client464, protocolFactory465, transport466, resultHandler468, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createSpace", TMessageType.CALL, 0));
        createSpace_args args = new createSpace_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createSpace();
      }
    }

    public void dropSpace(DropSpaceReq req, AsyncMethodCallback resultHandler472) throws TException {
      checkReady();
      dropSpace_call method_call = new dropSpace_call(req, resultHandler472, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropSpace_call extends TAsyncMethodCall {
      private DropSpaceReq req;
      public dropSpace_call(DropSpaceReq req, AsyncMethodCallback resultHandler473, TAsyncClient client469, TProtocolFactory protocolFactory470, TNonblockingTransport transport471) throws TException {
        super(client469, protocolFactory470, transport471, resultHandler473, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropSpace", TMessageType.CALL, 0));
        dropSpace_args args = new dropSpace_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropSpace();
      }
    }

    public void clearSpace(ClearSpaceReq req, AsyncMethodCallback resultHandler477) throws TException {
      checkReady();
      clearSpace_call method_call = new clearSpace_call(req, resultHandler477, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class clearSpace_call extends TAsyncMethodCall {
      private ClearSpaceReq req;
      public clearSpace_call(ClearSpaceReq req, AsyncMethodCallback resultHandler478, TAsyncClient client474, TProtocolFactory protocolFactory475, TNonblockingTransport transport476) throws TException {
        super(client474, protocolFactory475, transport476, resultHandler478, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("clearSpace", TMessageType.CALL, 0));
        clearSpace_args args = new clearSpace_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_clearSpace();
      }
    }

    public void getSpace(GetSpaceReq req, AsyncMethodCallback resultHandler482) throws TException {
      checkReady();
      getSpace_call method_call = new getSpace_call(req, resultHandler482, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getSpace_call extends TAsyncMethodCall {
      private GetSpaceReq req;
      public getSpace_call(GetSpaceReq req, AsyncMethodCallback resultHandler483, TAsyncClient client479, TProtocolFactory protocolFactory480, TNonblockingTransport transport481) throws TException {
        super(client479, protocolFactory480, transport481, resultHandler483, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getSpace", TMessageType.CALL, 0));
        getSpace_args args = new getSpace_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetSpaceResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getSpace();
      }
    }

    public void listSpaces(ListSpacesReq req, AsyncMethodCallback resultHandler487) throws TException {
      checkReady();
      listSpaces_call method_call = new listSpaces_call(req, resultHandler487, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listSpaces_call extends TAsyncMethodCall {
      private ListSpacesReq req;
      public listSpaces_call(ListSpacesReq req, AsyncMethodCallback resultHandler488, TAsyncClient client484, TProtocolFactory protocolFactory485, TNonblockingTransport transport486) throws TException {
        super(client484, protocolFactory485, transport486, resultHandler488, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listSpaces", TMessageType.CALL, 0));
        listSpaces_args args = new listSpaces_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListSpacesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listSpaces();
      }
    }

    public void alterSpace(AlterSpaceReq req, AsyncMethodCallback resultHandler492) throws TException {
      checkReady();
      alterSpace_call method_call = new alterSpace_call(req, resultHandler492, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class alterSpace_call extends TAsyncMethodCall {
      private AlterSpaceReq req;
      public alterSpace_call(AlterSpaceReq req, AsyncMethodCallback resultHandler493, TAsyncClient client489, TProtocolFactory protocolFactory490, TNonblockingTransport transport491) throws TException {
        super(client489, protocolFactory490, transport491, resultHandler493, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("alterSpace", TMessageType.CALL, 0));
        alterSpace_args args = new alterSpace_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_alterSpace();
      }
    }

    public void createSpaceAs(CreateSpaceAsReq req, AsyncMethodCallback resultHandler497) throws TException {
      checkReady();
      createSpaceAs_call method_call = new createSpaceAs_call(req, resultHandler497, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createSpaceAs_call extends TAsyncMethodCall {
      private CreateSpaceAsReq req;
      public createSpaceAs_call(CreateSpaceAsReq req, AsyncMethodCallback resultHandler498, TAsyncClient client494, TProtocolFactory protocolFactory495, TNonblockingTransport transport496) throws TException {
        super(client494, protocolFactory495, transport496, resultHandler498, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createSpaceAs", TMessageType.CALL, 0));
        createSpaceAs_args args = new createSpaceAs_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createSpaceAs();
      }
    }

    public void createTag(CreateTagReq req, AsyncMethodCallback resultHandler502) throws TException {
      checkReady();
      createTag_call method_call = new createTag_call(req, resultHandler502, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createTag_call extends TAsyncMethodCall {
      private CreateTagReq req;
      public createTag_call(CreateTagReq req, AsyncMethodCallback resultHandler503, TAsyncClient client499, TProtocolFactory protocolFactory500, TNonblockingTransport transport501) throws TException {
        super(client499, protocolFactory500, transport501, resultHandler503, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createTag", TMessageType.CALL, 0));
        createTag_args args = new createTag_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createTag();
      }
    }

    public void alterTag(AlterTagReq req, AsyncMethodCallback resultHandler507) throws TException {
      checkReady();
      alterTag_call method_call = new alterTag_call(req, resultHandler507, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class alterTag_call extends TAsyncMethodCall {
      private AlterTagReq req;
      public alterTag_call(AlterTagReq req, AsyncMethodCallback resultHandler508, TAsyncClient client504, TProtocolFactory protocolFactory505, TNonblockingTransport transport506) throws TException {
        super(client504, protocolFactory505, transport506, resultHandler508, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("alterTag", TMessageType.CALL, 0));
        alterTag_args args = new alterTag_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_alterTag();
      }
    }

    public void dropTag(DropTagReq req, AsyncMethodCallback resultHandler512) throws TException {
      checkReady();
      dropTag_call method_call = new dropTag_call(req, resultHandler512, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropTag_call extends TAsyncMethodCall {
      private DropTagReq req;
      public dropTag_call(DropTagReq req, AsyncMethodCallback resultHandler513, TAsyncClient client509, TProtocolFactory protocolFactory510, TNonblockingTransport transport511) throws TException {
        super(client509, protocolFactory510, transport511, resultHandler513, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropTag", TMessageType.CALL, 0));
        dropTag_args args = new dropTag_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropTag();
      }
    }

    public void getTag(GetTagReq req, AsyncMethodCallback resultHandler517) throws TException {
      checkReady();
      getTag_call method_call = new getTag_call(req, resultHandler517, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getTag_call extends TAsyncMethodCall {
      private GetTagReq req;
      public getTag_call(GetTagReq req, AsyncMethodCallback resultHandler518, TAsyncClient client514, TProtocolFactory protocolFactory515, TNonblockingTransport transport516) throws TException {
        super(client514, protocolFactory515, transport516, resultHandler518, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTag", TMessageType.CALL, 0));
        getTag_args args = new getTag_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetTagResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTag();
      }
    }

    public void listTags(ListTagsReq req, AsyncMethodCallback resultHandler522) throws TException {
      checkReady();
      listTags_call method_call = new listTags_call(req, resultHandler522, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listTags_call extends TAsyncMethodCall {
      private ListTagsReq req;
      public listTags_call(ListTagsReq req, AsyncMethodCallback resultHandler523, TAsyncClient client519, TProtocolFactory protocolFactory520, TNonblockingTransport transport521) throws TException {
        super(client519, protocolFactory520, transport521, resultHandler523, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listTags", TMessageType.CALL, 0));
        listTags_args args = new listTags_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListTagsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listTags();
      }
    }

    public void createEdge(CreateEdgeReq req, AsyncMethodCallback resultHandler527) throws TException {
      checkReady();
      createEdge_call method_call = new createEdge_call(req, resultHandler527, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createEdge_call extends TAsyncMethodCall {
      private CreateEdgeReq req;
      public createEdge_call(CreateEdgeReq req, AsyncMethodCallback resultHandler528, TAsyncClient client524, TProtocolFactory protocolFactory525, TNonblockingTransport transport526) throws TException {
        super(client524, protocolFactory525, transport526, resultHandler528, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createEdge", TMessageType.CALL, 0));
        createEdge_args args = new createEdge_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createEdge();
      }
    }

    public void alterEdge(AlterEdgeReq req, AsyncMethodCallback resultHandler532) throws TException {
      checkReady();
      alterEdge_call method_call = new alterEdge_call(req, resultHandler532, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class alterEdge_call extends TAsyncMethodCall {
      private AlterEdgeReq req;
      public alterEdge_call(AlterEdgeReq req, AsyncMethodCallback resultHandler533, TAsyncClient client529, TProtocolFactory protocolFactory530, TNonblockingTransport transport531) throws TException {
        super(client529, protocolFactory530, transport531, resultHandler533, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("alterEdge", TMessageType.CALL, 0));
        alterEdge_args args = new alterEdge_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_alterEdge();
      }
    }

    public void dropEdge(DropEdgeReq req, AsyncMethodCallback resultHandler537) throws TException {
      checkReady();
      dropEdge_call method_call = new dropEdge_call(req, resultHandler537, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropEdge_call extends TAsyncMethodCall {
      private DropEdgeReq req;
      public dropEdge_call(DropEdgeReq req, AsyncMethodCallback resultHandler538, TAsyncClient client534, TProtocolFactory protocolFactory535, TNonblockingTransport transport536) throws TException {
        super(client534, protocolFactory535, transport536, resultHandler538, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropEdge", TMessageType.CALL, 0));
        dropEdge_args args = new dropEdge_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropEdge();
      }
    }

    public void getEdge(GetEdgeReq req, AsyncMethodCallback resultHandler542) throws TException {
      checkReady();
      getEdge_call method_call = new getEdge_call(req, resultHandler542, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getEdge_call extends TAsyncMethodCall {
      private GetEdgeReq req;
      public getEdge_call(GetEdgeReq req, AsyncMethodCallback resultHandler543, TAsyncClient client539, TProtocolFactory protocolFactory540, TNonblockingTransport transport541) throws TException {
        super(client539, protocolFactory540, transport541, resultHandler543, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getEdge", TMessageType.CALL, 0));
        getEdge_args args = new getEdge_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetEdgeResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getEdge();
      }
    }

    public void listEdges(ListEdgesReq req, AsyncMethodCallback resultHandler547) throws TException {
      checkReady();
      listEdges_call method_call = new listEdges_call(req, resultHandler547, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listEdges_call extends TAsyncMethodCall {
      private ListEdgesReq req;
      public listEdges_call(ListEdgesReq req, AsyncMethodCallback resultHandler548, TAsyncClient client544, TProtocolFactory protocolFactory545, TNonblockingTransport transport546) throws TException {
        super(client544, protocolFactory545, transport546, resultHandler548, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listEdges", TMessageType.CALL, 0));
        listEdges_args args = new listEdges_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListEdgesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listEdges();
      }
    }

    public void addHosts(AddHostsReq req, AsyncMethodCallback resultHandler552) throws TException {
      checkReady();
      addHosts_call method_call = new addHosts_call(req, resultHandler552, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class addHosts_call extends TAsyncMethodCall {
      private AddHostsReq req;
      public addHosts_call(AddHostsReq req, AsyncMethodCallback resultHandler553, TAsyncClient client549, TProtocolFactory protocolFactory550, TNonblockingTransport transport551) throws TException {
        super(client549, protocolFactory550, transport551, resultHandler553, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("addHosts", TMessageType.CALL, 0));
        addHosts_args args = new addHosts_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_addHosts();
      }
    }

    public void addHostsIntoZone(AddHostsIntoZoneReq req, AsyncMethodCallback resultHandler557) throws TException {
      checkReady();
      addHostsIntoZone_call method_call = new addHostsIntoZone_call(req, resultHandler557, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class addHostsIntoZone_call extends TAsyncMethodCall {
      private AddHostsIntoZoneReq req;
      public addHostsIntoZone_call(AddHostsIntoZoneReq req, AsyncMethodCallback resultHandler558, TAsyncClient client554, TProtocolFactory protocolFactory555, TNonblockingTransport transport556) throws TException {
        super(client554, protocolFactory555, transport556, resultHandler558, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("addHostsIntoZone", TMessageType.CALL, 0));
        addHostsIntoZone_args args = new addHostsIntoZone_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_addHostsIntoZone();
      }
    }

    public void dropHosts(DropHostsReq req, AsyncMethodCallback resultHandler562) throws TException {
      checkReady();
      dropHosts_call method_call = new dropHosts_call(req, resultHandler562, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropHosts_call extends TAsyncMethodCall {
      private DropHostsReq req;
      public dropHosts_call(DropHostsReq req, AsyncMethodCallback resultHandler563, TAsyncClient client559, TProtocolFactory protocolFactory560, TNonblockingTransport transport561) throws TException {
        super(client559, protocolFactory560, transport561, resultHandler563, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropHosts", TMessageType.CALL, 0));
        dropHosts_args args = new dropHosts_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropHosts();
      }
    }

    public void listHosts(ListHostsReq req, AsyncMethodCallback resultHandler567) throws TException {
      checkReady();
      listHosts_call method_call = new listHosts_call(req, resultHandler567, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listHosts_call extends TAsyncMethodCall {
      private ListHostsReq req;
      public listHosts_call(ListHostsReq req, AsyncMethodCallback resultHandler568, TAsyncClient client564, TProtocolFactory protocolFactory565, TNonblockingTransport transport566) throws TException {
        super(client564, protocolFactory565, transport566, resultHandler568, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listHosts", TMessageType.CALL, 0));
        listHosts_args args = new listHosts_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListHostsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listHosts();
      }
    }

    public void getPartsAlloc(GetPartsAllocReq req, AsyncMethodCallback resultHandler572) throws TException {
      checkReady();
      getPartsAlloc_call method_call = new getPartsAlloc_call(req, resultHandler572, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getPartsAlloc_call extends TAsyncMethodCall {
      private GetPartsAllocReq req;
      public getPartsAlloc_call(GetPartsAllocReq req, AsyncMethodCallback resultHandler573, TAsyncClient client569, TProtocolFactory protocolFactory570, TNonblockingTransport transport571) throws TException {
        super(client569, protocolFactory570, transport571, resultHandler573, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getPartsAlloc", TMessageType.CALL, 0));
        getPartsAlloc_args args = new getPartsAlloc_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetPartsAllocResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getPartsAlloc();
      }
    }

    public void listParts(ListPartsReq req, AsyncMethodCallback resultHandler577) throws TException {
      checkReady();
      listParts_call method_call = new listParts_call(req, resultHandler577, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listParts_call extends TAsyncMethodCall {
      private ListPartsReq req;
      public listParts_call(ListPartsReq req, AsyncMethodCallback resultHandler578, TAsyncClient client574, TProtocolFactory protocolFactory575, TNonblockingTransport transport576) throws TException {
        super(client574, protocolFactory575, transport576, resultHandler578, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listParts", TMessageType.CALL, 0));
        listParts_args args = new listParts_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListPartsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listParts();
      }
    }

    public void getWorkerId(GetWorkerIdReq req, AsyncMethodCallback resultHandler582) throws TException {
      checkReady();
      getWorkerId_call method_call = new getWorkerId_call(req, resultHandler582, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getWorkerId_call extends TAsyncMethodCall {
      private GetWorkerIdReq req;
      public getWorkerId_call(GetWorkerIdReq req, AsyncMethodCallback resultHandler583, TAsyncClient client579, TProtocolFactory protocolFactory580, TNonblockingTransport transport581) throws TException {
        super(client579, protocolFactory580, transport581, resultHandler583, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getWorkerId", TMessageType.CALL, 0));
        getWorkerId_args args = new getWorkerId_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetWorkerIdResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getWorkerId();
      }
    }

    public void createTagIndex(CreateTagIndexReq req, AsyncMethodCallback resultHandler587) throws TException {
      checkReady();
      createTagIndex_call method_call = new createTagIndex_call(req, resultHandler587, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createTagIndex_call extends TAsyncMethodCall {
      private CreateTagIndexReq req;
      public createTagIndex_call(CreateTagIndexReq req, AsyncMethodCallback resultHandler588, TAsyncClient client584, TProtocolFactory protocolFactory585, TNonblockingTransport transport586) throws TException {
        super(client584, protocolFactory585, transport586, resultHandler588, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createTagIndex", TMessageType.CALL, 0));
        createTagIndex_args args = new createTagIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createTagIndex();
      }
    }

    public void dropTagIndex(DropTagIndexReq req, AsyncMethodCallback resultHandler592) throws TException {
      checkReady();
      dropTagIndex_call method_call = new dropTagIndex_call(req, resultHandler592, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropTagIndex_call extends TAsyncMethodCall {
      private DropTagIndexReq req;
      public dropTagIndex_call(DropTagIndexReq req, AsyncMethodCallback resultHandler593, TAsyncClient client589, TProtocolFactory protocolFactory590, TNonblockingTransport transport591) throws TException {
        super(client589, protocolFactory590, transport591, resultHandler593, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropTagIndex", TMessageType.CALL, 0));
        dropTagIndex_args args = new dropTagIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropTagIndex();
      }
    }

    public void getTagIndex(GetTagIndexReq req, AsyncMethodCallback resultHandler597) throws TException {
      checkReady();
      getTagIndex_call method_call = new getTagIndex_call(req, resultHandler597, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getTagIndex_call extends TAsyncMethodCall {
      private GetTagIndexReq req;
      public getTagIndex_call(GetTagIndexReq req, AsyncMethodCallback resultHandler598, TAsyncClient client594, TProtocolFactory protocolFactory595, TNonblockingTransport transport596) throws TException {
        super(client594, protocolFactory595, transport596, resultHandler598, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTagIndex", TMessageType.CALL, 0));
        getTagIndex_args args = new getTagIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetTagIndexResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTagIndex();
      }
    }

    public void listTagIndexes(ListTagIndexesReq req, AsyncMethodCallback resultHandler602) throws TException {
      checkReady();
      listTagIndexes_call method_call = new listTagIndexes_call(req, resultHandler602, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listTagIndexes_call extends TAsyncMethodCall {
      private ListTagIndexesReq req;
      public listTagIndexes_call(ListTagIndexesReq req, AsyncMethodCallback resultHandler603, TAsyncClient client599, TProtocolFactory protocolFactory600, TNonblockingTransport transport601) throws TException {
        super(client599, protocolFactory600, transport601, resultHandler603, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listTagIndexes", TMessageType.CALL, 0));
        listTagIndexes_args args = new listTagIndexes_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListTagIndexesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listTagIndexes();
      }
    }

    public void rebuildTagIndex(RebuildIndexReq req, AsyncMethodCallback resultHandler607) throws TException {
      checkReady();
      rebuildTagIndex_call method_call = new rebuildTagIndex_call(req, resultHandler607, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class rebuildTagIndex_call extends TAsyncMethodCall {
      private RebuildIndexReq req;
      public rebuildTagIndex_call(RebuildIndexReq req, AsyncMethodCallback resultHandler608, TAsyncClient client604, TProtocolFactory protocolFactory605, TNonblockingTransport transport606) throws TException {
        super(client604, protocolFactory605, transport606, resultHandler608, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("rebuildTagIndex", TMessageType.CALL, 0));
        rebuildTagIndex_args args = new rebuildTagIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_rebuildTagIndex();
      }
    }

    public void listTagIndexStatus(ListIndexStatusReq req, AsyncMethodCallback resultHandler612) throws TException {
      checkReady();
      listTagIndexStatus_call method_call = new listTagIndexStatus_call(req, resultHandler612, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listTagIndexStatus_call extends TAsyncMethodCall {
      private ListIndexStatusReq req;
      public listTagIndexStatus_call(ListIndexStatusReq req, AsyncMethodCallback resultHandler613, TAsyncClient client609, TProtocolFactory protocolFactory610, TNonblockingTransport transport611) throws TException {
        super(client609, protocolFactory610, transport611, resultHandler613, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listTagIndexStatus", TMessageType.CALL, 0));
        listTagIndexStatus_args args = new listTagIndexStatus_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListIndexStatusResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listTagIndexStatus();
      }
    }

    public void createEdgeIndex(CreateEdgeIndexReq req, AsyncMethodCallback resultHandler617) throws TException {
      checkReady();
      createEdgeIndex_call method_call = new createEdgeIndex_call(req, resultHandler617, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createEdgeIndex_call extends TAsyncMethodCall {
      private CreateEdgeIndexReq req;
      public createEdgeIndex_call(CreateEdgeIndexReq req, AsyncMethodCallback resultHandler618, TAsyncClient client614, TProtocolFactory protocolFactory615, TNonblockingTransport transport616) throws TException {
        super(client614, protocolFactory615, transport616, resultHandler618, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createEdgeIndex", TMessageType.CALL, 0));
        createEdgeIndex_args args = new createEdgeIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createEdgeIndex();
      }
    }

    public void dropEdgeIndex(DropEdgeIndexReq req, AsyncMethodCallback resultHandler622) throws TException {
      checkReady();
      dropEdgeIndex_call method_call = new dropEdgeIndex_call(req, resultHandler622, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropEdgeIndex_call extends TAsyncMethodCall {
      private DropEdgeIndexReq req;
      public dropEdgeIndex_call(DropEdgeIndexReq req, AsyncMethodCallback resultHandler623, TAsyncClient client619, TProtocolFactory protocolFactory620, TNonblockingTransport transport621) throws TException {
        super(client619, protocolFactory620, transport621, resultHandler623, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropEdgeIndex", TMessageType.CALL, 0));
        dropEdgeIndex_args args = new dropEdgeIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropEdgeIndex();
      }
    }

    public void getEdgeIndex(GetEdgeIndexReq req, AsyncMethodCallback resultHandler627) throws TException {
      checkReady();
      getEdgeIndex_call method_call = new getEdgeIndex_call(req, resultHandler627, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getEdgeIndex_call extends TAsyncMethodCall {
      private GetEdgeIndexReq req;
      public getEdgeIndex_call(GetEdgeIndexReq req, AsyncMethodCallback resultHandler628, TAsyncClient client624, TProtocolFactory protocolFactory625, TNonblockingTransport transport626) throws TException {
        super(client624, protocolFactory625, transport626, resultHandler628, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getEdgeIndex", TMessageType.CALL, 0));
        getEdgeIndex_args args = new getEdgeIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetEdgeIndexResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getEdgeIndex();
      }
    }

    public void listEdgeIndexes(ListEdgeIndexesReq req, AsyncMethodCallback resultHandler632) throws TException {
      checkReady();
      listEdgeIndexes_call method_call = new listEdgeIndexes_call(req, resultHandler632, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listEdgeIndexes_call extends TAsyncMethodCall {
      private ListEdgeIndexesReq req;
      public listEdgeIndexes_call(ListEdgeIndexesReq req, AsyncMethodCallback resultHandler633, TAsyncClient client629, TProtocolFactory protocolFactory630, TNonblockingTransport transport631) throws TException {
        super(client629, protocolFactory630, transport631, resultHandler633, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listEdgeIndexes", TMessageType.CALL, 0));
        listEdgeIndexes_args args = new listEdgeIndexes_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListEdgeIndexesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listEdgeIndexes();
      }
    }

    public void rebuildEdgeIndex(RebuildIndexReq req, AsyncMethodCallback resultHandler637) throws TException {
      checkReady();
      rebuildEdgeIndex_call method_call = new rebuildEdgeIndex_call(req, resultHandler637, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class rebuildEdgeIndex_call extends TAsyncMethodCall {
      private RebuildIndexReq req;
      public rebuildEdgeIndex_call(RebuildIndexReq req, AsyncMethodCallback resultHandler638, TAsyncClient client634, TProtocolFactory protocolFactory635, TNonblockingTransport transport636) throws TException {
        super(client634, protocolFactory635, transport636, resultHandler638, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("rebuildEdgeIndex", TMessageType.CALL, 0));
        rebuildEdgeIndex_args args = new rebuildEdgeIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_rebuildEdgeIndex();
      }
    }

    public void listEdgeIndexStatus(ListIndexStatusReq req, AsyncMethodCallback resultHandler642) throws TException {
      checkReady();
      listEdgeIndexStatus_call method_call = new listEdgeIndexStatus_call(req, resultHandler642, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listEdgeIndexStatus_call extends TAsyncMethodCall {
      private ListIndexStatusReq req;
      public listEdgeIndexStatus_call(ListIndexStatusReq req, AsyncMethodCallback resultHandler643, TAsyncClient client639, TProtocolFactory protocolFactory640, TNonblockingTransport transport641) throws TException {
        super(client639, protocolFactory640, transport641, resultHandler643, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listEdgeIndexStatus", TMessageType.CALL, 0));
        listEdgeIndexStatus_args args = new listEdgeIndexStatus_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListIndexStatusResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listEdgeIndexStatus();
      }
    }

    public void createUser(CreateUserReq req, AsyncMethodCallback resultHandler647) throws TException {
      checkReady();
      createUser_call method_call = new createUser_call(req, resultHandler647, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createUser_call extends TAsyncMethodCall {
      private CreateUserReq req;
      public createUser_call(CreateUserReq req, AsyncMethodCallback resultHandler648, TAsyncClient client644, TProtocolFactory protocolFactory645, TNonblockingTransport transport646) throws TException {
        super(client644, protocolFactory645, transport646, resultHandler648, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createUser", TMessageType.CALL, 0));
        createUser_args args = new createUser_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createUser();
      }
    }

    public void dropUser(DropUserReq req, AsyncMethodCallback resultHandler652) throws TException {
      checkReady();
      dropUser_call method_call = new dropUser_call(req, resultHandler652, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropUser_call extends TAsyncMethodCall {
      private DropUserReq req;
      public dropUser_call(DropUserReq req, AsyncMethodCallback resultHandler653, TAsyncClient client649, TProtocolFactory protocolFactory650, TNonblockingTransport transport651) throws TException {
        super(client649, protocolFactory650, transport651, resultHandler653, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropUser", TMessageType.CALL, 0));
        dropUser_args args = new dropUser_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropUser();
      }
    }

    public void alterUser(AlterUserReq req, AsyncMethodCallback resultHandler657) throws TException {
      checkReady();
      alterUser_call method_call = new alterUser_call(req, resultHandler657, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class alterUser_call extends TAsyncMethodCall {
      private AlterUserReq req;
      public alterUser_call(AlterUserReq req, AsyncMethodCallback resultHandler658, TAsyncClient client654, TProtocolFactory protocolFactory655, TNonblockingTransport transport656) throws TException {
        super(client654, protocolFactory655, transport656, resultHandler658, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("alterUser", TMessageType.CALL, 0));
        alterUser_args args = new alterUser_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_alterUser();
      }
    }

    public void grantRole(GrantRoleReq req, AsyncMethodCallback resultHandler662) throws TException {
      checkReady();
      grantRole_call method_call = new grantRole_call(req, resultHandler662, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class grantRole_call extends TAsyncMethodCall {
      private GrantRoleReq req;
      public grantRole_call(GrantRoleReq req, AsyncMethodCallback resultHandler663, TAsyncClient client659, TProtocolFactory protocolFactory660, TNonblockingTransport transport661) throws TException {
        super(client659, protocolFactory660, transport661, resultHandler663, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("grantRole", TMessageType.CALL, 0));
        grantRole_args args = new grantRole_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_grantRole();
      }
    }

    public void revokeRole(RevokeRoleReq req, AsyncMethodCallback resultHandler667) throws TException {
      checkReady();
      revokeRole_call method_call = new revokeRole_call(req, resultHandler667, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class revokeRole_call extends TAsyncMethodCall {
      private RevokeRoleReq req;
      public revokeRole_call(RevokeRoleReq req, AsyncMethodCallback resultHandler668, TAsyncClient client664, TProtocolFactory protocolFactory665, TNonblockingTransport transport666) throws TException {
        super(client664, protocolFactory665, transport666, resultHandler668, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("revokeRole", TMessageType.CALL, 0));
        revokeRole_args args = new revokeRole_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_revokeRole();
      }
    }

    public void listUsers(ListUsersReq req, AsyncMethodCallback resultHandler672) throws TException {
      checkReady();
      listUsers_call method_call = new listUsers_call(req, resultHandler672, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listUsers_call extends TAsyncMethodCall {
      private ListUsersReq req;
      public listUsers_call(ListUsersReq req, AsyncMethodCallback resultHandler673, TAsyncClient client669, TProtocolFactory protocolFactory670, TNonblockingTransport transport671) throws TException {
        super(client669, protocolFactory670, transport671, resultHandler673, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listUsers", TMessageType.CALL, 0));
        listUsers_args args = new listUsers_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListUsersResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listUsers();
      }
    }

    public void listRoles(ListRolesReq req, AsyncMethodCallback resultHandler677) throws TException {
      checkReady();
      listRoles_call method_call = new listRoles_call(req, resultHandler677, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listRoles_call extends TAsyncMethodCall {
      private ListRolesReq req;
      public listRoles_call(ListRolesReq req, AsyncMethodCallback resultHandler678, TAsyncClient client674, TProtocolFactory protocolFactory675, TNonblockingTransport transport676) throws TException {
        super(client674, protocolFactory675, transport676, resultHandler678, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listRoles", TMessageType.CALL, 0));
        listRoles_args args = new listRoles_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListRolesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listRoles();
      }
    }

    public void getUserRoles(GetUserRolesReq req, AsyncMethodCallback resultHandler682) throws TException {
      checkReady();
      getUserRoles_call method_call = new getUserRoles_call(req, resultHandler682, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getUserRoles_call extends TAsyncMethodCall {
      private GetUserRolesReq req;
      public getUserRoles_call(GetUserRolesReq req, AsyncMethodCallback resultHandler683, TAsyncClient client679, TProtocolFactory protocolFactory680, TNonblockingTransport transport681) throws TException {
        super(client679, protocolFactory680, transport681, resultHandler683, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getUserRoles", TMessageType.CALL, 0));
        getUserRoles_args args = new getUserRoles_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListRolesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getUserRoles();
      }
    }

    public void changePassword(ChangePasswordReq req, AsyncMethodCallback resultHandler687) throws TException {
      checkReady();
      changePassword_call method_call = new changePassword_call(req, resultHandler687, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class changePassword_call extends TAsyncMethodCall {
      private ChangePasswordReq req;
      public changePassword_call(ChangePasswordReq req, AsyncMethodCallback resultHandler688, TAsyncClient client684, TProtocolFactory protocolFactory685, TNonblockingTransport transport686) throws TException {
        super(client684, protocolFactory685, transport686, resultHandler688, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("changePassword", TMessageType.CALL, 0));
        changePassword_args args = new changePassword_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_changePassword();
      }
    }

    public void heartBeat(HBReq req, AsyncMethodCallback resultHandler692) throws TException {
      checkReady();
      heartBeat_call method_call = new heartBeat_call(req, resultHandler692, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class heartBeat_call extends TAsyncMethodCall {
      private HBReq req;
      public heartBeat_call(HBReq req, AsyncMethodCallback resultHandler693, TAsyncClient client689, TProtocolFactory protocolFactory690, TNonblockingTransport transport691) throws TException {
        super(client689, protocolFactory690, transport691, resultHandler693, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("heartBeat", TMessageType.CALL, 0));
        heartBeat_args args = new heartBeat_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public HBResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_heartBeat();
      }
    }

    public void agentHeartbeat(AgentHBReq req, AsyncMethodCallback resultHandler697) throws TException {
      checkReady();
      agentHeartbeat_call method_call = new agentHeartbeat_call(req, resultHandler697, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class agentHeartbeat_call extends TAsyncMethodCall {
      private AgentHBReq req;
      public agentHeartbeat_call(AgentHBReq req, AsyncMethodCallback resultHandler698, TAsyncClient client694, TProtocolFactory protocolFactory695, TNonblockingTransport transport696) throws TException {
        super(client694, protocolFactory695, transport696, resultHandler698, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("agentHeartbeat", TMessageType.CALL, 0));
        agentHeartbeat_args args = new agentHeartbeat_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public AgentHBResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_agentHeartbeat();
      }
    }

    public void regConfig(RegConfigReq req, AsyncMethodCallback resultHandler702) throws TException {
      checkReady();
      regConfig_call method_call = new regConfig_call(req, resultHandler702, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class regConfig_call extends TAsyncMethodCall {
      private RegConfigReq req;
      public regConfig_call(RegConfigReq req, AsyncMethodCallback resultHandler703, TAsyncClient client699, TProtocolFactory protocolFactory700, TNonblockingTransport transport701) throws TException {
        super(client699, protocolFactory700, transport701, resultHandler703, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("regConfig", TMessageType.CALL, 0));
        regConfig_args args = new regConfig_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_regConfig();
      }
    }

    public void getConfig(GetConfigReq req, AsyncMethodCallback resultHandler707) throws TException {
      checkReady();
      getConfig_call method_call = new getConfig_call(req, resultHandler707, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getConfig_call extends TAsyncMethodCall {
      private GetConfigReq req;
      public getConfig_call(GetConfigReq req, AsyncMethodCallback resultHandler708, TAsyncClient client704, TProtocolFactory protocolFactory705, TNonblockingTransport transport706) throws TException {
        super(client704, protocolFactory705, transport706, resultHandler708, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getConfig", TMessageType.CALL, 0));
        getConfig_args args = new getConfig_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetConfigResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getConfig();
      }
    }

    public void setConfig(SetConfigReq req, AsyncMethodCallback resultHandler712) throws TException {
      checkReady();
      setConfig_call method_call = new setConfig_call(req, resultHandler712, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class setConfig_call extends TAsyncMethodCall {
      private SetConfigReq req;
      public setConfig_call(SetConfigReq req, AsyncMethodCallback resultHandler713, TAsyncClient client709, TProtocolFactory protocolFactory710, TNonblockingTransport transport711) throws TException {
        super(client709, protocolFactory710, transport711, resultHandler713, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("setConfig", TMessageType.CALL, 0));
        setConfig_args args = new setConfig_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_setConfig();
      }
    }

    public void listConfigs(ListConfigsReq req, AsyncMethodCallback resultHandler717) throws TException {
      checkReady();
      listConfigs_call method_call = new listConfigs_call(req, resultHandler717, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listConfigs_call extends TAsyncMethodCall {
      private ListConfigsReq req;
      public listConfigs_call(ListConfigsReq req, AsyncMethodCallback resultHandler718, TAsyncClient client714, TProtocolFactory protocolFactory715, TNonblockingTransport transport716) throws TException {
        super(client714, protocolFactory715, transport716, resultHandler718, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listConfigs", TMessageType.CALL, 0));
        listConfigs_args args = new listConfigs_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListConfigsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listConfigs();
      }
    }

    public void createSnapshot(CreateSnapshotReq req, AsyncMethodCallback resultHandler722) throws TException {
      checkReady();
      createSnapshot_call method_call = new createSnapshot_call(req, resultHandler722, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createSnapshot_call extends TAsyncMethodCall {
      private CreateSnapshotReq req;
      public createSnapshot_call(CreateSnapshotReq req, AsyncMethodCallback resultHandler723, TAsyncClient client719, TProtocolFactory protocolFactory720, TNonblockingTransport transport721) throws TException {
        super(client719, protocolFactory720, transport721, resultHandler723, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createSnapshot", TMessageType.CALL, 0));
        createSnapshot_args args = new createSnapshot_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createSnapshot();
      }
    }

    public void dropSnapshot(DropSnapshotReq req, AsyncMethodCallback resultHandler727) throws TException {
      checkReady();
      dropSnapshot_call method_call = new dropSnapshot_call(req, resultHandler727, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropSnapshot_call extends TAsyncMethodCall {
      private DropSnapshotReq req;
      public dropSnapshot_call(DropSnapshotReq req, AsyncMethodCallback resultHandler728, TAsyncClient client724, TProtocolFactory protocolFactory725, TNonblockingTransport transport726) throws TException {
        super(client724, protocolFactory725, transport726, resultHandler728, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropSnapshot", TMessageType.CALL, 0));
        dropSnapshot_args args = new dropSnapshot_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropSnapshot();
      }
    }

    public void listSnapshots(ListSnapshotsReq req, AsyncMethodCallback resultHandler732) throws TException {
      checkReady();
      listSnapshots_call method_call = new listSnapshots_call(req, resultHandler732, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listSnapshots_call extends TAsyncMethodCall {
      private ListSnapshotsReq req;
      public listSnapshots_call(ListSnapshotsReq req, AsyncMethodCallback resultHandler733, TAsyncClient client729, TProtocolFactory protocolFactory730, TNonblockingTransport transport731) throws TException {
        super(client729, protocolFactory730, transport731, resultHandler733, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listSnapshots", TMessageType.CALL, 0));
        listSnapshots_args args = new listSnapshots_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListSnapshotsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listSnapshots();
      }
    }

    public void runAdminJob(AdminJobReq req, AsyncMethodCallback resultHandler737) throws TException {
      checkReady();
      runAdminJob_call method_call = new runAdminJob_call(req, resultHandler737, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class runAdminJob_call extends TAsyncMethodCall {
      private AdminJobReq req;
      public runAdminJob_call(AdminJobReq req, AsyncMethodCallback resultHandler738, TAsyncClient client734, TProtocolFactory protocolFactory735, TNonblockingTransport transport736) throws TException {
        super(client734, protocolFactory735, transport736, resultHandler738, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("runAdminJob", TMessageType.CALL, 0));
        runAdminJob_args args = new runAdminJob_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public AdminJobResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_runAdminJob();
      }
    }

    public void mergeZone(MergeZoneReq req, AsyncMethodCallback resultHandler742) throws TException {
      checkReady();
      mergeZone_call method_call = new mergeZone_call(req, resultHandler742, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class mergeZone_call extends TAsyncMethodCall {
      private MergeZoneReq req;
      public mergeZone_call(MergeZoneReq req, AsyncMethodCallback resultHandler743, TAsyncClient client739, TProtocolFactory protocolFactory740, TNonblockingTransport transport741) throws TException {
        super(client739, protocolFactory740, transport741, resultHandler743, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("mergeZone", TMessageType.CALL, 0));
        mergeZone_args args = new mergeZone_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_mergeZone();
      }
    }

    public void dropZone(DropZoneReq req, AsyncMethodCallback resultHandler747) throws TException {
      checkReady();
      dropZone_call method_call = new dropZone_call(req, resultHandler747, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropZone_call extends TAsyncMethodCall {
      private DropZoneReq req;
      public dropZone_call(DropZoneReq req, AsyncMethodCallback resultHandler748, TAsyncClient client744, TProtocolFactory protocolFactory745, TNonblockingTransport transport746) throws TException {
        super(client744, protocolFactory745, transport746, resultHandler748, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropZone", TMessageType.CALL, 0));
        dropZone_args args = new dropZone_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropZone();
      }
    }

    public void divideZone(DivideZoneReq req, AsyncMethodCallback resultHandler752) throws TException {
      checkReady();
      divideZone_call method_call = new divideZone_call(req, resultHandler752, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class divideZone_call extends TAsyncMethodCall {
      private DivideZoneReq req;
      public divideZone_call(DivideZoneReq req, AsyncMethodCallback resultHandler753, TAsyncClient client749, TProtocolFactory protocolFactory750, TNonblockingTransport transport751) throws TException {
        super(client749, protocolFactory750, transport751, resultHandler753, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("divideZone", TMessageType.CALL, 0));
        divideZone_args args = new divideZone_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_divideZone();
      }
    }

    public void renameZone(RenameZoneReq req, AsyncMethodCallback resultHandler757) throws TException {
      checkReady();
      renameZone_call method_call = new renameZone_call(req, resultHandler757, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class renameZone_call extends TAsyncMethodCall {
      private RenameZoneReq req;
      public renameZone_call(RenameZoneReq req, AsyncMethodCallback resultHandler758, TAsyncClient client754, TProtocolFactory protocolFactory755, TNonblockingTransport transport756) throws TException {
        super(client754, protocolFactory755, transport756, resultHandler758, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("renameZone", TMessageType.CALL, 0));
        renameZone_args args = new renameZone_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_renameZone();
      }
    }

    public void getZone(GetZoneReq req, AsyncMethodCallback resultHandler762) throws TException {
      checkReady();
      getZone_call method_call = new getZone_call(req, resultHandler762, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getZone_call extends TAsyncMethodCall {
      private GetZoneReq req;
      public getZone_call(GetZoneReq req, AsyncMethodCallback resultHandler763, TAsyncClient client759, TProtocolFactory protocolFactory760, TNonblockingTransport transport761) throws TException {
        super(client759, protocolFactory760, transport761, resultHandler763, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getZone", TMessageType.CALL, 0));
        getZone_args args = new getZone_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetZoneResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getZone();
      }
    }

    public void listZones(ListZonesReq req, AsyncMethodCallback resultHandler767) throws TException {
      checkReady();
      listZones_call method_call = new listZones_call(req, resultHandler767, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listZones_call extends TAsyncMethodCall {
      private ListZonesReq req;
      public listZones_call(ListZonesReq req, AsyncMethodCallback resultHandler768, TAsyncClient client764, TProtocolFactory protocolFactory765, TNonblockingTransport transport766) throws TException {
        super(client764, protocolFactory765, transport766, resultHandler768, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listZones", TMessageType.CALL, 0));
        listZones_args args = new listZones_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListZonesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listZones();
      }
    }

    public void addListener(AddListenerReq req, AsyncMethodCallback resultHandler772) throws TException {
      checkReady();
      addListener_call method_call = new addListener_call(req, resultHandler772, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class addListener_call extends TAsyncMethodCall {
      private AddListenerReq req;
      public addListener_call(AddListenerReq req, AsyncMethodCallback resultHandler773, TAsyncClient client769, TProtocolFactory protocolFactory770, TNonblockingTransport transport771) throws TException {
        super(client769, protocolFactory770, transport771, resultHandler773, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("addListener", TMessageType.CALL, 0));
        addListener_args args = new addListener_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_addListener();
      }
    }

    public void removeListener(RemoveListenerReq req, AsyncMethodCallback resultHandler777) throws TException {
      checkReady();
      removeListener_call method_call = new removeListener_call(req, resultHandler777, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class removeListener_call extends TAsyncMethodCall {
      private RemoveListenerReq req;
      public removeListener_call(RemoveListenerReq req, AsyncMethodCallback resultHandler778, TAsyncClient client774, TProtocolFactory protocolFactory775, TNonblockingTransport transport776) throws TException {
        super(client774, protocolFactory775, transport776, resultHandler778, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("removeListener", TMessageType.CALL, 0));
        removeListener_args args = new removeListener_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_removeListener();
      }
    }

    public void listListener(ListListenerReq req, AsyncMethodCallback resultHandler782) throws TException {
      checkReady();
      listListener_call method_call = new listListener_call(req, resultHandler782, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listListener_call extends TAsyncMethodCall {
      private ListListenerReq req;
      public listListener_call(ListListenerReq req, AsyncMethodCallback resultHandler783, TAsyncClient client779, TProtocolFactory protocolFactory780, TNonblockingTransport transport781) throws TException {
        super(client779, protocolFactory780, transport781, resultHandler783, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listListener", TMessageType.CALL, 0));
        listListener_args args = new listListener_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListListenerResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listListener();
      }
    }

    public void getStats(GetStatsReq req, AsyncMethodCallback resultHandler787) throws TException {
      checkReady();
      getStats_call method_call = new getStats_call(req, resultHandler787, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getStats_call extends TAsyncMethodCall {
      private GetStatsReq req;
      public getStats_call(GetStatsReq req, AsyncMethodCallback resultHandler788, TAsyncClient client784, TProtocolFactory protocolFactory785, TNonblockingTransport transport786) throws TException {
        super(client784, protocolFactory785, transport786, resultHandler788, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getStats", TMessageType.CALL, 0));
        getStats_args args = new getStats_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetStatsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getStats();
      }
    }

    public void signInService(SignInServiceReq req, AsyncMethodCallback resultHandler792) throws TException {
      checkReady();
      signInService_call method_call = new signInService_call(req, resultHandler792, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class signInService_call extends TAsyncMethodCall {
      private SignInServiceReq req;
      public signInService_call(SignInServiceReq req, AsyncMethodCallback resultHandler793, TAsyncClient client789, TProtocolFactory protocolFactory790, TNonblockingTransport transport791) throws TException {
        super(client789, protocolFactory790, transport791, resultHandler793, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("signInService", TMessageType.CALL, 0));
        signInService_args args = new signInService_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_signInService();
      }
    }

    public void signOutService(SignOutServiceReq req, AsyncMethodCallback resultHandler797) throws TException {
      checkReady();
      signOutService_call method_call = new signOutService_call(req, resultHandler797, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class signOutService_call extends TAsyncMethodCall {
      private SignOutServiceReq req;
      public signOutService_call(SignOutServiceReq req, AsyncMethodCallback resultHandler798, TAsyncClient client794, TProtocolFactory protocolFactory795, TNonblockingTransport transport796) throws TException {
        super(client794, protocolFactory795, transport796, resultHandler798, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("signOutService", TMessageType.CALL, 0));
        signOutService_args args = new signOutService_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_signOutService();
      }
    }

    public void listServiceClients(ListServiceClientsReq req, AsyncMethodCallback resultHandler802) throws TException {
      checkReady();
      listServiceClients_call method_call = new listServiceClients_call(req, resultHandler802, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listServiceClients_call extends TAsyncMethodCall {
      private ListServiceClientsReq req;
      public listServiceClients_call(ListServiceClientsReq req, AsyncMethodCallback resultHandler803, TAsyncClient client799, TProtocolFactory protocolFactory800, TNonblockingTransport transport801) throws TException {
        super(client799, protocolFactory800, transport801, resultHandler803, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listServiceClients", TMessageType.CALL, 0));
        listServiceClients_args args = new listServiceClients_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListServiceClientsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listServiceClients();
      }
    }

    public void createFTIndex(CreateFTIndexReq req, AsyncMethodCallback resultHandler807) throws TException {
      checkReady();
      createFTIndex_call method_call = new createFTIndex_call(req, resultHandler807, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createFTIndex_call extends TAsyncMethodCall {
      private CreateFTIndexReq req;
      public createFTIndex_call(CreateFTIndexReq req, AsyncMethodCallback resultHandler808, TAsyncClient client804, TProtocolFactory protocolFactory805, TNonblockingTransport transport806) throws TException {
        super(client804, protocolFactory805, transport806, resultHandler808, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createFTIndex", TMessageType.CALL, 0));
        createFTIndex_args args = new createFTIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createFTIndex();
      }
    }

    public void dropFTIndex(DropFTIndexReq req, AsyncMethodCallback resultHandler812) throws TException {
      checkReady();
      dropFTIndex_call method_call = new dropFTIndex_call(req, resultHandler812, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropFTIndex_call extends TAsyncMethodCall {
      private DropFTIndexReq req;
      public dropFTIndex_call(DropFTIndexReq req, AsyncMethodCallback resultHandler813, TAsyncClient client809, TProtocolFactory protocolFactory810, TNonblockingTransport transport811) throws TException {
        super(client809, protocolFactory810, transport811, resultHandler813, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropFTIndex", TMessageType.CALL, 0));
        dropFTIndex_args args = new dropFTIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropFTIndex();
      }
    }

    public void listFTIndexes(ListFTIndexesReq req, AsyncMethodCallback resultHandler817) throws TException {
      checkReady();
      listFTIndexes_call method_call = new listFTIndexes_call(req, resultHandler817, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listFTIndexes_call extends TAsyncMethodCall {
      private ListFTIndexesReq req;
      public listFTIndexes_call(ListFTIndexesReq req, AsyncMethodCallback resultHandler818, TAsyncClient client814, TProtocolFactory protocolFactory815, TNonblockingTransport transport816) throws TException {
        super(client814, protocolFactory815, transport816, resultHandler818, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listFTIndexes", TMessageType.CALL, 0));
        listFTIndexes_args args = new listFTIndexes_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListFTIndexesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listFTIndexes();
      }
    }

    public void createSession(CreateSessionReq req, AsyncMethodCallback resultHandler822) throws TException {
      checkReady();
      createSession_call method_call = new createSession_call(req, resultHandler822, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createSession_call extends TAsyncMethodCall {
      private CreateSessionReq req;
      public createSession_call(CreateSessionReq req, AsyncMethodCallback resultHandler823, TAsyncClient client819, TProtocolFactory protocolFactory820, TNonblockingTransport transport821) throws TException {
        super(client819, protocolFactory820, transport821, resultHandler823, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createSession", TMessageType.CALL, 0));
        createSession_args args = new createSession_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public CreateSessionResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createSession();
      }
    }

    public void updateSessions(UpdateSessionsReq req, AsyncMethodCallback resultHandler827) throws TException {
      checkReady();
      updateSessions_call method_call = new updateSessions_call(req, resultHandler827, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class updateSessions_call extends TAsyncMethodCall {
      private UpdateSessionsReq req;
      public updateSessions_call(UpdateSessionsReq req, AsyncMethodCallback resultHandler828, TAsyncClient client824, TProtocolFactory protocolFactory825, TNonblockingTransport transport826) throws TException {
        super(client824, protocolFactory825, transport826, resultHandler828, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("updateSessions", TMessageType.CALL, 0));
        updateSessions_args args = new updateSessions_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public UpdateSessionsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_updateSessions();
      }
    }

    public void listSessions(ListSessionsReq req, AsyncMethodCallback resultHandler832) throws TException {
      checkReady();
      listSessions_call method_call = new listSessions_call(req, resultHandler832, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listSessions_call extends TAsyncMethodCall {
      private ListSessionsReq req;
      public listSessions_call(ListSessionsReq req, AsyncMethodCallback resultHandler833, TAsyncClient client829, TProtocolFactory protocolFactory830, TNonblockingTransport transport831) throws TException {
        super(client829, protocolFactory830, transport831, resultHandler833, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listSessions", TMessageType.CALL, 0));
        listSessions_args args = new listSessions_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListSessionsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listSessions();
      }
    }

    public void getSession(GetSessionReq req, AsyncMethodCallback resultHandler837) throws TException {
      checkReady();
      getSession_call method_call = new getSession_call(req, resultHandler837, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getSession_call extends TAsyncMethodCall {
      private GetSessionReq req;
      public getSession_call(GetSessionReq req, AsyncMethodCallback resultHandler838, TAsyncClient client834, TProtocolFactory protocolFactory835, TNonblockingTransport transport836) throws TException {
        super(client834, protocolFactory835, transport836, resultHandler838, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getSession", TMessageType.CALL, 0));
        getSession_args args = new getSession_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetSessionResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getSession();
      }
    }

    public void removeSession(RemoveSessionReq req, AsyncMethodCallback resultHandler842) throws TException {
      checkReady();
      removeSession_call method_call = new removeSession_call(req, resultHandler842, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class removeSession_call extends TAsyncMethodCall {
      private RemoveSessionReq req;
      public removeSession_call(RemoveSessionReq req, AsyncMethodCallback resultHandler843, TAsyncClient client839, TProtocolFactory protocolFactory840, TNonblockingTransport transport841) throws TException {
        super(client839, protocolFactory840, transport841, resultHandler843, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("removeSession", TMessageType.CALL, 0));
        removeSession_args args = new removeSession_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public RemoveSessionResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_removeSession();
      }
    }

    public void killQuery(KillQueryReq req, AsyncMethodCallback resultHandler847) throws TException {
      checkReady();
      killQuery_call method_call = new killQuery_call(req, resultHandler847, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class killQuery_call extends TAsyncMethodCall {
      private KillQueryReq req;
      public killQuery_call(KillQueryReq req, AsyncMethodCallback resultHandler848, TAsyncClient client844, TProtocolFactory protocolFactory845, TNonblockingTransport transport846) throws TException {
        super(client844, protocolFactory845, transport846, resultHandler848, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("killQuery", TMessageType.CALL, 0));
        killQuery_args args = new killQuery_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_killQuery();
      }
    }

    public void reportTaskFinish(ReportTaskReq req, AsyncMethodCallback resultHandler852) throws TException {
      checkReady();
      reportTaskFinish_call method_call = new reportTaskFinish_call(req, resultHandler852, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class reportTaskFinish_call extends TAsyncMethodCall {
      private ReportTaskReq req;
      public reportTaskFinish_call(ReportTaskReq req, AsyncMethodCallback resultHandler853, TAsyncClient client849, TProtocolFactory protocolFactory850, TNonblockingTransport transport851) throws TException {
        super(client849, protocolFactory850, transport851, resultHandler853, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("reportTaskFinish", TMessageType.CALL, 0));
        reportTaskFinish_args args = new reportTaskFinish_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_reportTaskFinish();
      }
    }

    public void createBackup(CreateBackupReq req, AsyncMethodCallback resultHandler857) throws TException {
      checkReady();
      createBackup_call method_call = new createBackup_call(req, resultHandler857, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createBackup_call extends TAsyncMethodCall {
      private CreateBackupReq req;
      public createBackup_call(CreateBackupReq req, AsyncMethodCallback resultHandler858, TAsyncClient client854, TProtocolFactory protocolFactory855, TNonblockingTransport transport856) throws TException {
        super(client854, protocolFactory855, transport856, resultHandler858, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createBackup", TMessageType.CALL, 0));
        createBackup_args args = new createBackup_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public CreateBackupResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createBackup();
      }
    }

    public void restoreMeta(RestoreMetaReq req, AsyncMethodCallback resultHandler862) throws TException {
      checkReady();
      restoreMeta_call method_call = new restoreMeta_call(req, resultHandler862, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class restoreMeta_call extends TAsyncMethodCall {
      private RestoreMetaReq req;
      public restoreMeta_call(RestoreMetaReq req, AsyncMethodCallback resultHandler863, TAsyncClient client859, TProtocolFactory protocolFactory860, TNonblockingTransport transport861) throws TException {
        super(client859, protocolFactory860, transport861, resultHandler863, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("restoreMeta", TMessageType.CALL, 0));
        restoreMeta_args args = new restoreMeta_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public RestoreMetaResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_restoreMeta();
      }
    }

    public void listCluster(ListClusterInfoReq req, AsyncMethodCallback resultHandler867) throws TException {
      checkReady();
      listCluster_call method_call = new listCluster_call(req, resultHandler867, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listCluster_call extends TAsyncMethodCall {
      private ListClusterInfoReq req;
      public listCluster_call(ListClusterInfoReq req, AsyncMethodCallback resultHandler868, TAsyncClient client864, TProtocolFactory protocolFactory865, TNonblockingTransport transport866) throws TException {
        super(client864, protocolFactory865, transport866, resultHandler868, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listCluster", TMessageType.CALL, 0));
        listCluster_args args = new listCluster_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListClusterInfoResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listCluster();
      }
    }

    public void getMetaDirInfo(GetMetaDirInfoReq req, AsyncMethodCallback resultHandler872) throws TException {
      checkReady();
      getMetaDirInfo_call method_call = new getMetaDirInfo_call(req, resultHandler872, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getMetaDirInfo_call extends TAsyncMethodCall {
      private GetMetaDirInfoReq req;
      public getMetaDirInfo_call(GetMetaDirInfoReq req, AsyncMethodCallback resultHandler873, TAsyncClient client869, TProtocolFactory protocolFactory870, TNonblockingTransport transport871) throws TException {
        super(client869, protocolFactory870, transport871, resultHandler873, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getMetaDirInfo", TMessageType.CALL, 0));
        getMetaDirInfo_args args = new getMetaDirInfo_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetMetaDirInfoResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getMetaDirInfo();
      }
    }

    public void verifyClientVersion(VerifyClientVersionReq req, AsyncMethodCallback resultHandler877) throws TException {
      checkReady();
      verifyClientVersion_call method_call = new verifyClientVersion_call(req, resultHandler877, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class verifyClientVersion_call extends TAsyncMethodCall {
      private VerifyClientVersionReq req;
      public verifyClientVersion_call(VerifyClientVersionReq req, AsyncMethodCallback resultHandler878, TAsyncClient client874, TProtocolFactory protocolFactory875, TNonblockingTransport transport876) throws TException {
        super(client874, protocolFactory875, transport876, resultHandler878, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("verifyClientVersion", TMessageType.CALL, 0));
        verifyClientVersion_args args = new verifyClientVersion_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public VerifyClientVersionResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_verifyClientVersion();
      }
    }

    public void saveGraphVersion(SaveGraphVersionReq req, AsyncMethodCallback resultHandler882) throws TException {
      checkReady();
      saveGraphVersion_call method_call = new saveGraphVersion_call(req, resultHandler882, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class saveGraphVersion_call extends TAsyncMethodCall {
      private SaveGraphVersionReq req;
      public saveGraphVersion_call(SaveGraphVersionReq req, AsyncMethodCallback resultHandler883, TAsyncClient client879, TProtocolFactory protocolFactory880, TNonblockingTransport transport881) throws TException {
        super(client879, protocolFactory880, transport881, resultHandler883, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("saveGraphVersion", TMessageType.CALL, 0));
        saveGraphVersion_args args = new saveGraphVersion_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public SaveGraphVersionResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_saveGraphVersion();
      }
    }

    public void getSegmentId(GetSegmentIdReq req, AsyncMethodCallback resultHandler887) throws TException {
      checkReady();
      getSegmentId_call method_call = new getSegmentId_call(req, resultHandler887, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getSegmentId_call extends TAsyncMethodCall {
      private GetSegmentIdReq req;
      public getSegmentId_call(GetSegmentIdReq req, AsyncMethodCallback resultHandler888, TAsyncClient client884, TProtocolFactory protocolFactory885, TNonblockingTransport transport886) throws TException {
        super(client884, protocolFactory885, transport886, resultHandler888, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getSegmentId", TMessageType.CALL, 0));
        getSegmentId_args args = new getSegmentId_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetSegmentIdResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getSegmentId();
      }
    }

  }

  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      event_handler_ = new TProcessorEventHandler(); // Empty handler
      processMap_.put("createSpace", new createSpace());
      processMap_.put("dropSpace", new dropSpace());
      processMap_.put("clearSpace", new clearSpace());
      processMap_.put("getSpace", new getSpace());
      processMap_.put("listSpaces", new listSpaces());
      processMap_.put("alterSpace", new alterSpace());
      processMap_.put("createSpaceAs", new createSpaceAs());
      processMap_.put("createTag", new createTag());
      processMap_.put("alterTag", new alterTag());
      processMap_.put("dropTag", new dropTag());
      processMap_.put("getTag", new getTag());
      processMap_.put("listTags", new listTags());
      processMap_.put("createEdge", new createEdge());
      processMap_.put("alterEdge", new alterEdge());
      processMap_.put("dropEdge", new dropEdge());
      processMap_.put("getEdge", new getEdge());
      processMap_.put("listEdges", new listEdges());
      processMap_.put("addHosts", new addHosts());
      processMap_.put("addHostsIntoZone", new addHostsIntoZone());
      processMap_.put("dropHosts", new dropHosts());
      processMap_.put("listHosts", new listHosts());
      processMap_.put("getPartsAlloc", new getPartsAlloc());
      processMap_.put("listParts", new listParts());
      processMap_.put("getWorkerId", new getWorkerId());
      processMap_.put("createTagIndex", new createTagIndex());
      processMap_.put("dropTagIndex", new dropTagIndex());
      processMap_.put("getTagIndex", new getTagIndex());
      processMap_.put("listTagIndexes", new listTagIndexes());
      processMap_.put("rebuildTagIndex", new rebuildTagIndex());
      processMap_.put("listTagIndexStatus", new listTagIndexStatus());
      processMap_.put("createEdgeIndex", new createEdgeIndex());
      processMap_.put("dropEdgeIndex", new dropEdgeIndex());
      processMap_.put("getEdgeIndex", new getEdgeIndex());
      processMap_.put("listEdgeIndexes", new listEdgeIndexes());
      processMap_.put("rebuildEdgeIndex", new rebuildEdgeIndex());
      processMap_.put("listEdgeIndexStatus", new listEdgeIndexStatus());
      processMap_.put("createUser", new createUser());
      processMap_.put("dropUser", new dropUser());
      processMap_.put("alterUser", new alterUser());
      processMap_.put("grantRole", new grantRole());
      processMap_.put("revokeRole", new revokeRole());
      processMap_.put("listUsers", new listUsers());
      processMap_.put("listRoles", new listRoles());
      processMap_.put("getUserRoles", new getUserRoles());
      processMap_.put("changePassword", new changePassword());
      processMap_.put("heartBeat", new heartBeat());
      processMap_.put("agentHeartbeat", new agentHeartbeat());
      processMap_.put("regConfig", new regConfig());
      processMap_.put("getConfig", new getConfig());
      processMap_.put("setConfig", new setConfig());
      processMap_.put("listConfigs", new listConfigs());
      processMap_.put("createSnapshot", new createSnapshot());
      processMap_.put("dropSnapshot", new dropSnapshot());
      processMap_.put("listSnapshots", new listSnapshots());
      processMap_.put("runAdminJob", new runAdminJob());
      processMap_.put("mergeZone", new mergeZone());
      processMap_.put("dropZone", new dropZone());
      processMap_.put("divideZone", new divideZone());
      processMap_.put("renameZone", new renameZone());
      processMap_.put("getZone", new getZone());
      processMap_.put("listZones", new listZones());
      processMap_.put("addListener", new addListener());
      processMap_.put("removeListener", new removeListener());
      processMap_.put("listListener", new listListener());
      processMap_.put("getStats", new getStats());
      processMap_.put("signInService", new signInService());
      processMap_.put("signOutService", new signOutService());
      processMap_.put("listServiceClients", new listServiceClients());
      processMap_.put("createFTIndex", new createFTIndex());
      processMap_.put("dropFTIndex", new dropFTIndex());
      processMap_.put("listFTIndexes", new listFTIndexes());
      processMap_.put("createSession", new createSession());
      processMap_.put("updateSessions", new updateSessions());
      processMap_.put("listSessions", new listSessions());
      processMap_.put("getSession", new getSession());
      processMap_.put("removeSession", new removeSession());
      processMap_.put("killQuery", new killQuery());
      processMap_.put("reportTaskFinish", new reportTaskFinish());
      processMap_.put("createBackup", new createBackup());
      processMap_.put("restoreMeta", new restoreMeta());
      processMap_.put("listCluster", new listCluster());
      processMap_.put("getMetaDirInfo", new getMetaDirInfo());
      processMap_.put("verifyClientVersion", new verifyClientVersion());
      processMap_.put("saveGraphVersion", new saveGraphVersion());
      processMap_.put("getSegmentId", new getSegmentId());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException;
    }

    public void setEventHandler(TProcessorEventHandler handler) {
      this.event_handler_ = handler;
    }

    private Iface iface_;
    protected TProcessorEventHandler event_handler_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot, server_ctx);
      return true;
    }

    private class createSpace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createSpace", server_ctx);
        createSpace_args args = new createSpace_args();
        event_handler_.preRead(handler_ctx, "MetaService.createSpace");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createSpace", args);
        createSpace_result result = new createSpace_result();
        result.success = iface_.createSpace(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createSpace", result);
        oprot.writeMessageBegin(new TMessage("createSpace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createSpace", result);
      }

    }

    private class dropSpace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropSpace", server_ctx);
        dropSpace_args args = new dropSpace_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropSpace");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropSpace", args);
        dropSpace_result result = new dropSpace_result();
        result.success = iface_.dropSpace(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropSpace", result);
        oprot.writeMessageBegin(new TMessage("dropSpace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropSpace", result);
      }

    }

    private class clearSpace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.clearSpace", server_ctx);
        clearSpace_args args = new clearSpace_args();
        event_handler_.preRead(handler_ctx, "MetaService.clearSpace");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.clearSpace", args);
        clearSpace_result result = new clearSpace_result();
        result.success = iface_.clearSpace(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.clearSpace", result);
        oprot.writeMessageBegin(new TMessage("clearSpace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.clearSpace", result);
      }

    }

    private class getSpace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getSpace", server_ctx);
        getSpace_args args = new getSpace_args();
        event_handler_.preRead(handler_ctx, "MetaService.getSpace");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getSpace", args);
        getSpace_result result = new getSpace_result();
        result.success = iface_.getSpace(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getSpace", result);
        oprot.writeMessageBegin(new TMessage("getSpace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getSpace", result);
      }

    }

    private class listSpaces implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listSpaces", server_ctx);
        listSpaces_args args = new listSpaces_args();
        event_handler_.preRead(handler_ctx, "MetaService.listSpaces");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listSpaces", args);
        listSpaces_result result = new listSpaces_result();
        result.success = iface_.listSpaces(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listSpaces", result);
        oprot.writeMessageBegin(new TMessage("listSpaces", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listSpaces", result);
      }

    }

    private class alterSpace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.alterSpace", server_ctx);
        alterSpace_args args = new alterSpace_args();
        event_handler_.preRead(handler_ctx, "MetaService.alterSpace");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.alterSpace", args);
        alterSpace_result result = new alterSpace_result();
        result.success = iface_.alterSpace(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.alterSpace", result);
        oprot.writeMessageBegin(new TMessage("alterSpace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.alterSpace", result);
      }

    }

    private class createSpaceAs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createSpaceAs", server_ctx);
        createSpaceAs_args args = new createSpaceAs_args();
        event_handler_.preRead(handler_ctx, "MetaService.createSpaceAs");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createSpaceAs", args);
        createSpaceAs_result result = new createSpaceAs_result();
        result.success = iface_.createSpaceAs(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createSpaceAs", result);
        oprot.writeMessageBegin(new TMessage("createSpaceAs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createSpaceAs", result);
      }

    }

    private class createTag implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createTag", server_ctx);
        createTag_args args = new createTag_args();
        event_handler_.preRead(handler_ctx, "MetaService.createTag");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createTag", args);
        createTag_result result = new createTag_result();
        result.success = iface_.createTag(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createTag", result);
        oprot.writeMessageBegin(new TMessage("createTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createTag", result);
      }

    }

    private class alterTag implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.alterTag", server_ctx);
        alterTag_args args = new alterTag_args();
        event_handler_.preRead(handler_ctx, "MetaService.alterTag");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.alterTag", args);
        alterTag_result result = new alterTag_result();
        result.success = iface_.alterTag(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.alterTag", result);
        oprot.writeMessageBegin(new TMessage("alterTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.alterTag", result);
      }

    }

    private class dropTag implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropTag", server_ctx);
        dropTag_args args = new dropTag_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropTag");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropTag", args);
        dropTag_result result = new dropTag_result();
        result.success = iface_.dropTag(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropTag", result);
        oprot.writeMessageBegin(new TMessage("dropTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropTag", result);
      }

    }

    private class getTag implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getTag", server_ctx);
        getTag_args args = new getTag_args();
        event_handler_.preRead(handler_ctx, "MetaService.getTag");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getTag", args);
        getTag_result result = new getTag_result();
        result.success = iface_.getTag(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getTag", result);
        oprot.writeMessageBegin(new TMessage("getTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getTag", result);
      }

    }

    private class listTags implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listTags", server_ctx);
        listTags_args args = new listTags_args();
        event_handler_.preRead(handler_ctx, "MetaService.listTags");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listTags", args);
        listTags_result result = new listTags_result();
        result.success = iface_.listTags(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listTags", result);
        oprot.writeMessageBegin(new TMessage("listTags", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listTags", result);
      }

    }

    private class createEdge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createEdge", server_ctx);
        createEdge_args args = new createEdge_args();
        event_handler_.preRead(handler_ctx, "MetaService.createEdge");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createEdge", args);
        createEdge_result result = new createEdge_result();
        result.success = iface_.createEdge(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createEdge", result);
        oprot.writeMessageBegin(new TMessage("createEdge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createEdge", result);
      }

    }

    private class alterEdge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.alterEdge", server_ctx);
        alterEdge_args args = new alterEdge_args();
        event_handler_.preRead(handler_ctx, "MetaService.alterEdge");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.alterEdge", args);
        alterEdge_result result = new alterEdge_result();
        result.success = iface_.alterEdge(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.alterEdge", result);
        oprot.writeMessageBegin(new TMessage("alterEdge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.alterEdge", result);
      }

    }

    private class dropEdge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropEdge", server_ctx);
        dropEdge_args args = new dropEdge_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropEdge");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropEdge", args);
        dropEdge_result result = new dropEdge_result();
        result.success = iface_.dropEdge(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropEdge", result);
        oprot.writeMessageBegin(new TMessage("dropEdge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropEdge", result);
      }

    }

    private class getEdge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getEdge", server_ctx);
        getEdge_args args = new getEdge_args();
        event_handler_.preRead(handler_ctx, "MetaService.getEdge");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getEdge", args);
        getEdge_result result = new getEdge_result();
        result.success = iface_.getEdge(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getEdge", result);
        oprot.writeMessageBegin(new TMessage("getEdge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getEdge", result);
      }

    }

    private class listEdges implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listEdges", server_ctx);
        listEdges_args args = new listEdges_args();
        event_handler_.preRead(handler_ctx, "MetaService.listEdges");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listEdges", args);
        listEdges_result result = new listEdges_result();
        result.success = iface_.listEdges(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listEdges", result);
        oprot.writeMessageBegin(new TMessage("listEdges", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listEdges", result);
      }

    }

    private class addHosts implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.addHosts", server_ctx);
        addHosts_args args = new addHosts_args();
        event_handler_.preRead(handler_ctx, "MetaService.addHosts");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.addHosts", args);
        addHosts_result result = new addHosts_result();
        result.success = iface_.addHosts(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.addHosts", result);
        oprot.writeMessageBegin(new TMessage("addHosts", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.addHosts", result);
      }

    }

    private class addHostsIntoZone implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.addHostsIntoZone", server_ctx);
        addHostsIntoZone_args args = new addHostsIntoZone_args();
        event_handler_.preRead(handler_ctx, "MetaService.addHostsIntoZone");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.addHostsIntoZone", args);
        addHostsIntoZone_result result = new addHostsIntoZone_result();
        result.success = iface_.addHostsIntoZone(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.addHostsIntoZone", result);
        oprot.writeMessageBegin(new TMessage("addHostsIntoZone", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.addHostsIntoZone", result);
      }

    }

    private class dropHosts implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropHosts", server_ctx);
        dropHosts_args args = new dropHosts_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropHosts");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropHosts", args);
        dropHosts_result result = new dropHosts_result();
        result.success = iface_.dropHosts(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropHosts", result);
        oprot.writeMessageBegin(new TMessage("dropHosts", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropHosts", result);
      }

    }

    private class listHosts implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listHosts", server_ctx);
        listHosts_args args = new listHosts_args();
        event_handler_.preRead(handler_ctx, "MetaService.listHosts");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listHosts", args);
        listHosts_result result = new listHosts_result();
        result.success = iface_.listHosts(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listHosts", result);
        oprot.writeMessageBegin(new TMessage("listHosts", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listHosts", result);
      }

    }

    private class getPartsAlloc implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getPartsAlloc", server_ctx);
        getPartsAlloc_args args = new getPartsAlloc_args();
        event_handler_.preRead(handler_ctx, "MetaService.getPartsAlloc");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getPartsAlloc", args);
        getPartsAlloc_result result = new getPartsAlloc_result();
        result.success = iface_.getPartsAlloc(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getPartsAlloc", result);
        oprot.writeMessageBegin(new TMessage("getPartsAlloc", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getPartsAlloc", result);
      }

    }

    private class listParts implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listParts", server_ctx);
        listParts_args args = new listParts_args();
        event_handler_.preRead(handler_ctx, "MetaService.listParts");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listParts", args);
        listParts_result result = new listParts_result();
        result.success = iface_.listParts(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listParts", result);
        oprot.writeMessageBegin(new TMessage("listParts", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listParts", result);
      }

    }

    private class getWorkerId implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getWorkerId", server_ctx);
        getWorkerId_args args = new getWorkerId_args();
        event_handler_.preRead(handler_ctx, "MetaService.getWorkerId");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getWorkerId", args);
        getWorkerId_result result = new getWorkerId_result();
        result.success = iface_.getWorkerId(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getWorkerId", result);
        oprot.writeMessageBegin(new TMessage("getWorkerId", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getWorkerId", result);
      }

    }

    private class createTagIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createTagIndex", server_ctx);
        createTagIndex_args args = new createTagIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.createTagIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createTagIndex", args);
        createTagIndex_result result = new createTagIndex_result();
        result.success = iface_.createTagIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createTagIndex", result);
        oprot.writeMessageBegin(new TMessage("createTagIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createTagIndex", result);
      }

    }

    private class dropTagIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropTagIndex", server_ctx);
        dropTagIndex_args args = new dropTagIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropTagIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropTagIndex", args);
        dropTagIndex_result result = new dropTagIndex_result();
        result.success = iface_.dropTagIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropTagIndex", result);
        oprot.writeMessageBegin(new TMessage("dropTagIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropTagIndex", result);
      }

    }

    private class getTagIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getTagIndex", server_ctx);
        getTagIndex_args args = new getTagIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.getTagIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getTagIndex", args);
        getTagIndex_result result = new getTagIndex_result();
        result.success = iface_.getTagIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getTagIndex", result);
        oprot.writeMessageBegin(new TMessage("getTagIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getTagIndex", result);
      }

    }

    private class listTagIndexes implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listTagIndexes", server_ctx);
        listTagIndexes_args args = new listTagIndexes_args();
        event_handler_.preRead(handler_ctx, "MetaService.listTagIndexes");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listTagIndexes", args);
        listTagIndexes_result result = new listTagIndexes_result();
        result.success = iface_.listTagIndexes(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listTagIndexes", result);
        oprot.writeMessageBegin(new TMessage("listTagIndexes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listTagIndexes", result);
      }

    }

    private class rebuildTagIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.rebuildTagIndex", server_ctx);
        rebuildTagIndex_args args = new rebuildTagIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.rebuildTagIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.rebuildTagIndex", args);
        rebuildTagIndex_result result = new rebuildTagIndex_result();
        result.success = iface_.rebuildTagIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.rebuildTagIndex", result);
        oprot.writeMessageBegin(new TMessage("rebuildTagIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.rebuildTagIndex", result);
      }

    }

    private class listTagIndexStatus implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listTagIndexStatus", server_ctx);
        listTagIndexStatus_args args = new listTagIndexStatus_args();
        event_handler_.preRead(handler_ctx, "MetaService.listTagIndexStatus");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listTagIndexStatus", args);
        listTagIndexStatus_result result = new listTagIndexStatus_result();
        result.success = iface_.listTagIndexStatus(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listTagIndexStatus", result);
        oprot.writeMessageBegin(new TMessage("listTagIndexStatus", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listTagIndexStatus", result);
      }

    }

    private class createEdgeIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createEdgeIndex", server_ctx);
        createEdgeIndex_args args = new createEdgeIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.createEdgeIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createEdgeIndex", args);
        createEdgeIndex_result result = new createEdgeIndex_result();
        result.success = iface_.createEdgeIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createEdgeIndex", result);
        oprot.writeMessageBegin(new TMessage("createEdgeIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createEdgeIndex", result);
      }

    }

    private class dropEdgeIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropEdgeIndex", server_ctx);
        dropEdgeIndex_args args = new dropEdgeIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropEdgeIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropEdgeIndex", args);
        dropEdgeIndex_result result = new dropEdgeIndex_result();
        result.success = iface_.dropEdgeIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropEdgeIndex", result);
        oprot.writeMessageBegin(new TMessage("dropEdgeIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropEdgeIndex", result);
      }

    }

    private class getEdgeIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getEdgeIndex", server_ctx);
        getEdgeIndex_args args = new getEdgeIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.getEdgeIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getEdgeIndex", args);
        getEdgeIndex_result result = new getEdgeIndex_result();
        result.success = iface_.getEdgeIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getEdgeIndex", result);
        oprot.writeMessageBegin(new TMessage("getEdgeIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getEdgeIndex", result);
      }

    }

    private class listEdgeIndexes implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listEdgeIndexes", server_ctx);
        listEdgeIndexes_args args = new listEdgeIndexes_args();
        event_handler_.preRead(handler_ctx, "MetaService.listEdgeIndexes");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listEdgeIndexes", args);
        listEdgeIndexes_result result = new listEdgeIndexes_result();
        result.success = iface_.listEdgeIndexes(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listEdgeIndexes", result);
        oprot.writeMessageBegin(new TMessage("listEdgeIndexes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listEdgeIndexes", result);
      }

    }

    private class rebuildEdgeIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.rebuildEdgeIndex", server_ctx);
        rebuildEdgeIndex_args args = new rebuildEdgeIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.rebuildEdgeIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.rebuildEdgeIndex", args);
        rebuildEdgeIndex_result result = new rebuildEdgeIndex_result();
        result.success = iface_.rebuildEdgeIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.rebuildEdgeIndex", result);
        oprot.writeMessageBegin(new TMessage("rebuildEdgeIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.rebuildEdgeIndex", result);
      }

    }

    private class listEdgeIndexStatus implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listEdgeIndexStatus", server_ctx);
        listEdgeIndexStatus_args args = new listEdgeIndexStatus_args();
        event_handler_.preRead(handler_ctx, "MetaService.listEdgeIndexStatus");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listEdgeIndexStatus", args);
        listEdgeIndexStatus_result result = new listEdgeIndexStatus_result();
        result.success = iface_.listEdgeIndexStatus(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listEdgeIndexStatus", result);
        oprot.writeMessageBegin(new TMessage("listEdgeIndexStatus", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listEdgeIndexStatus", result);
      }

    }

    private class createUser implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createUser", server_ctx);
        createUser_args args = new createUser_args();
        event_handler_.preRead(handler_ctx, "MetaService.createUser");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createUser", args);
        createUser_result result = new createUser_result();
        result.success = iface_.createUser(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createUser", result);
        oprot.writeMessageBegin(new TMessage("createUser", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createUser", result);
      }

    }

    private class dropUser implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropUser", server_ctx);
        dropUser_args args = new dropUser_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropUser");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropUser", args);
        dropUser_result result = new dropUser_result();
        result.success = iface_.dropUser(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropUser", result);
        oprot.writeMessageBegin(new TMessage("dropUser", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropUser", result);
      }

    }

    private class alterUser implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.alterUser", server_ctx);
        alterUser_args args = new alterUser_args();
        event_handler_.preRead(handler_ctx, "MetaService.alterUser");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.alterUser", args);
        alterUser_result result = new alterUser_result();
        result.success = iface_.alterUser(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.alterUser", result);
        oprot.writeMessageBegin(new TMessage("alterUser", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.alterUser", result);
      }

    }

    private class grantRole implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.grantRole", server_ctx);
        grantRole_args args = new grantRole_args();
        event_handler_.preRead(handler_ctx, "MetaService.grantRole");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.grantRole", args);
        grantRole_result result = new grantRole_result();
        result.success = iface_.grantRole(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.grantRole", result);
        oprot.writeMessageBegin(new TMessage("grantRole", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.grantRole", result);
      }

    }

    private class revokeRole implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.revokeRole", server_ctx);
        revokeRole_args args = new revokeRole_args();
        event_handler_.preRead(handler_ctx, "MetaService.revokeRole");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.revokeRole", args);
        revokeRole_result result = new revokeRole_result();
        result.success = iface_.revokeRole(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.revokeRole", result);
        oprot.writeMessageBegin(new TMessage("revokeRole", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.revokeRole", result);
      }

    }

    private class listUsers implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listUsers", server_ctx);
        listUsers_args args = new listUsers_args();
        event_handler_.preRead(handler_ctx, "MetaService.listUsers");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listUsers", args);
        listUsers_result result = new listUsers_result();
        result.success = iface_.listUsers(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listUsers", result);
        oprot.writeMessageBegin(new TMessage("listUsers", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listUsers", result);
      }

    }

    private class listRoles implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listRoles", server_ctx);
        listRoles_args args = new listRoles_args();
        event_handler_.preRead(handler_ctx, "MetaService.listRoles");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listRoles", args);
        listRoles_result result = new listRoles_result();
        result.success = iface_.listRoles(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listRoles", result);
        oprot.writeMessageBegin(new TMessage("listRoles", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listRoles", result);
      }

    }

    private class getUserRoles implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getUserRoles", server_ctx);
        getUserRoles_args args = new getUserRoles_args();
        event_handler_.preRead(handler_ctx, "MetaService.getUserRoles");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getUserRoles", args);
        getUserRoles_result result = new getUserRoles_result();
        result.success = iface_.getUserRoles(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getUserRoles", result);
        oprot.writeMessageBegin(new TMessage("getUserRoles", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getUserRoles", result);
      }

    }

    private class changePassword implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.changePassword", server_ctx);
        changePassword_args args = new changePassword_args();
        event_handler_.preRead(handler_ctx, "MetaService.changePassword");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.changePassword", args);
        changePassword_result result = new changePassword_result();
        result.success = iface_.changePassword(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.changePassword", result);
        oprot.writeMessageBegin(new TMessage("changePassword", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.changePassword", result);
      }

    }

    private class heartBeat implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.heartBeat", server_ctx);
        heartBeat_args args = new heartBeat_args();
        event_handler_.preRead(handler_ctx, "MetaService.heartBeat");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.heartBeat", args);
        heartBeat_result result = new heartBeat_result();
        result.success = iface_.heartBeat(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.heartBeat", result);
        oprot.writeMessageBegin(new TMessage("heartBeat", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.heartBeat", result);
      }

    }

    private class agentHeartbeat implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.agentHeartbeat", server_ctx);
        agentHeartbeat_args args = new agentHeartbeat_args();
        event_handler_.preRead(handler_ctx, "MetaService.agentHeartbeat");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.agentHeartbeat", args);
        agentHeartbeat_result result = new agentHeartbeat_result();
        result.success = iface_.agentHeartbeat(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.agentHeartbeat", result);
        oprot.writeMessageBegin(new TMessage("agentHeartbeat", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.agentHeartbeat", result);
      }

    }

    private class regConfig implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.regConfig", server_ctx);
        regConfig_args args = new regConfig_args();
        event_handler_.preRead(handler_ctx, "MetaService.regConfig");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.regConfig", args);
        regConfig_result result = new regConfig_result();
        result.success = iface_.regConfig(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.regConfig", result);
        oprot.writeMessageBegin(new TMessage("regConfig", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.regConfig", result);
      }

    }

    private class getConfig implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getConfig", server_ctx);
        getConfig_args args = new getConfig_args();
        event_handler_.preRead(handler_ctx, "MetaService.getConfig");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getConfig", args);
        getConfig_result result = new getConfig_result();
        result.success = iface_.getConfig(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getConfig", result);
        oprot.writeMessageBegin(new TMessage("getConfig", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getConfig", result);
      }

    }

    private class setConfig implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.setConfig", server_ctx);
        setConfig_args args = new setConfig_args();
        event_handler_.preRead(handler_ctx, "MetaService.setConfig");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.setConfig", args);
        setConfig_result result = new setConfig_result();
        result.success = iface_.setConfig(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.setConfig", result);
        oprot.writeMessageBegin(new TMessage("setConfig", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.setConfig", result);
      }

    }

    private class listConfigs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listConfigs", server_ctx);
        listConfigs_args args = new listConfigs_args();
        event_handler_.preRead(handler_ctx, "MetaService.listConfigs");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listConfigs", args);
        listConfigs_result result = new listConfigs_result();
        result.success = iface_.listConfigs(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listConfigs", result);
        oprot.writeMessageBegin(new TMessage("listConfigs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listConfigs", result);
      }

    }

    private class createSnapshot implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createSnapshot", server_ctx);
        createSnapshot_args args = new createSnapshot_args();
        event_handler_.preRead(handler_ctx, "MetaService.createSnapshot");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createSnapshot", args);
        createSnapshot_result result = new createSnapshot_result();
        result.success = iface_.createSnapshot(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createSnapshot", result);
        oprot.writeMessageBegin(new TMessage("createSnapshot", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createSnapshot", result);
      }

    }

    private class dropSnapshot implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropSnapshot", server_ctx);
        dropSnapshot_args args = new dropSnapshot_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropSnapshot");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropSnapshot", args);
        dropSnapshot_result result = new dropSnapshot_result();
        result.success = iface_.dropSnapshot(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropSnapshot", result);
        oprot.writeMessageBegin(new TMessage("dropSnapshot", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropSnapshot", result);
      }

    }

    private class listSnapshots implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listSnapshots", server_ctx);
        listSnapshots_args args = new listSnapshots_args();
        event_handler_.preRead(handler_ctx, "MetaService.listSnapshots");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listSnapshots", args);
        listSnapshots_result result = new listSnapshots_result();
        result.success = iface_.listSnapshots(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listSnapshots", result);
        oprot.writeMessageBegin(new TMessage("listSnapshots", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listSnapshots", result);
      }

    }

    private class runAdminJob implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.runAdminJob", server_ctx);
        runAdminJob_args args = new runAdminJob_args();
        event_handler_.preRead(handler_ctx, "MetaService.runAdminJob");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.runAdminJob", args);
        runAdminJob_result result = new runAdminJob_result();
        result.success = iface_.runAdminJob(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.runAdminJob", result);
        oprot.writeMessageBegin(new TMessage("runAdminJob", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.runAdminJob", result);
      }

    }

    private class mergeZone implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.mergeZone", server_ctx);
        mergeZone_args args = new mergeZone_args();
        event_handler_.preRead(handler_ctx, "MetaService.mergeZone");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.mergeZone", args);
        mergeZone_result result = new mergeZone_result();
        result.success = iface_.mergeZone(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.mergeZone", result);
        oprot.writeMessageBegin(new TMessage("mergeZone", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.mergeZone", result);
      }

    }

    private class dropZone implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropZone", server_ctx);
        dropZone_args args = new dropZone_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropZone");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropZone", args);
        dropZone_result result = new dropZone_result();
        result.success = iface_.dropZone(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropZone", result);
        oprot.writeMessageBegin(new TMessage("dropZone", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropZone", result);
      }

    }

    private class divideZone implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.divideZone", server_ctx);
        divideZone_args args = new divideZone_args();
        event_handler_.preRead(handler_ctx, "MetaService.divideZone");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.divideZone", args);
        divideZone_result result = new divideZone_result();
        result.success = iface_.divideZone(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.divideZone", result);
        oprot.writeMessageBegin(new TMessage("divideZone", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.divideZone", result);
      }

    }

    private class renameZone implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.renameZone", server_ctx);
        renameZone_args args = new renameZone_args();
        event_handler_.preRead(handler_ctx, "MetaService.renameZone");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.renameZone", args);
        renameZone_result result = new renameZone_result();
        result.success = iface_.renameZone(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.renameZone", result);
        oprot.writeMessageBegin(new TMessage("renameZone", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.renameZone", result);
      }

    }

    private class getZone implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getZone", server_ctx);
        getZone_args args = new getZone_args();
        event_handler_.preRead(handler_ctx, "MetaService.getZone");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getZone", args);
        getZone_result result = new getZone_result();
        result.success = iface_.getZone(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getZone", result);
        oprot.writeMessageBegin(new TMessage("getZone", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getZone", result);
      }

    }

    private class listZones implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listZones", server_ctx);
        listZones_args args = new listZones_args();
        event_handler_.preRead(handler_ctx, "MetaService.listZones");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listZones", args);
        listZones_result result = new listZones_result();
        result.success = iface_.listZones(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listZones", result);
        oprot.writeMessageBegin(new TMessage("listZones", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listZones", result);
      }

    }

    private class addListener implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.addListener", server_ctx);
        addListener_args args = new addListener_args();
        event_handler_.preRead(handler_ctx, "MetaService.addListener");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.addListener", args);
        addListener_result result = new addListener_result();
        result.success = iface_.addListener(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.addListener", result);
        oprot.writeMessageBegin(new TMessage("addListener", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.addListener", result);
      }

    }

    private class removeListener implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.removeListener", server_ctx);
        removeListener_args args = new removeListener_args();
        event_handler_.preRead(handler_ctx, "MetaService.removeListener");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.removeListener", args);
        removeListener_result result = new removeListener_result();
        result.success = iface_.removeListener(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.removeListener", result);
        oprot.writeMessageBegin(new TMessage("removeListener", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.removeListener", result);
      }

    }

    private class listListener implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listListener", server_ctx);
        listListener_args args = new listListener_args();
        event_handler_.preRead(handler_ctx, "MetaService.listListener");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listListener", args);
        listListener_result result = new listListener_result();
        result.success = iface_.listListener(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listListener", result);
        oprot.writeMessageBegin(new TMessage("listListener", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listListener", result);
      }

    }

    private class getStats implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getStats", server_ctx);
        getStats_args args = new getStats_args();
        event_handler_.preRead(handler_ctx, "MetaService.getStats");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getStats", args);
        getStats_result result = new getStats_result();
        result.success = iface_.getStats(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getStats", result);
        oprot.writeMessageBegin(new TMessage("getStats", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getStats", result);
      }

    }

    private class signInService implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.signInService", server_ctx);
        signInService_args args = new signInService_args();
        event_handler_.preRead(handler_ctx, "MetaService.signInService");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.signInService", args);
        signInService_result result = new signInService_result();
        result.success = iface_.signInService(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.signInService", result);
        oprot.writeMessageBegin(new TMessage("signInService", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.signInService", result);
      }

    }

    private class signOutService implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.signOutService", server_ctx);
        signOutService_args args = new signOutService_args();
        event_handler_.preRead(handler_ctx, "MetaService.signOutService");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.signOutService", args);
        signOutService_result result = new signOutService_result();
        result.success = iface_.signOutService(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.signOutService", result);
        oprot.writeMessageBegin(new TMessage("signOutService", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.signOutService", result);
      }

    }

    private class listServiceClients implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listServiceClients", server_ctx);
        listServiceClients_args args = new listServiceClients_args();
        event_handler_.preRead(handler_ctx, "MetaService.listServiceClients");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listServiceClients", args);
        listServiceClients_result result = new listServiceClients_result();
        result.success = iface_.listServiceClients(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listServiceClients", result);
        oprot.writeMessageBegin(new TMessage("listServiceClients", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listServiceClients", result);
      }

    }

    private class createFTIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createFTIndex", server_ctx);
        createFTIndex_args args = new createFTIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.createFTIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createFTIndex", args);
        createFTIndex_result result = new createFTIndex_result();
        result.success = iface_.createFTIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createFTIndex", result);
        oprot.writeMessageBegin(new TMessage("createFTIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createFTIndex", result);
      }

    }

    private class dropFTIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropFTIndex", server_ctx);
        dropFTIndex_args args = new dropFTIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropFTIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropFTIndex", args);
        dropFTIndex_result result = new dropFTIndex_result();
        result.success = iface_.dropFTIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropFTIndex", result);
        oprot.writeMessageBegin(new TMessage("dropFTIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropFTIndex", result);
      }

    }

    private class listFTIndexes implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listFTIndexes", server_ctx);
        listFTIndexes_args args = new listFTIndexes_args();
        event_handler_.preRead(handler_ctx, "MetaService.listFTIndexes");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listFTIndexes", args);
        listFTIndexes_result result = new listFTIndexes_result();
        result.success = iface_.listFTIndexes(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listFTIndexes", result);
        oprot.writeMessageBegin(new TMessage("listFTIndexes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listFTIndexes", result);
      }

    }

    private class createSession implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createSession", server_ctx);
        createSession_args args = new createSession_args();
        event_handler_.preRead(handler_ctx, "MetaService.createSession");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createSession", args);
        createSession_result result = new createSession_result();
        result.success = iface_.createSession(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createSession", result);
        oprot.writeMessageBegin(new TMessage("createSession", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createSession", result);
      }

    }

    private class updateSessions implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.updateSessions", server_ctx);
        updateSessions_args args = new updateSessions_args();
        event_handler_.preRead(handler_ctx, "MetaService.updateSessions");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.updateSessions", args);
        updateSessions_result result = new updateSessions_result();
        result.success = iface_.updateSessions(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.updateSessions", result);
        oprot.writeMessageBegin(new TMessage("updateSessions", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.updateSessions", result);
      }

    }

    private class listSessions implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listSessions", server_ctx);
        listSessions_args args = new listSessions_args();
        event_handler_.preRead(handler_ctx, "MetaService.listSessions");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listSessions", args);
        listSessions_result result = new listSessions_result();
        result.success = iface_.listSessions(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listSessions", result);
        oprot.writeMessageBegin(new TMessage("listSessions", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listSessions", result);
      }

    }

    private class getSession implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getSession", server_ctx);
        getSession_args args = new getSession_args();
        event_handler_.preRead(handler_ctx, "MetaService.getSession");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getSession", args);
        getSession_result result = new getSession_result();
        result.success = iface_.getSession(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getSession", result);
        oprot.writeMessageBegin(new TMessage("getSession", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getSession", result);
      }

    }

    private class removeSession implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.removeSession", server_ctx);
        removeSession_args args = new removeSession_args();
        event_handler_.preRead(handler_ctx, "MetaService.removeSession");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.removeSession", args);
        removeSession_result result = new removeSession_result();
        result.success = iface_.removeSession(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.removeSession", result);
        oprot.writeMessageBegin(new TMessage("removeSession", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.removeSession", result);
      }

    }

    private class killQuery implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.killQuery", server_ctx);
        killQuery_args args = new killQuery_args();
        event_handler_.preRead(handler_ctx, "MetaService.killQuery");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.killQuery", args);
        killQuery_result result = new killQuery_result();
        result.success = iface_.killQuery(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.killQuery", result);
        oprot.writeMessageBegin(new TMessage("killQuery", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.killQuery", result);
      }

    }

    private class reportTaskFinish implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.reportTaskFinish", server_ctx);
        reportTaskFinish_args args = new reportTaskFinish_args();
        event_handler_.preRead(handler_ctx, "MetaService.reportTaskFinish");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.reportTaskFinish", args);
        reportTaskFinish_result result = new reportTaskFinish_result();
        result.success = iface_.reportTaskFinish(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.reportTaskFinish", result);
        oprot.writeMessageBegin(new TMessage("reportTaskFinish", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.reportTaskFinish", result);
      }

    }

    private class createBackup implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createBackup", server_ctx);
        createBackup_args args = new createBackup_args();
        event_handler_.preRead(handler_ctx, "MetaService.createBackup");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createBackup", args);
        createBackup_result result = new createBackup_result();
        result.success = iface_.createBackup(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createBackup", result);
        oprot.writeMessageBegin(new TMessage("createBackup", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createBackup", result);
      }

    }

    private class restoreMeta implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.restoreMeta", server_ctx);
        restoreMeta_args args = new restoreMeta_args();
        event_handler_.preRead(handler_ctx, "MetaService.restoreMeta");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.restoreMeta", args);
        restoreMeta_result result = new restoreMeta_result();
        result.success = iface_.restoreMeta(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.restoreMeta", result);
        oprot.writeMessageBegin(new TMessage("restoreMeta", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.restoreMeta", result);
      }

    }

    private class listCluster implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listCluster", server_ctx);
        listCluster_args args = new listCluster_args();
        event_handler_.preRead(handler_ctx, "MetaService.listCluster");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listCluster", args);
        listCluster_result result = new listCluster_result();
        result.success = iface_.listCluster(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listCluster", result);
        oprot.writeMessageBegin(new TMessage("listCluster", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listCluster", result);
      }

    }

    private class getMetaDirInfo implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getMetaDirInfo", server_ctx);
        getMetaDirInfo_args args = new getMetaDirInfo_args();
        event_handler_.preRead(handler_ctx, "MetaService.getMetaDirInfo");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getMetaDirInfo", args);
        getMetaDirInfo_result result = new getMetaDirInfo_result();
        result.success = iface_.getMetaDirInfo(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getMetaDirInfo", result);
        oprot.writeMessageBegin(new TMessage("getMetaDirInfo", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getMetaDirInfo", result);
      }

    }

    private class verifyClientVersion implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.verifyClientVersion", server_ctx);
        verifyClientVersion_args args = new verifyClientVersion_args();
        event_handler_.preRead(handler_ctx, "MetaService.verifyClientVersion");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.verifyClientVersion", args);
        verifyClientVersion_result result = new verifyClientVersion_result();
        result.success = iface_.verifyClientVersion(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.verifyClientVersion", result);
        oprot.writeMessageBegin(new TMessage("verifyClientVersion", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.verifyClientVersion", result);
      }

    }

    private class saveGraphVersion implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.saveGraphVersion", server_ctx);
        saveGraphVersion_args args = new saveGraphVersion_args();
        event_handler_.preRead(handler_ctx, "MetaService.saveGraphVersion");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.saveGraphVersion", args);
        saveGraphVersion_result result = new saveGraphVersion_result();
        result.success = iface_.saveGraphVersion(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.saveGraphVersion", result);
        oprot.writeMessageBegin(new TMessage("saveGraphVersion", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.saveGraphVersion", result);
      }

    }

    private class getSegmentId implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getSegmentId", server_ctx);
        getSegmentId_args args = new getSegmentId_args();
        event_handler_.preRead(handler_ctx, "MetaService.getSegmentId");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getSegmentId", args);
        getSegmentId_result result = new getSegmentId_result();
        result.success = iface_.getSegmentId(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getSegmentId", result);
        oprot.writeMessageBegin(new TMessage("getSegmentId", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getSegmentId", result);
      }

    }

  }

  public static class createSpace_args implements TBase, java.io.Serializable, Cloneable, Comparable<createSpace_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSpace_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateSpaceReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateSpaceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSpace_args.class, metaDataMap);
    }

    public createSpace_args() {
    }

    public createSpace_args(
        CreateSpaceReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSpace_args(createSpace_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createSpace_args deepCopy() {
      return new createSpace_args(this);
    }

    public CreateSpaceReq getReq() {
      return this.req;
    }

    public createSpace_args setReq(CreateSpaceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateSpaceReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createSpace_args))
        return false;
      createSpace_args that = (createSpace_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createSpace_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateSpaceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSpace_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createSpace_result implements TBase, java.io.Serializable, Cloneable, Comparable<createSpace_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSpace_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSpace_result.class, metaDataMap);
    }

    public createSpace_result() {
    }

    public createSpace_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSpace_result(createSpace_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createSpace_result deepCopy() {
      return new createSpace_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public createSpace_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createSpace_result))
        return false;
      createSpace_result that = (createSpace_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createSpace_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSpace_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropSpace_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropSpace_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropSpace_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropSpaceReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropSpaceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropSpace_args.class, metaDataMap);
    }

    public dropSpace_args() {
    }

    public dropSpace_args(
        DropSpaceReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropSpace_args(dropSpace_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropSpace_args deepCopy() {
      return new dropSpace_args(this);
    }

    public DropSpaceReq getReq() {
      return this.req;
    }

    public dropSpace_args setReq(DropSpaceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropSpaceReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropSpace_args))
        return false;
      dropSpace_args that = (dropSpace_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropSpace_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropSpaceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropSpace_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropSpace_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropSpace_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropSpace_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropSpace_result.class, metaDataMap);
    }

    public dropSpace_result() {
    }

    public dropSpace_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropSpace_result(dropSpace_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropSpace_result deepCopy() {
      return new dropSpace_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropSpace_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropSpace_result))
        return false;
      dropSpace_result that = (dropSpace_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropSpace_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropSpace_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class clearSpace_args implements TBase, java.io.Serializable, Cloneable, Comparable<clearSpace_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("clearSpace_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ClearSpaceReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ClearSpaceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(clearSpace_args.class, metaDataMap);
    }

    public clearSpace_args() {
    }

    public clearSpace_args(
        ClearSpaceReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public clearSpace_args(clearSpace_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public clearSpace_args deepCopy() {
      return new clearSpace_args(this);
    }

    public ClearSpaceReq getReq() {
      return this.req;
    }

    public clearSpace_args setReq(ClearSpaceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ClearSpaceReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof clearSpace_args))
        return false;
      clearSpace_args that = (clearSpace_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(clearSpace_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ClearSpaceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("clearSpace_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class clearSpace_result implements TBase, java.io.Serializable, Cloneable, Comparable<clearSpace_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("clearSpace_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(clearSpace_result.class, metaDataMap);
    }

    public clearSpace_result() {
    }

    public clearSpace_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public clearSpace_result(clearSpace_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public clearSpace_result deepCopy() {
      return new clearSpace_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public clearSpace_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof clearSpace_result))
        return false;
      clearSpace_result that = (clearSpace_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(clearSpace_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("clearSpace_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getSpace_args implements TBase, java.io.Serializable, Cloneable, Comparable<getSpace_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getSpace_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetSpaceReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetSpaceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getSpace_args.class, metaDataMap);
    }

    public getSpace_args() {
    }

    public getSpace_args(
        GetSpaceReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getSpace_args(getSpace_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getSpace_args deepCopy() {
      return new getSpace_args(this);
    }

    public GetSpaceReq getReq() {
      return this.req;
    }

    public getSpace_args setReq(GetSpaceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetSpaceReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getSpace_args))
        return false;
      getSpace_args that = (getSpace_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getSpace_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetSpaceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getSpace_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getSpace_result implements TBase, java.io.Serializable, Cloneable, Comparable<getSpace_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getSpace_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetSpaceResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetSpaceResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getSpace_result.class, metaDataMap);
    }

    public getSpace_result() {
    }

    public getSpace_result(
        GetSpaceResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getSpace_result(getSpace_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getSpace_result deepCopy() {
      return new getSpace_result(this);
    }

    public GetSpaceResp getSuccess() {
      return this.success;
    }

    public getSpace_result setSuccess(GetSpaceResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetSpaceResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getSpace_result))
        return false;
      getSpace_result that = (getSpace_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getSpace_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetSpaceResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getSpace_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listSpaces_args implements TBase, java.io.Serializable, Cloneable, Comparable<listSpaces_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSpaces_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListSpacesReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSpacesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSpaces_args.class, metaDataMap);
    }

    public listSpaces_args() {
    }

    public listSpaces_args(
        ListSpacesReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSpaces_args(listSpaces_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listSpaces_args deepCopy() {
      return new listSpaces_args(this);
    }

    public ListSpacesReq getReq() {
      return this.req;
    }

    public listSpaces_args setReq(ListSpacesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListSpacesReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listSpaces_args))
        return false;
      listSpaces_args that = (listSpaces_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listSpaces_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListSpacesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSpaces_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listSpaces_result implements TBase, java.io.Serializable, Cloneable, Comparable<listSpaces_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSpaces_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListSpacesResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSpacesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSpaces_result.class, metaDataMap);
    }

    public listSpaces_result() {
    }

    public listSpaces_result(
        ListSpacesResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSpaces_result(listSpaces_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listSpaces_result deepCopy() {
      return new listSpaces_result(this);
    }

    public ListSpacesResp getSuccess() {
      return this.success;
    }

    public listSpaces_result setSuccess(ListSpacesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListSpacesResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listSpaces_result))
        return false;
      listSpaces_result that = (listSpaces_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listSpaces_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListSpacesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSpaces_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alterSpace_args implements TBase, java.io.Serializable, Cloneable, Comparable<alterSpace_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterSpace_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AlterSpaceReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AlterSpaceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterSpace_args.class, metaDataMap);
    }

    public alterSpace_args() {
    }

    public alterSpace_args(
        AlterSpaceReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterSpace_args(alterSpace_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public alterSpace_args deepCopy() {
      return new alterSpace_args(this);
    }

    public AlterSpaceReq getReq() {
      return this.req;
    }

    public alterSpace_args setReq(AlterSpaceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AlterSpaceReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof alterSpace_args))
        return false;
      alterSpace_args that = (alterSpace_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(alterSpace_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AlterSpaceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterSpace_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alterSpace_result implements TBase, java.io.Serializable, Cloneable, Comparable<alterSpace_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterSpace_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterSpace_result.class, metaDataMap);
    }

    public alterSpace_result() {
    }

    public alterSpace_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterSpace_result(alterSpace_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public alterSpace_result deepCopy() {
      return new alterSpace_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public alterSpace_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof alterSpace_result))
        return false;
      alterSpace_result that = (alterSpace_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(alterSpace_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterSpace_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createSpaceAs_args implements TBase, java.io.Serializable, Cloneable, Comparable<createSpaceAs_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSpaceAs_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateSpaceAsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateSpaceAsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSpaceAs_args.class, metaDataMap);
    }

    public createSpaceAs_args() {
    }

    public createSpaceAs_args(
        CreateSpaceAsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSpaceAs_args(createSpaceAs_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createSpaceAs_args deepCopy() {
      return new createSpaceAs_args(this);
    }

    public CreateSpaceAsReq getReq() {
      return this.req;
    }

    public createSpaceAs_args setReq(CreateSpaceAsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateSpaceAsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createSpaceAs_args))
        return false;
      createSpaceAs_args that = (createSpaceAs_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createSpaceAs_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateSpaceAsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSpaceAs_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createSpaceAs_result implements TBase, java.io.Serializable, Cloneable, Comparable<createSpaceAs_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSpaceAs_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSpaceAs_result.class, metaDataMap);
    }

    public createSpaceAs_result() {
    }

    public createSpaceAs_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSpaceAs_result(createSpaceAs_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createSpaceAs_result deepCopy() {
      return new createSpaceAs_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public createSpaceAs_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createSpaceAs_result))
        return false;
      createSpaceAs_result that = (createSpaceAs_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createSpaceAs_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSpaceAs_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createTag_args implements TBase, java.io.Serializable, Cloneable, Comparable<createTag_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createTag_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateTagReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateTagReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createTag_args.class, metaDataMap);
    }

    public createTag_args() {
    }

    public createTag_args(
        CreateTagReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTag_args(createTag_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createTag_args deepCopy() {
      return new createTag_args(this);
    }

    public CreateTagReq getReq() {
      return this.req;
    }

    public createTag_args setReq(CreateTagReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateTagReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createTag_args))
        return false;
      createTag_args that = (createTag_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createTag_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateTagReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createTag_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createTag_result implements TBase, java.io.Serializable, Cloneable, Comparable<createTag_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createTag_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createTag_result.class, metaDataMap);
    }

    public createTag_result() {
    }

    public createTag_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTag_result(createTag_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createTag_result deepCopy() {
      return new createTag_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public createTag_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createTag_result))
        return false;
      createTag_result that = (createTag_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createTag_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createTag_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alterTag_args implements TBase, java.io.Serializable, Cloneable, Comparable<alterTag_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterTag_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AlterTagReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AlterTagReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterTag_args.class, metaDataMap);
    }

    public alterTag_args() {
    }

    public alterTag_args(
        AlterTagReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterTag_args(alterTag_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public alterTag_args deepCopy() {
      return new alterTag_args(this);
    }

    public AlterTagReq getReq() {
      return this.req;
    }

    public alterTag_args setReq(AlterTagReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AlterTagReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof alterTag_args))
        return false;
      alterTag_args that = (alterTag_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(alterTag_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AlterTagReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterTag_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alterTag_result implements TBase, java.io.Serializable, Cloneable, Comparable<alterTag_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterTag_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterTag_result.class, metaDataMap);
    }

    public alterTag_result() {
    }

    public alterTag_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterTag_result(alterTag_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public alterTag_result deepCopy() {
      return new alterTag_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public alterTag_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof alterTag_result))
        return false;
      alterTag_result that = (alterTag_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(alterTag_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterTag_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropTag_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropTag_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTag_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropTagReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropTagReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropTag_args.class, metaDataMap);
    }

    public dropTag_args() {
    }

    public dropTag_args(
        DropTagReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTag_args(dropTag_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropTag_args deepCopy() {
      return new dropTag_args(this);
    }

    public DropTagReq getReq() {
      return this.req;
    }

    public dropTag_args setReq(DropTagReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropTagReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropTag_args))
        return false;
      dropTag_args that = (dropTag_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropTag_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropTagReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropTag_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropTag_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropTag_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTag_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropTag_result.class, metaDataMap);
    }

    public dropTag_result() {
    }

    public dropTag_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTag_result(dropTag_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropTag_result deepCopy() {
      return new dropTag_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropTag_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropTag_result))
        return false;
      dropTag_result that = (dropTag_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropTag_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropTag_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTag_args implements TBase, java.io.Serializable, Cloneable, Comparable<getTag_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getTag_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetTagReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetTagReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getTag_args.class, metaDataMap);
    }

    public getTag_args() {
    }

    public getTag_args(
        GetTagReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTag_args(getTag_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getTag_args deepCopy() {
      return new getTag_args(this);
    }

    public GetTagReq getReq() {
      return this.req;
    }

    public getTag_args setReq(GetTagReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetTagReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getTag_args))
        return false;
      getTag_args that = (getTag_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getTag_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetTagReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getTag_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTag_result implements TBase, java.io.Serializable, Cloneable, Comparable<getTag_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getTag_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetTagResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetTagResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getTag_result.class, metaDataMap);
    }

    public getTag_result() {
    }

    public getTag_result(
        GetTagResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTag_result(getTag_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getTag_result deepCopy() {
      return new getTag_result(this);
    }

    public GetTagResp getSuccess() {
      return this.success;
    }

    public getTag_result setSuccess(GetTagResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetTagResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getTag_result))
        return false;
      getTag_result that = (getTag_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getTag_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetTagResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getTag_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listTags_args implements TBase, java.io.Serializable, Cloneable, Comparable<listTags_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTags_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListTagsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListTagsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTags_args.class, metaDataMap);
    }

    public listTags_args() {
    }

    public listTags_args(
        ListTagsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTags_args(listTags_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listTags_args deepCopy() {
      return new listTags_args(this);
    }

    public ListTagsReq getReq() {
      return this.req;
    }

    public listTags_args setReq(ListTagsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListTagsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listTags_args))
        return false;
      listTags_args that = (listTags_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listTags_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListTagsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTags_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listTags_result implements TBase, java.io.Serializable, Cloneable, Comparable<listTags_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTags_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListTagsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListTagsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTags_result.class, metaDataMap);
    }

    public listTags_result() {
    }

    public listTags_result(
        ListTagsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTags_result(listTags_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listTags_result deepCopy() {
      return new listTags_result(this);
    }

    public ListTagsResp getSuccess() {
      return this.success;
    }

    public listTags_result setSuccess(ListTagsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListTagsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listTags_result))
        return false;
      listTags_result that = (listTags_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listTags_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListTagsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTags_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createEdge_args implements TBase, java.io.Serializable, Cloneable, Comparable<createEdge_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createEdge_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateEdgeReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateEdgeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createEdge_args.class, metaDataMap);
    }

    public createEdge_args() {
    }

    public createEdge_args(
        CreateEdgeReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createEdge_args(createEdge_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createEdge_args deepCopy() {
      return new createEdge_args(this);
    }

    public CreateEdgeReq getReq() {
      return this.req;
    }

    public createEdge_args setReq(CreateEdgeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateEdgeReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createEdge_args))
        return false;
      createEdge_args that = (createEdge_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createEdge_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateEdgeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createEdge_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createEdge_result implements TBase, java.io.Serializable, Cloneable, Comparable<createEdge_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createEdge_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createEdge_result.class, metaDataMap);
    }

    public createEdge_result() {
    }

    public createEdge_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createEdge_result(createEdge_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createEdge_result deepCopy() {
      return new createEdge_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public createEdge_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createEdge_result))
        return false;
      createEdge_result that = (createEdge_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createEdge_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createEdge_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alterEdge_args implements TBase, java.io.Serializable, Cloneable, Comparable<alterEdge_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterEdge_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AlterEdgeReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AlterEdgeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterEdge_args.class, metaDataMap);
    }

    public alterEdge_args() {
    }

    public alterEdge_args(
        AlterEdgeReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterEdge_args(alterEdge_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public alterEdge_args deepCopy() {
      return new alterEdge_args(this);
    }

    public AlterEdgeReq getReq() {
      return this.req;
    }

    public alterEdge_args setReq(AlterEdgeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AlterEdgeReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof alterEdge_args))
        return false;
      alterEdge_args that = (alterEdge_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(alterEdge_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AlterEdgeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterEdge_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alterEdge_result implements TBase, java.io.Serializable, Cloneable, Comparable<alterEdge_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterEdge_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterEdge_result.class, metaDataMap);
    }

    public alterEdge_result() {
    }

    public alterEdge_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterEdge_result(alterEdge_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public alterEdge_result deepCopy() {
      return new alterEdge_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public alterEdge_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof alterEdge_result))
        return false;
      alterEdge_result that = (alterEdge_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(alterEdge_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterEdge_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropEdge_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropEdge_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropEdge_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropEdgeReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropEdgeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropEdge_args.class, metaDataMap);
    }

    public dropEdge_args() {
    }

    public dropEdge_args(
        DropEdgeReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropEdge_args(dropEdge_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropEdge_args deepCopy() {
      return new dropEdge_args(this);
    }

    public DropEdgeReq getReq() {
      return this.req;
    }

    public dropEdge_args setReq(DropEdgeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropEdgeReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropEdge_args))
        return false;
      dropEdge_args that = (dropEdge_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropEdge_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropEdgeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropEdge_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropEdge_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropEdge_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropEdge_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropEdge_result.class, metaDataMap);
    }

    public dropEdge_result() {
    }

    public dropEdge_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropEdge_result(dropEdge_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropEdge_result deepCopy() {
      return new dropEdge_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropEdge_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropEdge_result))
        return false;
      dropEdge_result that = (dropEdge_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropEdge_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropEdge_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getEdge_args implements TBase, java.io.Serializable, Cloneable, Comparable<getEdge_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getEdge_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetEdgeReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetEdgeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getEdge_args.class, metaDataMap);
    }

    public getEdge_args() {
    }

    public getEdge_args(
        GetEdgeReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEdge_args(getEdge_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getEdge_args deepCopy() {
      return new getEdge_args(this);
    }

    public GetEdgeReq getReq() {
      return this.req;
    }

    public getEdge_args setReq(GetEdgeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetEdgeReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getEdge_args))
        return false;
      getEdge_args that = (getEdge_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getEdge_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetEdgeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getEdge_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getEdge_result implements TBase, java.io.Serializable, Cloneable, Comparable<getEdge_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getEdge_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetEdgeResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetEdgeResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getEdge_result.class, metaDataMap);
    }

    public getEdge_result() {
    }

    public getEdge_result(
        GetEdgeResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEdge_result(getEdge_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getEdge_result deepCopy() {
      return new getEdge_result(this);
    }

    public GetEdgeResp getSuccess() {
      return this.success;
    }

    public getEdge_result setSuccess(GetEdgeResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetEdgeResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getEdge_result))
        return false;
      getEdge_result that = (getEdge_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getEdge_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetEdgeResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getEdge_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listEdges_args implements TBase, java.io.Serializable, Cloneable, Comparable<listEdges_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdges_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListEdgesReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListEdgesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdges_args.class, metaDataMap);
    }

    public listEdges_args() {
    }

    public listEdges_args(
        ListEdgesReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdges_args(listEdges_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listEdges_args deepCopy() {
      return new listEdges_args(this);
    }

    public ListEdgesReq getReq() {
      return this.req;
    }

    public listEdges_args setReq(ListEdgesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListEdgesReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listEdges_args))
        return false;
      listEdges_args that = (listEdges_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listEdges_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListEdgesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdges_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listEdges_result implements TBase, java.io.Serializable, Cloneable, Comparable<listEdges_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdges_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListEdgesResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListEdgesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdges_result.class, metaDataMap);
    }

    public listEdges_result() {
    }

    public listEdges_result(
        ListEdgesResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdges_result(listEdges_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listEdges_result deepCopy() {
      return new listEdges_result(this);
    }

    public ListEdgesResp getSuccess() {
      return this.success;
    }

    public listEdges_result setSuccess(ListEdgesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListEdgesResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listEdges_result))
        return false;
      listEdges_result that = (listEdges_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listEdges_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListEdgesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdges_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addHosts_args implements TBase, java.io.Serializable, Cloneable, Comparable<addHosts_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("addHosts_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AddHostsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AddHostsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(addHosts_args.class, metaDataMap);
    }

    public addHosts_args() {
    }

    public addHosts_args(
        AddHostsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addHosts_args(addHosts_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public addHosts_args deepCopy() {
      return new addHosts_args(this);
    }

    public AddHostsReq getReq() {
      return this.req;
    }

    public addHosts_args setReq(AddHostsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AddHostsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof addHosts_args))
        return false;
      addHosts_args that = (addHosts_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(addHosts_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AddHostsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("addHosts_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addHosts_result implements TBase, java.io.Serializable, Cloneable, Comparable<addHosts_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("addHosts_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(addHosts_result.class, metaDataMap);
    }

    public addHosts_result() {
    }

    public addHosts_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addHosts_result(addHosts_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public addHosts_result deepCopy() {
      return new addHosts_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public addHosts_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof addHosts_result))
        return false;
      addHosts_result that = (addHosts_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(addHosts_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("addHosts_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addHostsIntoZone_args implements TBase, java.io.Serializable, Cloneable, Comparable<addHostsIntoZone_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("addHostsIntoZone_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AddHostsIntoZoneReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AddHostsIntoZoneReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(addHostsIntoZone_args.class, metaDataMap);
    }

    public addHostsIntoZone_args() {
    }

    public addHostsIntoZone_args(
        AddHostsIntoZoneReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addHostsIntoZone_args(addHostsIntoZone_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public addHostsIntoZone_args deepCopy() {
      return new addHostsIntoZone_args(this);
    }

    public AddHostsIntoZoneReq getReq() {
      return this.req;
    }

    public addHostsIntoZone_args setReq(AddHostsIntoZoneReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AddHostsIntoZoneReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof addHostsIntoZone_args))
        return false;
      addHostsIntoZone_args that = (addHostsIntoZone_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(addHostsIntoZone_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AddHostsIntoZoneReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("addHostsIntoZone_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addHostsIntoZone_result implements TBase, java.io.Serializable, Cloneable, Comparable<addHostsIntoZone_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("addHostsIntoZone_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(addHostsIntoZone_result.class, metaDataMap);
    }

    public addHostsIntoZone_result() {
    }

    public addHostsIntoZone_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addHostsIntoZone_result(addHostsIntoZone_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public addHostsIntoZone_result deepCopy() {
      return new addHostsIntoZone_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public addHostsIntoZone_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof addHostsIntoZone_result))
        return false;
      addHostsIntoZone_result that = (addHostsIntoZone_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(addHostsIntoZone_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("addHostsIntoZone_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropHosts_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropHosts_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropHosts_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropHostsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropHostsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropHosts_args.class, metaDataMap);
    }

    public dropHosts_args() {
    }

    public dropHosts_args(
        DropHostsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropHosts_args(dropHosts_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropHosts_args deepCopy() {
      return new dropHosts_args(this);
    }

    public DropHostsReq getReq() {
      return this.req;
    }

    public dropHosts_args setReq(DropHostsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropHostsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropHosts_args))
        return false;
      dropHosts_args that = (dropHosts_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropHosts_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropHostsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropHosts_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropHosts_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropHosts_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropHosts_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropHosts_result.class, metaDataMap);
    }

    public dropHosts_result() {
    }

    public dropHosts_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropHosts_result(dropHosts_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropHosts_result deepCopy() {
      return new dropHosts_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropHosts_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropHosts_result))
        return false;
      dropHosts_result that = (dropHosts_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropHosts_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropHosts_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listHosts_args implements TBase, java.io.Serializable, Cloneable, Comparable<listHosts_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listHosts_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListHostsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListHostsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listHosts_args.class, metaDataMap);
    }

    public listHosts_args() {
    }

    public listHosts_args(
        ListHostsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listHosts_args(listHosts_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listHosts_args deepCopy() {
      return new listHosts_args(this);
    }

    public ListHostsReq getReq() {
      return this.req;
    }

    public listHosts_args setReq(ListHostsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListHostsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listHosts_args))
        return false;
      listHosts_args that = (listHosts_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listHosts_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListHostsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listHosts_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listHosts_result implements TBase, java.io.Serializable, Cloneable, Comparable<listHosts_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listHosts_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListHostsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListHostsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listHosts_result.class, metaDataMap);
    }

    public listHosts_result() {
    }

    public listHosts_result(
        ListHostsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listHosts_result(listHosts_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listHosts_result deepCopy() {
      return new listHosts_result(this);
    }

    public ListHostsResp getSuccess() {
      return this.success;
    }

    public listHosts_result setSuccess(ListHostsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListHostsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listHosts_result))
        return false;
      listHosts_result that = (listHosts_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listHosts_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListHostsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listHosts_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getPartsAlloc_args implements TBase, java.io.Serializable, Cloneable, Comparable<getPartsAlloc_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getPartsAlloc_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetPartsAllocReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetPartsAllocReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getPartsAlloc_args.class, metaDataMap);
    }

    public getPartsAlloc_args() {
    }

    public getPartsAlloc_args(
        GetPartsAllocReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPartsAlloc_args(getPartsAlloc_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getPartsAlloc_args deepCopy() {
      return new getPartsAlloc_args(this);
    }

    public GetPartsAllocReq getReq() {
      return this.req;
    }

    public getPartsAlloc_args setReq(GetPartsAllocReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetPartsAllocReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getPartsAlloc_args))
        return false;
      getPartsAlloc_args that = (getPartsAlloc_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getPartsAlloc_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetPartsAllocReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getPartsAlloc_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getPartsAlloc_result implements TBase, java.io.Serializable, Cloneable, Comparable<getPartsAlloc_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getPartsAlloc_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetPartsAllocResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetPartsAllocResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getPartsAlloc_result.class, metaDataMap);
    }

    public getPartsAlloc_result() {
    }

    public getPartsAlloc_result(
        GetPartsAllocResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPartsAlloc_result(getPartsAlloc_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getPartsAlloc_result deepCopy() {
      return new getPartsAlloc_result(this);
    }

    public GetPartsAllocResp getSuccess() {
      return this.success;
    }

    public getPartsAlloc_result setSuccess(GetPartsAllocResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetPartsAllocResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getPartsAlloc_result))
        return false;
      getPartsAlloc_result that = (getPartsAlloc_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getPartsAlloc_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetPartsAllocResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getPartsAlloc_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listParts_args implements TBase, java.io.Serializable, Cloneable, Comparable<listParts_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listParts_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListPartsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListPartsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listParts_args.class, metaDataMap);
    }

    public listParts_args() {
    }

    public listParts_args(
        ListPartsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listParts_args(listParts_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listParts_args deepCopy() {
      return new listParts_args(this);
    }

    public ListPartsReq getReq() {
      return this.req;
    }

    public listParts_args setReq(ListPartsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListPartsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listParts_args))
        return false;
      listParts_args that = (listParts_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listParts_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListPartsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listParts_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listParts_result implements TBase, java.io.Serializable, Cloneable, Comparable<listParts_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listParts_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListPartsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListPartsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listParts_result.class, metaDataMap);
    }

    public listParts_result() {
    }

    public listParts_result(
        ListPartsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listParts_result(listParts_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listParts_result deepCopy() {
      return new listParts_result(this);
    }

    public ListPartsResp getSuccess() {
      return this.success;
    }

    public listParts_result setSuccess(ListPartsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListPartsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listParts_result))
        return false;
      listParts_result that = (listParts_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listParts_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListPartsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listParts_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getWorkerId_args implements TBase, java.io.Serializable, Cloneable, Comparable<getWorkerId_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getWorkerId_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetWorkerIdReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetWorkerIdReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getWorkerId_args.class, metaDataMap);
    }

    public getWorkerId_args() {
    }

    public getWorkerId_args(
        GetWorkerIdReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getWorkerId_args(getWorkerId_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getWorkerId_args deepCopy() {
      return new getWorkerId_args(this);
    }

    public GetWorkerIdReq getReq() {
      return this.req;
    }

    public getWorkerId_args setReq(GetWorkerIdReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetWorkerIdReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getWorkerId_args))
        return false;
      getWorkerId_args that = (getWorkerId_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getWorkerId_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetWorkerIdReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getWorkerId_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getWorkerId_result implements TBase, java.io.Serializable, Cloneable, Comparable<getWorkerId_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getWorkerId_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetWorkerIdResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetWorkerIdResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getWorkerId_result.class, metaDataMap);
    }

    public getWorkerId_result() {
    }

    public getWorkerId_result(
        GetWorkerIdResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getWorkerId_result(getWorkerId_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getWorkerId_result deepCopy() {
      return new getWorkerId_result(this);
    }

    public GetWorkerIdResp getSuccess() {
      return this.success;
    }

    public getWorkerId_result setSuccess(GetWorkerIdResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetWorkerIdResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getWorkerId_result))
        return false;
      getWorkerId_result that = (getWorkerId_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getWorkerId_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetWorkerIdResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getWorkerId_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createTagIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<createTagIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createTagIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateTagIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateTagIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createTagIndex_args.class, metaDataMap);
    }

    public createTagIndex_args() {
    }

    public createTagIndex_args(
        CreateTagIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTagIndex_args(createTagIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createTagIndex_args deepCopy() {
      return new createTagIndex_args(this);
    }

    public CreateTagIndexReq getReq() {
      return this.req;
    }

    public createTagIndex_args setReq(CreateTagIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateTagIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createTagIndex_args))
        return false;
      createTagIndex_args that = (createTagIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createTagIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateTagIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createTagIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createTagIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<createTagIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createTagIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createTagIndex_result.class, metaDataMap);
    }

    public createTagIndex_result() {
    }

    public createTagIndex_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTagIndex_result(createTagIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createTagIndex_result deepCopy() {
      return new createTagIndex_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public createTagIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createTagIndex_result))
        return false;
      createTagIndex_result that = (createTagIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createTagIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createTagIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropTagIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropTagIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTagIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropTagIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropTagIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropTagIndex_args.class, metaDataMap);
    }

    public dropTagIndex_args() {
    }

    public dropTagIndex_args(
        DropTagIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTagIndex_args(dropTagIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropTagIndex_args deepCopy() {
      return new dropTagIndex_args(this);
    }

    public DropTagIndexReq getReq() {
      return this.req;
    }

    public dropTagIndex_args setReq(DropTagIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropTagIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropTagIndex_args))
        return false;
      dropTagIndex_args that = (dropTagIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropTagIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropTagIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropTagIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropTagIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropTagIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTagIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropTagIndex_result.class, metaDataMap);
    }

    public dropTagIndex_result() {
    }

    public dropTagIndex_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTagIndex_result(dropTagIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropTagIndex_result deepCopy() {
      return new dropTagIndex_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropTagIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropTagIndex_result))
        return false;
      dropTagIndex_result that = (dropTagIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropTagIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropTagIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTagIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<getTagIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getTagIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetTagIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetTagIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getTagIndex_args.class, metaDataMap);
    }

    public getTagIndex_args() {
    }

    public getTagIndex_args(
        GetTagIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTagIndex_args(getTagIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getTagIndex_args deepCopy() {
      return new getTagIndex_args(this);
    }

    public GetTagIndexReq getReq() {
      return this.req;
    }

    public getTagIndex_args setReq(GetTagIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetTagIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getTagIndex_args))
        return false;
      getTagIndex_args that = (getTagIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getTagIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetTagIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getTagIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTagIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<getTagIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getTagIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetTagIndexResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetTagIndexResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getTagIndex_result.class, metaDataMap);
    }

    public getTagIndex_result() {
    }

    public getTagIndex_result(
        GetTagIndexResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTagIndex_result(getTagIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getTagIndex_result deepCopy() {
      return new getTagIndex_result(this);
    }

    public GetTagIndexResp getSuccess() {
      return this.success;
    }

    public getTagIndex_result setSuccess(GetTagIndexResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetTagIndexResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getTagIndex_result))
        return false;
      getTagIndex_result that = (getTagIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getTagIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetTagIndexResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getTagIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listTagIndexes_args implements TBase, java.io.Serializable, Cloneable, Comparable<listTagIndexes_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTagIndexes_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListTagIndexesReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListTagIndexesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTagIndexes_args.class, metaDataMap);
    }

    public listTagIndexes_args() {
    }

    public listTagIndexes_args(
        ListTagIndexesReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTagIndexes_args(listTagIndexes_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listTagIndexes_args deepCopy() {
      return new listTagIndexes_args(this);
    }

    public ListTagIndexesReq getReq() {
      return this.req;
    }

    public listTagIndexes_args setReq(ListTagIndexesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListTagIndexesReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listTagIndexes_args))
        return false;
      listTagIndexes_args that = (listTagIndexes_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listTagIndexes_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListTagIndexesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTagIndexes_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listTagIndexes_result implements TBase, java.io.Serializable, Cloneable, Comparable<listTagIndexes_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTagIndexes_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListTagIndexesResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListTagIndexesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTagIndexes_result.class, metaDataMap);
    }

    public listTagIndexes_result() {
    }

    public listTagIndexes_result(
        ListTagIndexesResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTagIndexes_result(listTagIndexes_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listTagIndexes_result deepCopy() {
      return new listTagIndexes_result(this);
    }

    public ListTagIndexesResp getSuccess() {
      return this.success;
    }

    public listTagIndexes_result setSuccess(ListTagIndexesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListTagIndexesResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listTagIndexes_result))
        return false;
      listTagIndexes_result that = (listTagIndexes_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listTagIndexes_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListTagIndexesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTagIndexes_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class rebuildTagIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<rebuildTagIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("rebuildTagIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RebuildIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RebuildIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(rebuildTagIndex_args.class, metaDataMap);
    }

    public rebuildTagIndex_args() {
    }

    public rebuildTagIndex_args(
        RebuildIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rebuildTagIndex_args(rebuildTagIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public rebuildTagIndex_args deepCopy() {
      return new rebuildTagIndex_args(this);
    }

    public RebuildIndexReq getReq() {
      return this.req;
    }

    public rebuildTagIndex_args setReq(RebuildIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((RebuildIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof rebuildTagIndex_args))
        return false;
      rebuildTagIndex_args that = (rebuildTagIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(rebuildTagIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new RebuildIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("rebuildTagIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class rebuildTagIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<rebuildTagIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("rebuildTagIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(rebuildTagIndex_result.class, metaDataMap);
    }

    public rebuildTagIndex_result() {
    }

    public rebuildTagIndex_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rebuildTagIndex_result(rebuildTagIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public rebuildTagIndex_result deepCopy() {
      return new rebuildTagIndex_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public rebuildTagIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof rebuildTagIndex_result))
        return false;
      rebuildTagIndex_result that = (rebuildTagIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(rebuildTagIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("rebuildTagIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listTagIndexStatus_args implements TBase, java.io.Serializable, Cloneable, Comparable<listTagIndexStatus_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTagIndexStatus_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListIndexStatusReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListIndexStatusReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTagIndexStatus_args.class, metaDataMap);
    }

    public listTagIndexStatus_args() {
    }

    public listTagIndexStatus_args(
        ListIndexStatusReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTagIndexStatus_args(listTagIndexStatus_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listTagIndexStatus_args deepCopy() {
      return new listTagIndexStatus_args(this);
    }

    public ListIndexStatusReq getReq() {
      return this.req;
    }

    public listTagIndexStatus_args setReq(ListIndexStatusReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListIndexStatusReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listTagIndexStatus_args))
        return false;
      listTagIndexStatus_args that = (listTagIndexStatus_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listTagIndexStatus_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListIndexStatusReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTagIndexStatus_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listTagIndexStatus_result implements TBase, java.io.Serializable, Cloneable, Comparable<listTagIndexStatus_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTagIndexStatus_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListIndexStatusResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListIndexStatusResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTagIndexStatus_result.class, metaDataMap);
    }

    public listTagIndexStatus_result() {
    }

    public listTagIndexStatus_result(
        ListIndexStatusResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTagIndexStatus_result(listTagIndexStatus_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listTagIndexStatus_result deepCopy() {
      return new listTagIndexStatus_result(this);
    }

    public ListIndexStatusResp getSuccess() {
      return this.success;
    }

    public listTagIndexStatus_result setSuccess(ListIndexStatusResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListIndexStatusResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listTagIndexStatus_result))
        return false;
      listTagIndexStatus_result that = (listTagIndexStatus_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listTagIndexStatus_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListIndexStatusResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTagIndexStatus_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createEdgeIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<createEdgeIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createEdgeIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateEdgeIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateEdgeIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createEdgeIndex_args.class, metaDataMap);
    }

    public createEdgeIndex_args() {
    }

    public createEdgeIndex_args(
        CreateEdgeIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createEdgeIndex_args(createEdgeIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createEdgeIndex_args deepCopy() {
      return new createEdgeIndex_args(this);
    }

    public CreateEdgeIndexReq getReq() {
      return this.req;
    }

    public createEdgeIndex_args setReq(CreateEdgeIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateEdgeIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createEdgeIndex_args))
        return false;
      createEdgeIndex_args that = (createEdgeIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createEdgeIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateEdgeIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createEdgeIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createEdgeIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<createEdgeIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createEdgeIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createEdgeIndex_result.class, metaDataMap);
    }

    public createEdgeIndex_result() {
    }

    public createEdgeIndex_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createEdgeIndex_result(createEdgeIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createEdgeIndex_result deepCopy() {
      return new createEdgeIndex_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public createEdgeIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createEdgeIndex_result))
        return false;
      createEdgeIndex_result that = (createEdgeIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createEdgeIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createEdgeIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropEdgeIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropEdgeIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropEdgeIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropEdgeIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropEdgeIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropEdgeIndex_args.class, metaDataMap);
    }

    public dropEdgeIndex_args() {
    }

    public dropEdgeIndex_args(
        DropEdgeIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropEdgeIndex_args(dropEdgeIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropEdgeIndex_args deepCopy() {
      return new dropEdgeIndex_args(this);
    }

    public DropEdgeIndexReq getReq() {
      return this.req;
    }

    public dropEdgeIndex_args setReq(DropEdgeIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropEdgeIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropEdgeIndex_args))
        return false;
      dropEdgeIndex_args that = (dropEdgeIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropEdgeIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropEdgeIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropEdgeIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropEdgeIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropEdgeIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropEdgeIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropEdgeIndex_result.class, metaDataMap);
    }

    public dropEdgeIndex_result() {
    }

    public dropEdgeIndex_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropEdgeIndex_result(dropEdgeIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropEdgeIndex_result deepCopy() {
      return new dropEdgeIndex_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropEdgeIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropEdgeIndex_result))
        return false;
      dropEdgeIndex_result that = (dropEdgeIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropEdgeIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropEdgeIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getEdgeIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<getEdgeIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getEdgeIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetEdgeIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetEdgeIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getEdgeIndex_args.class, metaDataMap);
    }

    public getEdgeIndex_args() {
    }

    public getEdgeIndex_args(
        GetEdgeIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEdgeIndex_args(getEdgeIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getEdgeIndex_args deepCopy() {
      return new getEdgeIndex_args(this);
    }

    public GetEdgeIndexReq getReq() {
      return this.req;
    }

    public getEdgeIndex_args setReq(GetEdgeIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetEdgeIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getEdgeIndex_args))
        return false;
      getEdgeIndex_args that = (getEdgeIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getEdgeIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetEdgeIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getEdgeIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getEdgeIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<getEdgeIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getEdgeIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetEdgeIndexResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetEdgeIndexResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getEdgeIndex_result.class, metaDataMap);
    }

    public getEdgeIndex_result() {
    }

    public getEdgeIndex_result(
        GetEdgeIndexResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEdgeIndex_result(getEdgeIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getEdgeIndex_result deepCopy() {
      return new getEdgeIndex_result(this);
    }

    public GetEdgeIndexResp getSuccess() {
      return this.success;
    }

    public getEdgeIndex_result setSuccess(GetEdgeIndexResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetEdgeIndexResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getEdgeIndex_result))
        return false;
      getEdgeIndex_result that = (getEdgeIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getEdgeIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetEdgeIndexResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getEdgeIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listEdgeIndexes_args implements TBase, java.io.Serializable, Cloneable, Comparable<listEdgeIndexes_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdgeIndexes_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListEdgeIndexesReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListEdgeIndexesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdgeIndexes_args.class, metaDataMap);
    }

    public listEdgeIndexes_args() {
    }

    public listEdgeIndexes_args(
        ListEdgeIndexesReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdgeIndexes_args(listEdgeIndexes_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listEdgeIndexes_args deepCopy() {
      return new listEdgeIndexes_args(this);
    }

    public ListEdgeIndexesReq getReq() {
      return this.req;
    }

    public listEdgeIndexes_args setReq(ListEdgeIndexesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListEdgeIndexesReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listEdgeIndexes_args))
        return false;
      listEdgeIndexes_args that = (listEdgeIndexes_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listEdgeIndexes_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListEdgeIndexesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdgeIndexes_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listEdgeIndexes_result implements TBase, java.io.Serializable, Cloneable, Comparable<listEdgeIndexes_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdgeIndexes_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListEdgeIndexesResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListEdgeIndexesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdgeIndexes_result.class, metaDataMap);
    }

    public listEdgeIndexes_result() {
    }

    public listEdgeIndexes_result(
        ListEdgeIndexesResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdgeIndexes_result(listEdgeIndexes_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listEdgeIndexes_result deepCopy() {
      return new listEdgeIndexes_result(this);
    }

    public ListEdgeIndexesResp getSuccess() {
      return this.success;
    }

    public listEdgeIndexes_result setSuccess(ListEdgeIndexesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListEdgeIndexesResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listEdgeIndexes_result))
        return false;
      listEdgeIndexes_result that = (listEdgeIndexes_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listEdgeIndexes_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListEdgeIndexesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdgeIndexes_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class rebuildEdgeIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<rebuildEdgeIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("rebuildEdgeIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RebuildIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RebuildIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(rebuildEdgeIndex_args.class, metaDataMap);
    }

    public rebuildEdgeIndex_args() {
    }

    public rebuildEdgeIndex_args(
        RebuildIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rebuildEdgeIndex_args(rebuildEdgeIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public rebuildEdgeIndex_args deepCopy() {
      return new rebuildEdgeIndex_args(this);
    }

    public RebuildIndexReq getReq() {
      return this.req;
    }

    public rebuildEdgeIndex_args setReq(RebuildIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((RebuildIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof rebuildEdgeIndex_args))
        return false;
      rebuildEdgeIndex_args that = (rebuildEdgeIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(rebuildEdgeIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new RebuildIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("rebuildEdgeIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class rebuildEdgeIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<rebuildEdgeIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("rebuildEdgeIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(rebuildEdgeIndex_result.class, metaDataMap);
    }

    public rebuildEdgeIndex_result() {
    }

    public rebuildEdgeIndex_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rebuildEdgeIndex_result(rebuildEdgeIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public rebuildEdgeIndex_result deepCopy() {
      return new rebuildEdgeIndex_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public rebuildEdgeIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof rebuildEdgeIndex_result))
        return false;
      rebuildEdgeIndex_result that = (rebuildEdgeIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(rebuildEdgeIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("rebuildEdgeIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listEdgeIndexStatus_args implements TBase, java.io.Serializable, Cloneable, Comparable<listEdgeIndexStatus_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdgeIndexStatus_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListIndexStatusReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListIndexStatusReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdgeIndexStatus_args.class, metaDataMap);
    }

    public listEdgeIndexStatus_args() {
    }

    public listEdgeIndexStatus_args(
        ListIndexStatusReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdgeIndexStatus_args(listEdgeIndexStatus_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listEdgeIndexStatus_args deepCopy() {
      return new listEdgeIndexStatus_args(this);
    }

    public ListIndexStatusReq getReq() {
      return this.req;
    }

    public listEdgeIndexStatus_args setReq(ListIndexStatusReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListIndexStatusReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listEdgeIndexStatus_args))
        return false;
      listEdgeIndexStatus_args that = (listEdgeIndexStatus_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listEdgeIndexStatus_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListIndexStatusReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdgeIndexStatus_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listEdgeIndexStatus_result implements TBase, java.io.Serializable, Cloneable, Comparable<listEdgeIndexStatus_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdgeIndexStatus_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListIndexStatusResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListIndexStatusResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdgeIndexStatus_result.class, metaDataMap);
    }

    public listEdgeIndexStatus_result() {
    }

    public listEdgeIndexStatus_result(
        ListIndexStatusResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdgeIndexStatus_result(listEdgeIndexStatus_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listEdgeIndexStatus_result deepCopy() {
      return new listEdgeIndexStatus_result(this);
    }

    public ListIndexStatusResp getSuccess() {
      return this.success;
    }

    public listEdgeIndexStatus_result setSuccess(ListIndexStatusResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListIndexStatusResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listEdgeIndexStatus_result))
        return false;
      listEdgeIndexStatus_result that = (listEdgeIndexStatus_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listEdgeIndexStatus_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListIndexStatusResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdgeIndexStatus_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createUser_args implements TBase, java.io.Serializable, Cloneable, Comparable<createUser_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createUser_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateUserReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateUserReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createUser_args.class, metaDataMap);
    }

    public createUser_args() {
    }

    public createUser_args(
        CreateUserReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createUser_args(createUser_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createUser_args deepCopy() {
      return new createUser_args(this);
    }

    public CreateUserReq getReq() {
      return this.req;
    }

    public createUser_args setReq(CreateUserReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateUserReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createUser_args))
        return false;
      createUser_args that = (createUser_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createUser_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateUserReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createUser_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createUser_result implements TBase, java.io.Serializable, Cloneable, Comparable<createUser_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createUser_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createUser_result.class, metaDataMap);
    }

    public createUser_result() {
    }

    public createUser_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createUser_result(createUser_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createUser_result deepCopy() {
      return new createUser_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public createUser_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createUser_result))
        return false;
      createUser_result that = (createUser_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createUser_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createUser_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropUser_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropUser_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropUser_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropUserReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropUserReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropUser_args.class, metaDataMap);
    }

    public dropUser_args() {
    }

    public dropUser_args(
        DropUserReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropUser_args(dropUser_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropUser_args deepCopy() {
      return new dropUser_args(this);
    }

    public DropUserReq getReq() {
      return this.req;
    }

    public dropUser_args setReq(DropUserReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropUserReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropUser_args))
        return false;
      dropUser_args that = (dropUser_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropUser_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropUserReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropUser_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropUser_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropUser_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropUser_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropUser_result.class, metaDataMap);
    }

    public dropUser_result() {
    }

    public dropUser_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropUser_result(dropUser_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropUser_result deepCopy() {
      return new dropUser_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropUser_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropUser_result))
        return false;
      dropUser_result that = (dropUser_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropUser_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropUser_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alterUser_args implements TBase, java.io.Serializable, Cloneable, Comparable<alterUser_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterUser_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AlterUserReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AlterUserReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterUser_args.class, metaDataMap);
    }

    public alterUser_args() {
    }

    public alterUser_args(
        AlterUserReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterUser_args(alterUser_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public alterUser_args deepCopy() {
      return new alterUser_args(this);
    }

    public AlterUserReq getReq() {
      return this.req;
    }

    public alterUser_args setReq(AlterUserReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AlterUserReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof alterUser_args))
        return false;
      alterUser_args that = (alterUser_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(alterUser_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AlterUserReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterUser_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alterUser_result implements TBase, java.io.Serializable, Cloneable, Comparable<alterUser_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterUser_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterUser_result.class, metaDataMap);
    }

    public alterUser_result() {
    }

    public alterUser_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterUser_result(alterUser_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public alterUser_result deepCopy() {
      return new alterUser_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public alterUser_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof alterUser_result))
        return false;
      alterUser_result that = (alterUser_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(alterUser_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterUser_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class grantRole_args implements TBase, java.io.Serializable, Cloneable, Comparable<grantRole_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("grantRole_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GrantRoleReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GrantRoleReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(grantRole_args.class, metaDataMap);
    }

    public grantRole_args() {
    }

    public grantRole_args(
        GrantRoleReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public grantRole_args(grantRole_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public grantRole_args deepCopy() {
      return new grantRole_args(this);
    }

    public GrantRoleReq getReq() {
      return this.req;
    }

    public grantRole_args setReq(GrantRoleReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GrantRoleReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof grantRole_args))
        return false;
      grantRole_args that = (grantRole_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(grantRole_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GrantRoleReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("grantRole_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class grantRole_result implements TBase, java.io.Serializable, Cloneable, Comparable<grantRole_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("grantRole_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(grantRole_result.class, metaDataMap);
    }

    public grantRole_result() {
    }

    public grantRole_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public grantRole_result(grantRole_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public grantRole_result deepCopy() {
      return new grantRole_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public grantRole_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof grantRole_result))
        return false;
      grantRole_result that = (grantRole_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(grantRole_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("grantRole_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class revokeRole_args implements TBase, java.io.Serializable, Cloneable, Comparable<revokeRole_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("revokeRole_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RevokeRoleReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RevokeRoleReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(revokeRole_args.class, metaDataMap);
    }

    public revokeRole_args() {
    }

    public revokeRole_args(
        RevokeRoleReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public revokeRole_args(revokeRole_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public revokeRole_args deepCopy() {
      return new revokeRole_args(this);
    }

    public RevokeRoleReq getReq() {
      return this.req;
    }

    public revokeRole_args setReq(RevokeRoleReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((RevokeRoleReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof revokeRole_args))
        return false;
      revokeRole_args that = (revokeRole_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(revokeRole_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new RevokeRoleReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("revokeRole_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class revokeRole_result implements TBase, java.io.Serializable, Cloneable, Comparable<revokeRole_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("revokeRole_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(revokeRole_result.class, metaDataMap);
    }

    public revokeRole_result() {
    }

    public revokeRole_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public revokeRole_result(revokeRole_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public revokeRole_result deepCopy() {
      return new revokeRole_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public revokeRole_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof revokeRole_result))
        return false;
      revokeRole_result that = (revokeRole_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(revokeRole_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("revokeRole_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listUsers_args implements TBase, java.io.Serializable, Cloneable, Comparable<listUsers_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listUsers_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListUsersReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListUsersReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listUsers_args.class, metaDataMap);
    }

    public listUsers_args() {
    }

    public listUsers_args(
        ListUsersReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listUsers_args(listUsers_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listUsers_args deepCopy() {
      return new listUsers_args(this);
    }

    public ListUsersReq getReq() {
      return this.req;
    }

    public listUsers_args setReq(ListUsersReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListUsersReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listUsers_args))
        return false;
      listUsers_args that = (listUsers_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listUsers_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListUsersReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listUsers_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listUsers_result implements TBase, java.io.Serializable, Cloneable, Comparable<listUsers_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listUsers_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListUsersResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListUsersResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listUsers_result.class, metaDataMap);
    }

    public listUsers_result() {
    }

    public listUsers_result(
        ListUsersResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listUsers_result(listUsers_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listUsers_result deepCopy() {
      return new listUsers_result(this);
    }

    public ListUsersResp getSuccess() {
      return this.success;
    }

    public listUsers_result setSuccess(ListUsersResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListUsersResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listUsers_result))
        return false;
      listUsers_result that = (listUsers_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listUsers_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListUsersResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listUsers_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listRoles_args implements TBase, java.io.Serializable, Cloneable, Comparable<listRoles_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listRoles_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListRolesReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListRolesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listRoles_args.class, metaDataMap);
    }

    public listRoles_args() {
    }

    public listRoles_args(
        ListRolesReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listRoles_args(listRoles_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listRoles_args deepCopy() {
      return new listRoles_args(this);
    }

    public ListRolesReq getReq() {
      return this.req;
    }

    public listRoles_args setReq(ListRolesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListRolesReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listRoles_args))
        return false;
      listRoles_args that = (listRoles_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listRoles_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListRolesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listRoles_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listRoles_result implements TBase, java.io.Serializable, Cloneable, Comparable<listRoles_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listRoles_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListRolesResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListRolesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listRoles_result.class, metaDataMap);
    }

    public listRoles_result() {
    }

    public listRoles_result(
        ListRolesResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listRoles_result(listRoles_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listRoles_result deepCopy() {
      return new listRoles_result(this);
    }

    public ListRolesResp getSuccess() {
      return this.success;
    }

    public listRoles_result setSuccess(ListRolesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListRolesResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listRoles_result))
        return false;
      listRoles_result that = (listRoles_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listRoles_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListRolesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listRoles_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getUserRoles_args implements TBase, java.io.Serializable, Cloneable, Comparable<getUserRoles_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getUserRoles_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetUserRolesReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetUserRolesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getUserRoles_args.class, metaDataMap);
    }

    public getUserRoles_args() {
    }

    public getUserRoles_args(
        GetUserRolesReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getUserRoles_args(getUserRoles_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getUserRoles_args deepCopy() {
      return new getUserRoles_args(this);
    }

    public GetUserRolesReq getReq() {
      return this.req;
    }

    public getUserRoles_args setReq(GetUserRolesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetUserRolesReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getUserRoles_args))
        return false;
      getUserRoles_args that = (getUserRoles_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getUserRoles_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetUserRolesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getUserRoles_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getUserRoles_result implements TBase, java.io.Serializable, Cloneable, Comparable<getUserRoles_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getUserRoles_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListRolesResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListRolesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getUserRoles_result.class, metaDataMap);
    }

    public getUserRoles_result() {
    }

    public getUserRoles_result(
        ListRolesResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getUserRoles_result(getUserRoles_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getUserRoles_result deepCopy() {
      return new getUserRoles_result(this);
    }

    public ListRolesResp getSuccess() {
      return this.success;
    }

    public getUserRoles_result setSuccess(ListRolesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListRolesResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getUserRoles_result))
        return false;
      getUserRoles_result that = (getUserRoles_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getUserRoles_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListRolesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getUserRoles_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class changePassword_args implements TBase, java.io.Serializable, Cloneable, Comparable<changePassword_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("changePassword_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ChangePasswordReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ChangePasswordReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(changePassword_args.class, metaDataMap);
    }

    public changePassword_args() {
    }

    public changePassword_args(
        ChangePasswordReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public changePassword_args(changePassword_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public changePassword_args deepCopy() {
      return new changePassword_args(this);
    }

    public ChangePasswordReq getReq() {
      return this.req;
    }

    public changePassword_args setReq(ChangePasswordReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ChangePasswordReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof changePassword_args))
        return false;
      changePassword_args that = (changePassword_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(changePassword_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ChangePasswordReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("changePassword_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class changePassword_result implements TBase, java.io.Serializable, Cloneable, Comparable<changePassword_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("changePassword_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(changePassword_result.class, metaDataMap);
    }

    public changePassword_result() {
    }

    public changePassword_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public changePassword_result(changePassword_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public changePassword_result deepCopy() {
      return new changePassword_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public changePassword_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof changePassword_result))
        return false;
      changePassword_result that = (changePassword_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(changePassword_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("changePassword_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class heartBeat_args implements TBase, java.io.Serializable, Cloneable, Comparable<heartBeat_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("heartBeat_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public HBReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, HBReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(heartBeat_args.class, metaDataMap);
    }

    public heartBeat_args() {
    }

    public heartBeat_args(
        HBReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public heartBeat_args(heartBeat_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public heartBeat_args deepCopy() {
      return new heartBeat_args(this);
    }

    public HBReq getReq() {
      return this.req;
    }

    public heartBeat_args setReq(HBReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((HBReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof heartBeat_args))
        return false;
      heartBeat_args that = (heartBeat_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(heartBeat_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new HBReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("heartBeat_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class heartBeat_result implements TBase, java.io.Serializable, Cloneable, Comparable<heartBeat_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("heartBeat_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public HBResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, HBResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(heartBeat_result.class, metaDataMap);
    }

    public heartBeat_result() {
    }

    public heartBeat_result(
        HBResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public heartBeat_result(heartBeat_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public heartBeat_result deepCopy() {
      return new heartBeat_result(this);
    }

    public HBResp getSuccess() {
      return this.success;
    }

    public heartBeat_result setSuccess(HBResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((HBResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof heartBeat_result))
        return false;
      heartBeat_result that = (heartBeat_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(heartBeat_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new HBResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("heartBeat_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class agentHeartbeat_args implements TBase, java.io.Serializable, Cloneable, Comparable<agentHeartbeat_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("agentHeartbeat_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AgentHBReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AgentHBReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(agentHeartbeat_args.class, metaDataMap);
    }

    public agentHeartbeat_args() {
    }

    public agentHeartbeat_args(
        AgentHBReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public agentHeartbeat_args(agentHeartbeat_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public agentHeartbeat_args deepCopy() {
      return new agentHeartbeat_args(this);
    }

    public AgentHBReq getReq() {
      return this.req;
    }

    public agentHeartbeat_args setReq(AgentHBReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AgentHBReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof agentHeartbeat_args))
        return false;
      agentHeartbeat_args that = (agentHeartbeat_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(agentHeartbeat_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AgentHBReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("agentHeartbeat_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class agentHeartbeat_result implements TBase, java.io.Serializable, Cloneable, Comparable<agentHeartbeat_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("agentHeartbeat_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public AgentHBResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AgentHBResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(agentHeartbeat_result.class, metaDataMap);
    }

    public agentHeartbeat_result() {
    }

    public agentHeartbeat_result(
        AgentHBResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public agentHeartbeat_result(agentHeartbeat_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public agentHeartbeat_result deepCopy() {
      return new agentHeartbeat_result(this);
    }

    public AgentHBResp getSuccess() {
      return this.success;
    }

    public agentHeartbeat_result setSuccess(AgentHBResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((AgentHBResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof agentHeartbeat_result))
        return false;
      agentHeartbeat_result that = (agentHeartbeat_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(agentHeartbeat_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new AgentHBResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("agentHeartbeat_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class regConfig_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("regConfig_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RegConfigReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RegConfigReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(regConfig_args.class, metaDataMap);
    }

    public regConfig_args() {
    }

    public regConfig_args(
        RegConfigReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public regConfig_args(regConfig_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public regConfig_args deepCopy() {
      return new regConfig_args(this);
    }

    public RegConfigReq getReq() {
      return this.req;
    }

    public regConfig_args setReq(RegConfigReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((RegConfigReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof regConfig_args))
        return false;
      regConfig_args that = (regConfig_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new RegConfigReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("regConfig_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class regConfig_result implements TBase, java.io.Serializable, Cloneable, Comparable<regConfig_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("regConfig_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(regConfig_result.class, metaDataMap);
    }

    public regConfig_result() {
    }

    public regConfig_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public regConfig_result(regConfig_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public regConfig_result deepCopy() {
      return new regConfig_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public regConfig_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof regConfig_result))
        return false;
      regConfig_result that = (regConfig_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(regConfig_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("regConfig_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getConfig_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getConfig_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetConfigReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetConfigReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getConfig_args.class, metaDataMap);
    }

    public getConfig_args() {
    }

    public getConfig_args(
        GetConfigReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConfig_args(getConfig_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getConfig_args deepCopy() {
      return new getConfig_args(this);
    }

    public GetConfigReq getReq() {
      return this.req;
    }

    public getConfig_args setReq(GetConfigReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetConfigReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getConfig_args))
        return false;
      getConfig_args that = (getConfig_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetConfigReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getConfig_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getConfig_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getConfig_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetConfigResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetConfigResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getConfig_result.class, metaDataMap);
    }

    public getConfig_result() {
    }

    public getConfig_result(
        GetConfigResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConfig_result(getConfig_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getConfig_result deepCopy() {
      return new getConfig_result(this);
    }

    public GetConfigResp getSuccess() {
      return this.success;
    }

    public getConfig_result setSuccess(GetConfigResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetConfigResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getConfig_result))
        return false;
      getConfig_result that = (getConfig_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetConfigResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getConfig_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setConfig_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setConfig_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public SetConfigReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, SetConfigReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(setConfig_args.class, metaDataMap);
    }

    public setConfig_args() {
    }

    public setConfig_args(
        SetConfigReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setConfig_args(setConfig_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public setConfig_args deepCopy() {
      return new setConfig_args(this);
    }

    public SetConfigReq getReq() {
      return this.req;
    }

    public setConfig_args setReq(SetConfigReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((SetConfigReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof setConfig_args))
        return false;
      setConfig_args that = (setConfig_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new SetConfigReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("setConfig_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setConfig_result implements TBase, java.io.Serializable, Cloneable, Comparable<setConfig_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("setConfig_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(setConfig_result.class, metaDataMap);
    }

    public setConfig_result() {
    }

    public setConfig_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setConfig_result(setConfig_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public setConfig_result deepCopy() {
      return new setConfig_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public setConfig_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof setConfig_result))
        return false;
      setConfig_result that = (setConfig_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(setConfig_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("setConfig_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listConfigs_args implements TBase, java.io.Serializable, Cloneable, Comparable<listConfigs_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listConfigs_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListConfigsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListConfigsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listConfigs_args.class, metaDataMap);
    }

    public listConfigs_args() {
    }

    public listConfigs_args(
        ListConfigsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listConfigs_args(listConfigs_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listConfigs_args deepCopy() {
      return new listConfigs_args(this);
    }

    public ListConfigsReq getReq() {
      return this.req;
    }

    public listConfigs_args setReq(ListConfigsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListConfigsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listConfigs_args))
        return false;
      listConfigs_args that = (listConfigs_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listConfigs_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListConfigsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listConfigs_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listConfigs_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("listConfigs_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListConfigsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListConfigsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listConfigs_result.class, metaDataMap);
    }

    public listConfigs_result() {
    }

    public listConfigs_result(
        ListConfigsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listConfigs_result(listConfigs_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listConfigs_result deepCopy() {
      return new listConfigs_result(this);
    }

    public ListConfigsResp getSuccess() {
      return this.success;
    }

    public listConfigs_result setSuccess(ListConfigsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListConfigsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listConfigs_result))
        return false;
      listConfigs_result that = (listConfigs_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListConfigsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listConfigs_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createSnapshot_args implements TBase, java.io.Serializable, Cloneable, Comparable<createSnapshot_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSnapshot_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateSnapshotReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateSnapshotReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSnapshot_args.class, metaDataMap);
    }

    public createSnapshot_args() {
    }

    public createSnapshot_args(
        CreateSnapshotReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSnapshot_args(createSnapshot_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createSnapshot_args deepCopy() {
      return new createSnapshot_args(this);
    }

    public CreateSnapshotReq getReq() {
      return this.req;
    }

    public createSnapshot_args setReq(CreateSnapshotReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateSnapshotReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createSnapshot_args))
        return false;
      createSnapshot_args that = (createSnapshot_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createSnapshot_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateSnapshotReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSnapshot_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createSnapshot_result implements TBase, java.io.Serializable, Cloneable, Comparable<createSnapshot_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSnapshot_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSnapshot_result.class, metaDataMap);
    }

    public createSnapshot_result() {
    }

    public createSnapshot_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSnapshot_result(createSnapshot_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createSnapshot_result deepCopy() {
      return new createSnapshot_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public createSnapshot_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createSnapshot_result))
        return false;
      createSnapshot_result that = (createSnapshot_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createSnapshot_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSnapshot_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropSnapshot_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropSnapshot_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropSnapshot_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropSnapshotReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropSnapshotReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropSnapshot_args.class, metaDataMap);
    }

    public dropSnapshot_args() {
    }

    public dropSnapshot_args(
        DropSnapshotReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropSnapshot_args(dropSnapshot_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropSnapshot_args deepCopy() {
      return new dropSnapshot_args(this);
    }

    public DropSnapshotReq getReq() {
      return this.req;
    }

    public dropSnapshot_args setReq(DropSnapshotReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropSnapshotReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropSnapshot_args))
        return false;
      dropSnapshot_args that = (dropSnapshot_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropSnapshot_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropSnapshotReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropSnapshot_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropSnapshot_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropSnapshot_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropSnapshot_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropSnapshot_result.class, metaDataMap);
    }

    public dropSnapshot_result() {
    }

    public dropSnapshot_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropSnapshot_result(dropSnapshot_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropSnapshot_result deepCopy() {
      return new dropSnapshot_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropSnapshot_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropSnapshot_result))
        return false;
      dropSnapshot_result that = (dropSnapshot_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropSnapshot_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropSnapshot_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listSnapshots_args implements TBase, java.io.Serializable, Cloneable, Comparable<listSnapshots_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSnapshots_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListSnapshotsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSnapshotsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSnapshots_args.class, metaDataMap);
    }

    public listSnapshots_args() {
    }

    public listSnapshots_args(
        ListSnapshotsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSnapshots_args(listSnapshots_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listSnapshots_args deepCopy() {
      return new listSnapshots_args(this);
    }

    public ListSnapshotsReq getReq() {
      return this.req;
    }

    public listSnapshots_args setReq(ListSnapshotsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListSnapshotsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listSnapshots_args))
        return false;
      listSnapshots_args that = (listSnapshots_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listSnapshots_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListSnapshotsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSnapshots_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listSnapshots_result implements TBase, java.io.Serializable, Cloneable, Comparable<listSnapshots_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSnapshots_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListSnapshotsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSnapshotsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSnapshots_result.class, metaDataMap);
    }

    public listSnapshots_result() {
    }

    public listSnapshots_result(
        ListSnapshotsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSnapshots_result(listSnapshots_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listSnapshots_result deepCopy() {
      return new listSnapshots_result(this);
    }

    public ListSnapshotsResp getSuccess() {
      return this.success;
    }

    public listSnapshots_result setSuccess(ListSnapshotsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListSnapshotsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listSnapshots_result))
        return false;
      listSnapshots_result that = (listSnapshots_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listSnapshots_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListSnapshotsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSnapshots_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class runAdminJob_args implements TBase, java.io.Serializable, Cloneable, Comparable<runAdminJob_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("runAdminJob_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AdminJobReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AdminJobReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(runAdminJob_args.class, metaDataMap);
    }

    public runAdminJob_args() {
    }

    public runAdminJob_args(
        AdminJobReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public runAdminJob_args(runAdminJob_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public runAdminJob_args deepCopy() {
      return new runAdminJob_args(this);
    }

    public AdminJobReq getReq() {
      return this.req;
    }

    public runAdminJob_args setReq(AdminJobReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AdminJobReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof runAdminJob_args))
        return false;
      runAdminJob_args that = (runAdminJob_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(runAdminJob_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AdminJobReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("runAdminJob_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class runAdminJob_result implements TBase, java.io.Serializable, Cloneable, Comparable<runAdminJob_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("runAdminJob_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public AdminJobResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AdminJobResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(runAdminJob_result.class, metaDataMap);
    }

    public runAdminJob_result() {
    }

    public runAdminJob_result(
        AdminJobResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public runAdminJob_result(runAdminJob_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public runAdminJob_result deepCopy() {
      return new runAdminJob_result(this);
    }

    public AdminJobResp getSuccess() {
      return this.success;
    }

    public runAdminJob_result setSuccess(AdminJobResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((AdminJobResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof runAdminJob_result))
        return false;
      runAdminJob_result that = (runAdminJob_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(runAdminJob_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new AdminJobResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("runAdminJob_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class mergeZone_args implements TBase, java.io.Serializable, Cloneable, Comparable<mergeZone_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("mergeZone_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public MergeZoneReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, MergeZoneReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(mergeZone_args.class, metaDataMap);
    }

    public mergeZone_args() {
    }

    public mergeZone_args(
        MergeZoneReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mergeZone_args(mergeZone_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public mergeZone_args deepCopy() {
      return new mergeZone_args(this);
    }

    public MergeZoneReq getReq() {
      return this.req;
    }

    public mergeZone_args setReq(MergeZoneReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((MergeZoneReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof mergeZone_args))
        return false;
      mergeZone_args that = (mergeZone_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(mergeZone_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new MergeZoneReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("mergeZone_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class mergeZone_result implements TBase, java.io.Serializable, Cloneable, Comparable<mergeZone_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("mergeZone_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(mergeZone_result.class, metaDataMap);
    }

    public mergeZone_result() {
    }

    public mergeZone_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mergeZone_result(mergeZone_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public mergeZone_result deepCopy() {
      return new mergeZone_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public mergeZone_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof mergeZone_result))
        return false;
      mergeZone_result that = (mergeZone_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(mergeZone_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("mergeZone_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropZone_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropZone_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropZone_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropZoneReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropZoneReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropZone_args.class, metaDataMap);
    }

    public dropZone_args() {
    }

    public dropZone_args(
        DropZoneReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropZone_args(dropZone_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropZone_args deepCopy() {
      return new dropZone_args(this);
    }

    public DropZoneReq getReq() {
      return this.req;
    }

    public dropZone_args setReq(DropZoneReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropZoneReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropZone_args))
        return false;
      dropZone_args that = (dropZone_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropZone_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropZoneReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropZone_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropZone_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropZone_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropZone_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropZone_result.class, metaDataMap);
    }

    public dropZone_result() {
    }

    public dropZone_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropZone_result(dropZone_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropZone_result deepCopy() {
      return new dropZone_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropZone_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropZone_result))
        return false;
      dropZone_result that = (dropZone_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropZone_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropZone_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class divideZone_args implements TBase, java.io.Serializable, Cloneable, Comparable<divideZone_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("divideZone_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DivideZoneReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DivideZoneReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(divideZone_args.class, metaDataMap);
    }

    public divideZone_args() {
    }

    public divideZone_args(
        DivideZoneReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public divideZone_args(divideZone_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public divideZone_args deepCopy() {
      return new divideZone_args(this);
    }

    public DivideZoneReq getReq() {
      return this.req;
    }

    public divideZone_args setReq(DivideZoneReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DivideZoneReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof divideZone_args))
        return false;
      divideZone_args that = (divideZone_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(divideZone_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DivideZoneReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("divideZone_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class divideZone_result implements TBase, java.io.Serializable, Cloneable, Comparable<divideZone_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("divideZone_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(divideZone_result.class, metaDataMap);
    }

    public divideZone_result() {
    }

    public divideZone_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public divideZone_result(divideZone_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public divideZone_result deepCopy() {
      return new divideZone_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public divideZone_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof divideZone_result))
        return false;
      divideZone_result that = (divideZone_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(divideZone_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("divideZone_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class renameZone_args implements TBase, java.io.Serializable, Cloneable, Comparable<renameZone_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("renameZone_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RenameZoneReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RenameZoneReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(renameZone_args.class, metaDataMap);
    }

    public renameZone_args() {
    }

    public renameZone_args(
        RenameZoneReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public renameZone_args(renameZone_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public renameZone_args deepCopy() {
      return new renameZone_args(this);
    }

    public RenameZoneReq getReq() {
      return this.req;
    }

    public renameZone_args setReq(RenameZoneReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((RenameZoneReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof renameZone_args))
        return false;
      renameZone_args that = (renameZone_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(renameZone_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new RenameZoneReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("renameZone_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class renameZone_result implements TBase, java.io.Serializable, Cloneable, Comparable<renameZone_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("renameZone_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(renameZone_result.class, metaDataMap);
    }

    public renameZone_result() {
    }

    public renameZone_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public renameZone_result(renameZone_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public renameZone_result deepCopy() {
      return new renameZone_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public renameZone_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof renameZone_result))
        return false;
      renameZone_result that = (renameZone_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(renameZone_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("renameZone_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getZone_args implements TBase, java.io.Serializable, Cloneable, Comparable<getZone_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getZone_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetZoneReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetZoneReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getZone_args.class, metaDataMap);
    }

    public getZone_args() {
    }

    public getZone_args(
        GetZoneReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getZone_args(getZone_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getZone_args deepCopy() {
      return new getZone_args(this);
    }

    public GetZoneReq getReq() {
      return this.req;
    }

    public getZone_args setReq(GetZoneReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetZoneReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getZone_args))
        return false;
      getZone_args that = (getZone_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getZone_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetZoneReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getZone_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getZone_result implements TBase, java.io.Serializable, Cloneable, Comparable<getZone_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getZone_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetZoneResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetZoneResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getZone_result.class, metaDataMap);
    }

    public getZone_result() {
    }

    public getZone_result(
        GetZoneResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getZone_result(getZone_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getZone_result deepCopy() {
      return new getZone_result(this);
    }

    public GetZoneResp getSuccess() {
      return this.success;
    }

    public getZone_result setSuccess(GetZoneResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetZoneResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getZone_result))
        return false;
      getZone_result that = (getZone_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getZone_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetZoneResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getZone_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listZones_args implements TBase, java.io.Serializable, Cloneable, Comparable<listZones_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listZones_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListZonesReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListZonesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listZones_args.class, metaDataMap);
    }

    public listZones_args() {
    }

    public listZones_args(
        ListZonesReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listZones_args(listZones_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listZones_args deepCopy() {
      return new listZones_args(this);
    }

    public ListZonesReq getReq() {
      return this.req;
    }

    public listZones_args setReq(ListZonesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListZonesReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listZones_args))
        return false;
      listZones_args that = (listZones_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listZones_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListZonesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listZones_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listZones_result implements TBase, java.io.Serializable, Cloneable, Comparable<listZones_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listZones_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListZonesResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListZonesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listZones_result.class, metaDataMap);
    }

    public listZones_result() {
    }

    public listZones_result(
        ListZonesResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listZones_result(listZones_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listZones_result deepCopy() {
      return new listZones_result(this);
    }

    public ListZonesResp getSuccess() {
      return this.success;
    }

    public listZones_result setSuccess(ListZonesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListZonesResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listZones_result))
        return false;
      listZones_result that = (listZones_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listZones_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListZonesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listZones_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addListener_args implements TBase, java.io.Serializable, Cloneable, Comparable<addListener_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("addListener_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AddListenerReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AddListenerReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(addListener_args.class, metaDataMap);
    }

    public addListener_args() {
    }

    public addListener_args(
        AddListenerReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addListener_args(addListener_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public addListener_args deepCopy() {
      return new addListener_args(this);
    }

    public AddListenerReq getReq() {
      return this.req;
    }

    public addListener_args setReq(AddListenerReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AddListenerReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof addListener_args))
        return false;
      addListener_args that = (addListener_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(addListener_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AddListenerReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("addListener_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addListener_result implements TBase, java.io.Serializable, Cloneable, Comparable<addListener_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("addListener_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(addListener_result.class, metaDataMap);
    }

    public addListener_result() {
    }

    public addListener_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addListener_result(addListener_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public addListener_result deepCopy() {
      return new addListener_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public addListener_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof addListener_result))
        return false;
      addListener_result that = (addListener_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(addListener_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("addListener_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class removeListener_args implements TBase, java.io.Serializable, Cloneable, Comparable<removeListener_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeListener_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RemoveListenerReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RemoveListenerReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(removeListener_args.class, metaDataMap);
    }

    public removeListener_args() {
    }

    public removeListener_args(
        RemoveListenerReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeListener_args(removeListener_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public removeListener_args deepCopy() {
      return new removeListener_args(this);
    }

    public RemoveListenerReq getReq() {
      return this.req;
    }

    public removeListener_args setReq(RemoveListenerReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((RemoveListenerReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof removeListener_args))
        return false;
      removeListener_args that = (removeListener_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(removeListener_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new RemoveListenerReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("removeListener_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class removeListener_result implements TBase, java.io.Serializable, Cloneable, Comparable<removeListener_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeListener_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(removeListener_result.class, metaDataMap);
    }

    public removeListener_result() {
    }

    public removeListener_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeListener_result(removeListener_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public removeListener_result deepCopy() {
      return new removeListener_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public removeListener_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof removeListener_result))
        return false;
      removeListener_result that = (removeListener_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(removeListener_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("removeListener_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listListener_args implements TBase, java.io.Serializable, Cloneable, Comparable<listListener_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listListener_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListListenerReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListListenerReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listListener_args.class, metaDataMap);
    }

    public listListener_args() {
    }

    public listListener_args(
        ListListenerReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listListener_args(listListener_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listListener_args deepCopy() {
      return new listListener_args(this);
    }

    public ListListenerReq getReq() {
      return this.req;
    }

    public listListener_args setReq(ListListenerReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListListenerReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listListener_args))
        return false;
      listListener_args that = (listListener_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listListener_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListListenerReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listListener_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listListener_result implements TBase, java.io.Serializable, Cloneable, Comparable<listListener_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listListener_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListListenerResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListListenerResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listListener_result.class, metaDataMap);
    }

    public listListener_result() {
    }

    public listListener_result(
        ListListenerResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listListener_result(listListener_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listListener_result deepCopy() {
      return new listListener_result(this);
    }

    public ListListenerResp getSuccess() {
      return this.success;
    }

    public listListener_result setSuccess(ListListenerResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListListenerResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listListener_result))
        return false;
      listListener_result that = (listListener_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listListener_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListListenerResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listListener_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getStats_args implements TBase, java.io.Serializable, Cloneable, Comparable<getStats_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getStats_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetStatsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetStatsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getStats_args.class, metaDataMap);
    }

    public getStats_args() {
    }

    public getStats_args(
        GetStatsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getStats_args(getStats_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getStats_args deepCopy() {
      return new getStats_args(this);
    }

    public GetStatsReq getReq() {
      return this.req;
    }

    public getStats_args setReq(GetStatsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetStatsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getStats_args))
        return false;
      getStats_args that = (getStats_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getStats_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetStatsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getStats_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getStats_result implements TBase, java.io.Serializable, Cloneable, Comparable<getStats_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getStats_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetStatsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetStatsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getStats_result.class, metaDataMap);
    }

    public getStats_result() {
    }

    public getStats_result(
        GetStatsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getStats_result(getStats_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getStats_result deepCopy() {
      return new getStats_result(this);
    }

    public GetStatsResp getSuccess() {
      return this.success;
    }

    public getStats_result setSuccess(GetStatsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetStatsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getStats_result))
        return false;
      getStats_result that = (getStats_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getStats_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetStatsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getStats_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class signInService_args implements TBase, java.io.Serializable, Cloneable, Comparable<signInService_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("signInService_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public SignInServiceReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, SignInServiceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(signInService_args.class, metaDataMap);
    }

    public signInService_args() {
    }

    public signInService_args(
        SignInServiceReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public signInService_args(signInService_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public signInService_args deepCopy() {
      return new signInService_args(this);
    }

    public SignInServiceReq getReq() {
      return this.req;
    }

    public signInService_args setReq(SignInServiceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((SignInServiceReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof signInService_args))
        return false;
      signInService_args that = (signInService_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(signInService_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new SignInServiceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("signInService_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class signInService_result implements TBase, java.io.Serializable, Cloneable, Comparable<signInService_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("signInService_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(signInService_result.class, metaDataMap);
    }

    public signInService_result() {
    }

    public signInService_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public signInService_result(signInService_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public signInService_result deepCopy() {
      return new signInService_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public signInService_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof signInService_result))
        return false;
      signInService_result that = (signInService_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(signInService_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("signInService_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class signOutService_args implements TBase, java.io.Serializable, Cloneable, Comparable<signOutService_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("signOutService_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public SignOutServiceReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, SignOutServiceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(signOutService_args.class, metaDataMap);
    }

    public signOutService_args() {
    }

    public signOutService_args(
        SignOutServiceReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public signOutService_args(signOutService_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public signOutService_args deepCopy() {
      return new signOutService_args(this);
    }

    public SignOutServiceReq getReq() {
      return this.req;
    }

    public signOutService_args setReq(SignOutServiceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((SignOutServiceReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof signOutService_args))
        return false;
      signOutService_args that = (signOutService_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(signOutService_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new SignOutServiceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("signOutService_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class signOutService_result implements TBase, java.io.Serializable, Cloneable, Comparable<signOutService_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("signOutService_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(signOutService_result.class, metaDataMap);
    }

    public signOutService_result() {
    }

    public signOutService_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public signOutService_result(signOutService_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public signOutService_result deepCopy() {
      return new signOutService_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public signOutService_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof signOutService_result))
        return false;
      signOutService_result that = (signOutService_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(signOutService_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("signOutService_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listServiceClients_args implements TBase, java.io.Serializable, Cloneable, Comparable<listServiceClients_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listServiceClients_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListServiceClientsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListServiceClientsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listServiceClients_args.class, metaDataMap);
    }

    public listServiceClients_args() {
    }

    public listServiceClients_args(
        ListServiceClientsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listServiceClients_args(listServiceClients_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listServiceClients_args deepCopy() {
      return new listServiceClients_args(this);
    }

    public ListServiceClientsReq getReq() {
      return this.req;
    }

    public listServiceClients_args setReq(ListServiceClientsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListServiceClientsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listServiceClients_args))
        return false;
      listServiceClients_args that = (listServiceClients_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listServiceClients_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListServiceClientsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listServiceClients_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listServiceClients_result implements TBase, java.io.Serializable, Cloneable, Comparable<listServiceClients_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listServiceClients_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListServiceClientsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListServiceClientsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listServiceClients_result.class, metaDataMap);
    }

    public listServiceClients_result() {
    }

    public listServiceClients_result(
        ListServiceClientsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listServiceClients_result(listServiceClients_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listServiceClients_result deepCopy() {
      return new listServiceClients_result(this);
    }

    public ListServiceClientsResp getSuccess() {
      return this.success;
    }

    public listServiceClients_result setSuccess(ListServiceClientsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListServiceClientsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listServiceClients_result))
        return false;
      listServiceClients_result that = (listServiceClients_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listServiceClients_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListServiceClientsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listServiceClients_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createFTIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<createFTIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createFTIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateFTIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateFTIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createFTIndex_args.class, metaDataMap);
    }

    public createFTIndex_args() {
    }

    public createFTIndex_args(
        CreateFTIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createFTIndex_args(createFTIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createFTIndex_args deepCopy() {
      return new createFTIndex_args(this);
    }

    public CreateFTIndexReq getReq() {
      return this.req;
    }

    public createFTIndex_args setReq(CreateFTIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateFTIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createFTIndex_args))
        return false;
      createFTIndex_args that = (createFTIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createFTIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateFTIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createFTIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createFTIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<createFTIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createFTIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createFTIndex_result.class, metaDataMap);
    }

    public createFTIndex_result() {
    }

    public createFTIndex_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createFTIndex_result(createFTIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createFTIndex_result deepCopy() {
      return new createFTIndex_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public createFTIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createFTIndex_result))
        return false;
      createFTIndex_result that = (createFTIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createFTIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createFTIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropFTIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropFTIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropFTIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropFTIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropFTIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropFTIndex_args.class, metaDataMap);
    }

    public dropFTIndex_args() {
    }

    public dropFTIndex_args(
        DropFTIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropFTIndex_args(dropFTIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropFTIndex_args deepCopy() {
      return new dropFTIndex_args(this);
    }

    public DropFTIndexReq getReq() {
      return this.req;
    }

    public dropFTIndex_args setReq(DropFTIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropFTIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropFTIndex_args))
        return false;
      dropFTIndex_args that = (dropFTIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropFTIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropFTIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropFTIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropFTIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropFTIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropFTIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropFTIndex_result.class, metaDataMap);
    }

    public dropFTIndex_result() {
    }

    public dropFTIndex_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropFTIndex_result(dropFTIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropFTIndex_result deepCopy() {
      return new dropFTIndex_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropFTIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropFTIndex_result))
        return false;
      dropFTIndex_result that = (dropFTIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropFTIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropFTIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listFTIndexes_args implements TBase, java.io.Serializable, Cloneable, Comparable<listFTIndexes_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listFTIndexes_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListFTIndexesReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListFTIndexesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listFTIndexes_args.class, metaDataMap);
    }

    public listFTIndexes_args() {
    }

    public listFTIndexes_args(
        ListFTIndexesReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listFTIndexes_args(listFTIndexes_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listFTIndexes_args deepCopy() {
      return new listFTIndexes_args(this);
    }

    public ListFTIndexesReq getReq() {
      return this.req;
    }

    public listFTIndexes_args setReq(ListFTIndexesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListFTIndexesReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listFTIndexes_args))
        return false;
      listFTIndexes_args that = (listFTIndexes_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listFTIndexes_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListFTIndexesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listFTIndexes_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listFTIndexes_result implements TBase, java.io.Serializable, Cloneable, Comparable<listFTIndexes_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listFTIndexes_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListFTIndexesResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListFTIndexesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listFTIndexes_result.class, metaDataMap);
    }

    public listFTIndexes_result() {
    }

    public listFTIndexes_result(
        ListFTIndexesResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listFTIndexes_result(listFTIndexes_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listFTIndexes_result deepCopy() {
      return new listFTIndexes_result(this);
    }

    public ListFTIndexesResp getSuccess() {
      return this.success;
    }

    public listFTIndexes_result setSuccess(ListFTIndexesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListFTIndexesResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listFTIndexes_result))
        return false;
      listFTIndexes_result that = (listFTIndexes_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listFTIndexes_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListFTIndexesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listFTIndexes_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createSession_args implements TBase, java.io.Serializable, Cloneable, Comparable<createSession_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSession_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateSessionReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateSessionReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSession_args.class, metaDataMap);
    }

    public createSession_args() {
    }

    public createSession_args(
        CreateSessionReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSession_args(createSession_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createSession_args deepCopy() {
      return new createSession_args(this);
    }

    public CreateSessionReq getReq() {
      return this.req;
    }

    public createSession_args setReq(CreateSessionReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateSessionReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createSession_args))
        return false;
      createSession_args that = (createSession_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createSession_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateSessionReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSession_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createSession_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("createSession_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public CreateSessionResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateSessionResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSession_result.class, metaDataMap);
    }

    public createSession_result() {
    }

    public createSession_result(
        CreateSessionResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSession_result(createSession_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createSession_result deepCopy() {
      return new createSession_result(this);
    }

    public CreateSessionResp getSuccess() {
      return this.success;
    }

    public createSession_result setSuccess(CreateSessionResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((CreateSessionResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createSession_result))
        return false;
      createSession_result that = (createSession_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new CreateSessionResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSession_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class updateSessions_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("updateSessions_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public UpdateSessionsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, UpdateSessionsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(updateSessions_args.class, metaDataMap);
    }

    public updateSessions_args() {
    }

    public updateSessions_args(
        UpdateSessionsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public updateSessions_args(updateSessions_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public updateSessions_args deepCopy() {
      return new updateSessions_args(this);
    }

    public UpdateSessionsReq getReq() {
      return this.req;
    }

    public updateSessions_args setReq(UpdateSessionsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((UpdateSessionsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof updateSessions_args))
        return false;
      updateSessions_args that = (updateSessions_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new UpdateSessionsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("updateSessions_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class updateSessions_result implements TBase, java.io.Serializable, Cloneable, Comparable<updateSessions_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("updateSessions_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public UpdateSessionsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, UpdateSessionsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(updateSessions_result.class, metaDataMap);
    }

    public updateSessions_result() {
    }

    public updateSessions_result(
        UpdateSessionsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public updateSessions_result(updateSessions_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public updateSessions_result deepCopy() {
      return new updateSessions_result(this);
    }

    public UpdateSessionsResp getSuccess() {
      return this.success;
    }

    public updateSessions_result setSuccess(UpdateSessionsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((UpdateSessionsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof updateSessions_result))
        return false;
      updateSessions_result that = (updateSessions_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(updateSessions_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new UpdateSessionsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("updateSessions_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listSessions_args implements TBase, java.io.Serializable, Cloneable, Comparable<listSessions_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSessions_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListSessionsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSessionsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSessions_args.class, metaDataMap);
    }

    public listSessions_args() {
    }

    public listSessions_args(
        ListSessionsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSessions_args(listSessions_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listSessions_args deepCopy() {
      return new listSessions_args(this);
    }

    public ListSessionsReq getReq() {
      return this.req;
    }

    public listSessions_args setReq(ListSessionsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListSessionsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listSessions_args))
        return false;
      listSessions_args that = (listSessions_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listSessions_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListSessionsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSessions_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listSessions_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("listSessions_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListSessionsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSessionsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSessions_result.class, metaDataMap);
    }

    public listSessions_result() {
    }

    public listSessions_result(
        ListSessionsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSessions_result(listSessions_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listSessions_result deepCopy() {
      return new listSessions_result(this);
    }

    public ListSessionsResp getSuccess() {
      return this.success;
    }

    public listSessions_result setSuccess(ListSessionsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListSessionsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listSessions_result))
        return false;
      listSessions_result that = (listSessions_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListSessionsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSessions_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getSession_args implements TBase, java.io.Serializable, Cloneable, Comparable<getSession_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getSession_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetSessionReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetSessionReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getSession_args.class, metaDataMap);
    }

    public getSession_args() {
    }

    public getSession_args(
        GetSessionReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getSession_args(getSession_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getSession_args deepCopy() {
      return new getSession_args(this);
    }

    public GetSessionReq getReq() {
      return this.req;
    }

    public getSession_args setReq(GetSessionReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetSessionReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getSession_args))
        return false;
      getSession_args that = (getSession_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getSession_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetSessionReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getSession_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getSession_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getSession_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetSessionResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetSessionResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getSession_result.class, metaDataMap);
    }

    public getSession_result() {
    }

    public getSession_result(
        GetSessionResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getSession_result(getSession_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getSession_result deepCopy() {
      return new getSession_result(this);
    }

    public GetSessionResp getSuccess() {
      return this.success;
    }

    public getSession_result setSuccess(GetSessionResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetSessionResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getSession_result))
        return false;
      getSession_result that = (getSession_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetSessionResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getSession_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class removeSession_args implements TBase, java.io.Serializable, Cloneable, Comparable<removeSession_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeSession_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RemoveSessionReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RemoveSessionReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(removeSession_args.class, metaDataMap);
    }

    public removeSession_args() {
    }

    public removeSession_args(
        RemoveSessionReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeSession_args(removeSession_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public removeSession_args deepCopy() {
      return new removeSession_args(this);
    }

    public RemoveSessionReq getReq() {
      return this.req;
    }

    public removeSession_args setReq(RemoveSessionReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((RemoveSessionReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof removeSession_args))
        return false;
      removeSession_args that = (removeSession_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(removeSession_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new RemoveSessionReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("removeSession_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class removeSession_result implements TBase, java.io.Serializable, Cloneable, Comparable<removeSession_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeSession_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public RemoveSessionResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RemoveSessionResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(removeSession_result.class, metaDataMap);
    }

    public removeSession_result() {
    }

    public removeSession_result(
        RemoveSessionResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeSession_result(removeSession_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public removeSession_result deepCopy() {
      return new removeSession_result(this);
    }

    public RemoveSessionResp getSuccess() {
      return this.success;
    }

    public removeSession_result setSuccess(RemoveSessionResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((RemoveSessionResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof removeSession_result))
        return false;
      removeSession_result that = (removeSession_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(removeSession_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new RemoveSessionResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("removeSession_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class killQuery_args implements TBase, java.io.Serializable, Cloneable, Comparable<killQuery_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("killQuery_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public KillQueryReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, KillQueryReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(killQuery_args.class, metaDataMap);
    }

    public killQuery_args() {
    }

    public killQuery_args(
        KillQueryReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public killQuery_args(killQuery_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public killQuery_args deepCopy() {
      return new killQuery_args(this);
    }

    public KillQueryReq getReq() {
      return this.req;
    }

    public killQuery_args setReq(KillQueryReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((KillQueryReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof killQuery_args))
        return false;
      killQuery_args that = (killQuery_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(killQuery_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new KillQueryReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("killQuery_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class killQuery_result implements TBase, java.io.Serializable, Cloneable, Comparable<killQuery_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("killQuery_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(killQuery_result.class, metaDataMap);
    }

    public killQuery_result() {
    }

    public killQuery_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public killQuery_result(killQuery_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public killQuery_result deepCopy() {
      return new killQuery_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public killQuery_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof killQuery_result))
        return false;
      killQuery_result that = (killQuery_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(killQuery_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("killQuery_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class reportTaskFinish_args implements TBase, java.io.Serializable, Cloneable, Comparable<reportTaskFinish_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("reportTaskFinish_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ReportTaskReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ReportTaskReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(reportTaskFinish_args.class, metaDataMap);
    }

    public reportTaskFinish_args() {
    }

    public reportTaskFinish_args(
        ReportTaskReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public reportTaskFinish_args(reportTaskFinish_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public reportTaskFinish_args deepCopy() {
      return new reportTaskFinish_args(this);
    }

    public ReportTaskReq getReq() {
      return this.req;
    }

    public reportTaskFinish_args setReq(ReportTaskReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ReportTaskReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof reportTaskFinish_args))
        return false;
      reportTaskFinish_args that = (reportTaskFinish_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(reportTaskFinish_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ReportTaskReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("reportTaskFinish_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class reportTaskFinish_result implements TBase, java.io.Serializable, Cloneable, Comparable<reportTaskFinish_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("reportTaskFinish_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(reportTaskFinish_result.class, metaDataMap);
    }

    public reportTaskFinish_result() {
    }

    public reportTaskFinish_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public reportTaskFinish_result(reportTaskFinish_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public reportTaskFinish_result deepCopy() {
      return new reportTaskFinish_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public reportTaskFinish_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof reportTaskFinish_result))
        return false;
      reportTaskFinish_result that = (reportTaskFinish_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(reportTaskFinish_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("reportTaskFinish_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createBackup_args implements TBase, java.io.Serializable, Cloneable, Comparable<createBackup_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createBackup_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateBackupReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateBackupReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createBackup_args.class, metaDataMap);
    }

    public createBackup_args() {
    }

    public createBackup_args(
        CreateBackupReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createBackup_args(createBackup_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createBackup_args deepCopy() {
      return new createBackup_args(this);
    }

    public CreateBackupReq getReq() {
      return this.req;
    }

    public createBackup_args setReq(CreateBackupReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateBackupReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createBackup_args))
        return false;
      createBackup_args that = (createBackup_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createBackup_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateBackupReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createBackup_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createBackup_result implements TBase, java.io.Serializable, Cloneable, Comparable<createBackup_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createBackup_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public CreateBackupResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateBackupResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createBackup_result.class, metaDataMap);
    }

    public createBackup_result() {
    }

    public createBackup_result(
        CreateBackupResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createBackup_result(createBackup_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createBackup_result deepCopy() {
      return new createBackup_result(this);
    }

    public CreateBackupResp getSuccess() {
      return this.success;
    }

    public createBackup_result setSuccess(CreateBackupResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((CreateBackupResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createBackup_result))
        return false;
      createBackup_result that = (createBackup_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createBackup_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new CreateBackupResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createBackup_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class restoreMeta_args implements TBase, java.io.Serializable, Cloneable, Comparable<restoreMeta_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("restoreMeta_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RestoreMetaReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RestoreMetaReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(restoreMeta_args.class, metaDataMap);
    }

    public restoreMeta_args() {
    }

    public restoreMeta_args(
        RestoreMetaReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public restoreMeta_args(restoreMeta_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public restoreMeta_args deepCopy() {
      return new restoreMeta_args(this);
    }

    public RestoreMetaReq getReq() {
      return this.req;
    }

    public restoreMeta_args setReq(RestoreMetaReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((RestoreMetaReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof restoreMeta_args))
        return false;
      restoreMeta_args that = (restoreMeta_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(restoreMeta_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new RestoreMetaReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("restoreMeta_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class restoreMeta_result implements TBase, java.io.Serializable, Cloneable, Comparable<restoreMeta_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("restoreMeta_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public RestoreMetaResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RestoreMetaResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(restoreMeta_result.class, metaDataMap);
    }

    public restoreMeta_result() {
    }

    public restoreMeta_result(
        RestoreMetaResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public restoreMeta_result(restoreMeta_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public restoreMeta_result deepCopy() {
      return new restoreMeta_result(this);
    }

    public RestoreMetaResp getSuccess() {
      return this.success;
    }

    public restoreMeta_result setSuccess(RestoreMetaResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((RestoreMetaResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof restoreMeta_result))
        return false;
      restoreMeta_result that = (restoreMeta_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(restoreMeta_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new RestoreMetaResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("restoreMeta_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listCluster_args implements TBase, java.io.Serializable, Cloneable, Comparable<listCluster_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listCluster_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListClusterInfoReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListClusterInfoReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listCluster_args.class, metaDataMap);
    }

    public listCluster_args() {
    }

    public listCluster_args(
        ListClusterInfoReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listCluster_args(listCluster_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listCluster_args deepCopy() {
      return new listCluster_args(this);
    }

    public ListClusterInfoReq getReq() {
      return this.req;
    }

    public listCluster_args setReq(ListClusterInfoReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListClusterInfoReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listCluster_args))
        return false;
      listCluster_args that = (listCluster_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listCluster_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListClusterInfoReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listCluster_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listCluster_result implements TBase, java.io.Serializable, Cloneable, Comparable<listCluster_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listCluster_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListClusterInfoResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListClusterInfoResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listCluster_result.class, metaDataMap);
    }

    public listCluster_result() {
    }

    public listCluster_result(
        ListClusterInfoResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listCluster_result(listCluster_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listCluster_result deepCopy() {
      return new listCluster_result(this);
    }

    public ListClusterInfoResp getSuccess() {
      return this.success;
    }

    public listCluster_result setSuccess(ListClusterInfoResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListClusterInfoResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listCluster_result))
        return false;
      listCluster_result that = (listCluster_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listCluster_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListClusterInfoResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listCluster_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getMetaDirInfo_args implements TBase, java.io.Serializable, Cloneable, Comparable<getMetaDirInfo_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getMetaDirInfo_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetMetaDirInfoReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetMetaDirInfoReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getMetaDirInfo_args.class, metaDataMap);
    }

    public getMetaDirInfo_args() {
    }

    public getMetaDirInfo_args(
        GetMetaDirInfoReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getMetaDirInfo_args(getMetaDirInfo_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getMetaDirInfo_args deepCopy() {
      return new getMetaDirInfo_args(this);
    }

    public GetMetaDirInfoReq getReq() {
      return this.req;
    }

    public getMetaDirInfo_args setReq(GetMetaDirInfoReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetMetaDirInfoReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getMetaDirInfo_args))
        return false;
      getMetaDirInfo_args that = (getMetaDirInfo_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getMetaDirInfo_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetMetaDirInfoReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getMetaDirInfo_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getMetaDirInfo_result implements TBase, java.io.Serializable, Cloneable, Comparable<getMetaDirInfo_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getMetaDirInfo_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetMetaDirInfoResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetMetaDirInfoResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getMetaDirInfo_result.class, metaDataMap);
    }

    public getMetaDirInfo_result() {
    }

    public getMetaDirInfo_result(
        GetMetaDirInfoResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getMetaDirInfo_result(getMetaDirInfo_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getMetaDirInfo_result deepCopy() {
      return new getMetaDirInfo_result(this);
    }

    public GetMetaDirInfoResp getSuccess() {
      return this.success;
    }

    public getMetaDirInfo_result setSuccess(GetMetaDirInfoResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetMetaDirInfoResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getMetaDirInfo_result))
        return false;
      getMetaDirInfo_result that = (getMetaDirInfo_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getMetaDirInfo_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetMetaDirInfoResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getMetaDirInfo_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class verifyClientVersion_args implements TBase, java.io.Serializable, Cloneable, Comparable<verifyClientVersion_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("verifyClientVersion_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public VerifyClientVersionReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, VerifyClientVersionReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(verifyClientVersion_args.class, metaDataMap);
    }

    public verifyClientVersion_args() {
    }

    public verifyClientVersion_args(
        VerifyClientVersionReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public verifyClientVersion_args(verifyClientVersion_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public verifyClientVersion_args deepCopy() {
      return new verifyClientVersion_args(this);
    }

    public VerifyClientVersionReq getReq() {
      return this.req;
    }

    public verifyClientVersion_args setReq(VerifyClientVersionReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((VerifyClientVersionReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof verifyClientVersion_args))
        return false;
      verifyClientVersion_args that = (verifyClientVersion_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(verifyClientVersion_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new VerifyClientVersionReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("verifyClientVersion_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class verifyClientVersion_result implements TBase, java.io.Serializable, Cloneable, Comparable<verifyClientVersion_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("verifyClientVersion_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public VerifyClientVersionResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, VerifyClientVersionResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(verifyClientVersion_result.class, metaDataMap);
    }

    public verifyClientVersion_result() {
    }

    public verifyClientVersion_result(
        VerifyClientVersionResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public verifyClientVersion_result(verifyClientVersion_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public verifyClientVersion_result deepCopy() {
      return new verifyClientVersion_result(this);
    }

    public VerifyClientVersionResp getSuccess() {
      return this.success;
    }

    public verifyClientVersion_result setSuccess(VerifyClientVersionResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((VerifyClientVersionResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof verifyClientVersion_result))
        return false;
      verifyClientVersion_result that = (verifyClientVersion_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(verifyClientVersion_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new VerifyClientVersionResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("verifyClientVersion_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class saveGraphVersion_args implements TBase, java.io.Serializable, Cloneable, Comparable<saveGraphVersion_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("saveGraphVersion_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public SaveGraphVersionReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, SaveGraphVersionReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(saveGraphVersion_args.class, metaDataMap);
    }

    public saveGraphVersion_args() {
    }

    public saveGraphVersion_args(
        SaveGraphVersionReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public saveGraphVersion_args(saveGraphVersion_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public saveGraphVersion_args deepCopy() {
      return new saveGraphVersion_args(this);
    }

    public SaveGraphVersionReq getReq() {
      return this.req;
    }

    public saveGraphVersion_args setReq(SaveGraphVersionReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((SaveGraphVersionReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof saveGraphVersion_args))
        return false;
      saveGraphVersion_args that = (saveGraphVersion_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(saveGraphVersion_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new SaveGraphVersionReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("saveGraphVersion_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class saveGraphVersion_result implements TBase, java.io.Serializable, Cloneable, Comparable<saveGraphVersion_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("saveGraphVersion_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public SaveGraphVersionResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, SaveGraphVersionResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(saveGraphVersion_result.class, metaDataMap);
    }

    public saveGraphVersion_result() {
    }

    public saveGraphVersion_result(
        SaveGraphVersionResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public saveGraphVersion_result(saveGraphVersion_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public saveGraphVersion_result deepCopy() {
      return new saveGraphVersion_result(this);
    }

    public SaveGraphVersionResp getSuccess() {
      return this.success;
    }

    public saveGraphVersion_result setSuccess(SaveGraphVersionResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((SaveGraphVersionResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof saveGraphVersion_result))
        return false;
      saveGraphVersion_result that = (saveGraphVersion_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(saveGraphVersion_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new SaveGraphVersionResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("saveGraphVersion_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getSegmentId_args implements TBase, java.io.Serializable, Cloneable, Comparable<getSegmentId_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getSegmentId_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetSegmentIdReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetSegmentIdReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getSegmentId_args.class, metaDataMap);
    }

    public getSegmentId_args() {
    }

    public getSegmentId_args(
        GetSegmentIdReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getSegmentId_args(getSegmentId_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getSegmentId_args deepCopy() {
      return new getSegmentId_args(this);
    }

    public GetSegmentIdReq getReq() {
      return this.req;
    }

    public getSegmentId_args setReq(GetSegmentIdReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetSegmentIdReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getSegmentId_args))
        return false;
      getSegmentId_args that = (getSegmentId_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getSegmentId_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetSegmentIdReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getSegmentId_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getSegmentId_result implements TBase, java.io.Serializable, Cloneable, Comparable<getSegmentId_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getSegmentId_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetSegmentIdResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetSegmentIdResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getSegmentId_result.class, metaDataMap);
    }

    public getSegmentId_result() {
    }

    public getSegmentId_result(
        GetSegmentIdResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getSegmentId_result(getSegmentId_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getSegmentId_result deepCopy() {
      return new getSegmentId_result(this);
    }

    public GetSegmentIdResp getSuccess() {
      return this.success;
    }

    public getSegmentId_result setSuccess(GetSegmentIdResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetSegmentIdResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getSegmentId_result))
        return false;
      getSegmentId_result that = (getSegmentId_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getSegmentId_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetSegmentIdResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getSegmentId_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

}
