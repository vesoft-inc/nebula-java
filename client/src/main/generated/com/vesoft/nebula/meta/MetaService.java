/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package com.vesoft.nebula.meta;

import org.apache.commons.lang.builder.HashCodeBuilder;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import java.util.BitSet;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.facebook.thrift.*;
import com.facebook.thrift.async.*;
import com.facebook.thrift.meta_data.*;
import com.facebook.thrift.server.*;
import com.facebook.thrift.transport.*;
import com.facebook.thrift.protocol.*;

@SuppressWarnings({ "unused", "serial" })
public class MetaService {

  public interface Iface {

    public ExecResp createSpace(CreateSpaceReq req) throws TException;

    public ExecResp dropSpace(DropSpaceReq req) throws TException;

    public GetSpaceResp getSpace(GetSpaceReq req) throws TException;

    public ListSpacesResp listSpaces(ListSpacesReq req) throws TException;

    public ExecResp createTag(CreateTagReq req) throws TException;

    public ExecResp alterTag(AlterTagReq req) throws TException;

    public ExecResp dropTag(DropTagReq req) throws TException;

    public GetTagResp getTag(GetTagReq req) throws TException;

    public ListTagsResp listTags(ListTagsReq req) throws TException;

    public ExecResp createEdge(CreateEdgeReq req) throws TException;

    public ExecResp alterEdge(AlterEdgeReq req) throws TException;

    public ExecResp dropEdge(DropEdgeReq req) throws TException;

    public GetEdgeResp getEdge(GetEdgeReq req) throws TException;

    public ListEdgesResp listEdges(ListEdgesReq req) throws TException;

    public ListHostsResp listHosts(ListHostsReq req) throws TException;

    public GetPartsAllocResp getPartsAlloc(GetPartsAllocReq req) throws TException;

    public ListPartsResp listParts(ListPartsReq req) throws TException;

    public ExecResp multiPut(MultiPutReq req) throws TException;

    public GetResp get(GetReq req) throws TException;

    public MultiGetResp multiGet(MultiGetReq req) throws TException;

    public ExecResp remove(RemoveReq req) throws TException;

    public ExecResp removeRange(RemoveRangeReq req) throws TException;

    public ScanResp scan(ScanReq req) throws TException;

    public ExecResp createTagIndex(CreateTagIndexReq req) throws TException;

    public ExecResp dropTagIndex(DropTagIndexReq req) throws TException;

    public GetTagIndexResp getTagIndex(GetTagIndexReq req) throws TException;

    public ListTagIndexesResp listTagIndexes(ListTagIndexesReq req) throws TException;

    public ExecResp createEdgeIndex(CreateEdgeIndexReq req) throws TException;

    public ExecResp dropEdgeIndex(DropEdgeIndexReq req) throws TException;

    public GetEdgeIndexResp getEdgeIndex(GetEdgeIndexReq req) throws TException;

    public ListEdgeIndexesResp listEdgeIndexes(ListEdgeIndexesReq req) throws TException;

    public ExecResp createUser(CreateUserReq req) throws TException;

    public ExecResp dropUser(DropUserReq req) throws TException;

    public ExecResp alterUser(AlterUserReq req) throws TException;

    public ExecResp grantRole(GrantRoleReq req) throws TException;

    public ExecResp revokeRole(RevokeRoleReq req) throws TException;

    public GetUserResp getUser(GetUserReq req) throws TException;

    public ListUsersResp listUsers(ListUsersReq req) throws TException;

    public ListRolesResp listRoles(ListRolesReq req) throws TException;

    public ExecResp changePassword(ChangePasswordReq req) throws TException;

    public ExecResp checkPassword(CheckPasswordReq req) throws TException;

    public HBResp heartBeat(HBReq req) throws TException;

    public BalanceResp balance(BalanceReq req) throws TException;

    public ExecResp leaderBalance(LeaderBalanceReq req) throws TException;

    public ExecResp regConfig(RegConfigReq req) throws TException;

    public GetConfigResp getConfig(GetConfigReq req) throws TException;

    public ExecResp setConfig(SetConfigReq req) throws TException;

    public ListConfigsResp listConfigs(ListConfigsReq req) throws TException;

    public ExecResp createSnapshot(CreateSnapshotReq req) throws TException;

    public ExecResp dropSnapshot(DropSnapshotReq req) throws TException;

    public ListSnapshotsResp listSnapshots(ListSnapshotsReq req) throws TException;

    public AdminJobResp runAdminJob(AdminJobReq req) throws TException;

  }

  public interface AsyncIface {

    public void createSpace(CreateSpaceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropSpace(DropSpaceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getSpace(GetSpaceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listSpaces(ListSpacesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createTag(CreateTagReq req, AsyncMethodCallback resultHandler) throws TException;

    public void alterTag(AlterTagReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropTag(DropTagReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getTag(GetTagReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listTags(ListTagsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createEdge(CreateEdgeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void alterEdge(AlterEdgeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropEdge(DropEdgeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getEdge(GetEdgeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listEdges(ListEdgesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listHosts(ListHostsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getPartsAlloc(GetPartsAllocReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listParts(ListPartsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void multiPut(MultiPutReq req, AsyncMethodCallback resultHandler) throws TException;

    public void get(GetReq req, AsyncMethodCallback resultHandler) throws TException;

    public void multiGet(MultiGetReq req, AsyncMethodCallback resultHandler) throws TException;

    public void remove(RemoveReq req, AsyncMethodCallback resultHandler) throws TException;

    public void removeRange(RemoveRangeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void scan(ScanReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createTagIndex(CreateTagIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropTagIndex(DropTagIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getTagIndex(GetTagIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listTagIndexes(ListTagIndexesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createEdgeIndex(CreateEdgeIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropEdgeIndex(DropEdgeIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getEdgeIndex(GetEdgeIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listEdgeIndexes(ListEdgeIndexesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createUser(CreateUserReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropUser(DropUserReq req, AsyncMethodCallback resultHandler) throws TException;

    public void alterUser(AlterUserReq req, AsyncMethodCallback resultHandler) throws TException;

    public void grantRole(GrantRoleReq req, AsyncMethodCallback resultHandler) throws TException;

    public void revokeRole(RevokeRoleReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getUser(GetUserReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listUsers(ListUsersReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listRoles(ListRolesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void changePassword(ChangePasswordReq req, AsyncMethodCallback resultHandler) throws TException;

    public void checkPassword(CheckPasswordReq req, AsyncMethodCallback resultHandler) throws TException;

    public void heartBeat(HBReq req, AsyncMethodCallback resultHandler) throws TException;

    public void balance(BalanceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void leaderBalance(LeaderBalanceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void regConfig(RegConfigReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getConfig(GetConfigReq req, AsyncMethodCallback resultHandler) throws TException;

    public void setConfig(SetConfigReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listConfigs(ListConfigsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createSnapshot(CreateSnapshotReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropSnapshot(DropSnapshotReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listSnapshots(ListSnapshotsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void runAdminJob(AdminJobReq req, AsyncMethodCallback resultHandler) throws TException;

  }

  public static class Client extends EventHandlerBase implements Iface, TClientIf {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    @Override
    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    @Override
    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public ExecResp createSpace(CreateSpaceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createSpace", null);
      this.setContextStack(ctx);
      send_createSpace(req);
      return recv_createSpace();
    }

    public void send_createSpace(CreateSpaceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createSpace", null);
      oprot_.writeMessageBegin(new TMessage("createSpace", TMessageType.CALL, seqid_));
      createSpace_args args = new createSpace_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createSpace", args);
      return;
    }

    public ExecResp recv_createSpace() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createSpace");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createSpace_result result = new createSpace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createSpace", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createSpace failed: unknown result");
    }

    public ExecResp dropSpace(DropSpaceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropSpace", null);
      this.setContextStack(ctx);
      send_dropSpace(req);
      return recv_dropSpace();
    }

    public void send_dropSpace(DropSpaceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropSpace", null);
      oprot_.writeMessageBegin(new TMessage("dropSpace", TMessageType.CALL, seqid_));
      dropSpace_args args = new dropSpace_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropSpace", args);
      return;
    }

    public ExecResp recv_dropSpace() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropSpace");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropSpace_result result = new dropSpace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropSpace", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropSpace failed: unknown result");
    }

    public GetSpaceResp getSpace(GetSpaceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getSpace", null);
      this.setContextStack(ctx);
      send_getSpace(req);
      return recv_getSpace();
    }

    public void send_getSpace(GetSpaceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getSpace", null);
      oprot_.writeMessageBegin(new TMessage("getSpace", TMessageType.CALL, seqid_));
      getSpace_args args = new getSpace_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getSpace", args);
      return;
    }

    public GetSpaceResp recv_getSpace() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getSpace");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getSpace_result result = new getSpace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getSpace", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getSpace failed: unknown result");
    }

    public ListSpacesResp listSpaces(ListSpacesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listSpaces", null);
      this.setContextStack(ctx);
      send_listSpaces(req);
      return recv_listSpaces();
    }

    public void send_listSpaces(ListSpacesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listSpaces", null);
      oprot_.writeMessageBegin(new TMessage("listSpaces", TMessageType.CALL, seqid_));
      listSpaces_args args = new listSpaces_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listSpaces", args);
      return;
    }

    public ListSpacesResp recv_listSpaces() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listSpaces");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listSpaces_result result = new listSpaces_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listSpaces", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listSpaces failed: unknown result");
    }

    public ExecResp createTag(CreateTagReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createTag", null);
      this.setContextStack(ctx);
      send_createTag(req);
      return recv_createTag();
    }

    public void send_createTag(CreateTagReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createTag", null);
      oprot_.writeMessageBegin(new TMessage("createTag", TMessageType.CALL, seqid_));
      createTag_args args = new createTag_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createTag", args);
      return;
    }

    public ExecResp recv_createTag() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createTag");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createTag_result result = new createTag_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createTag", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createTag failed: unknown result");
    }

    public ExecResp alterTag(AlterTagReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.alterTag", null);
      this.setContextStack(ctx);
      send_alterTag(req);
      return recv_alterTag();
    }

    public void send_alterTag(AlterTagReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.alterTag", null);
      oprot_.writeMessageBegin(new TMessage("alterTag", TMessageType.CALL, seqid_));
      alterTag_args args = new alterTag_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.alterTag", args);
      return;
    }

    public ExecResp recv_alterTag() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.alterTag");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      alterTag_result result = new alterTag_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.alterTag", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "alterTag failed: unknown result");
    }

    public ExecResp dropTag(DropTagReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropTag", null);
      this.setContextStack(ctx);
      send_dropTag(req);
      return recv_dropTag();
    }

    public void send_dropTag(DropTagReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropTag", null);
      oprot_.writeMessageBegin(new TMessage("dropTag", TMessageType.CALL, seqid_));
      dropTag_args args = new dropTag_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropTag", args);
      return;
    }

    public ExecResp recv_dropTag() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropTag");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropTag_result result = new dropTag_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropTag", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropTag failed: unknown result");
    }

    public GetTagResp getTag(GetTagReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getTag", null);
      this.setContextStack(ctx);
      send_getTag(req);
      return recv_getTag();
    }

    public void send_getTag(GetTagReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getTag", null);
      oprot_.writeMessageBegin(new TMessage("getTag", TMessageType.CALL, seqid_));
      getTag_args args = new getTag_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getTag", args);
      return;
    }

    public GetTagResp recv_getTag() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getTag");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getTag_result result = new getTag_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getTag", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTag failed: unknown result");
    }

    public ListTagsResp listTags(ListTagsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listTags", null);
      this.setContextStack(ctx);
      send_listTags(req);
      return recv_listTags();
    }

    public void send_listTags(ListTagsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listTags", null);
      oprot_.writeMessageBegin(new TMessage("listTags", TMessageType.CALL, seqid_));
      listTags_args args = new listTags_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listTags", args);
      return;
    }

    public ListTagsResp recv_listTags() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listTags");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listTags_result result = new listTags_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listTags", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listTags failed: unknown result");
    }

    public ExecResp createEdge(CreateEdgeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createEdge", null);
      this.setContextStack(ctx);
      send_createEdge(req);
      return recv_createEdge();
    }

    public void send_createEdge(CreateEdgeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createEdge", null);
      oprot_.writeMessageBegin(new TMessage("createEdge", TMessageType.CALL, seqid_));
      createEdge_args args = new createEdge_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createEdge", args);
      return;
    }

    public ExecResp recv_createEdge() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createEdge");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createEdge_result result = new createEdge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createEdge", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createEdge failed: unknown result");
    }

    public ExecResp alterEdge(AlterEdgeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.alterEdge", null);
      this.setContextStack(ctx);
      send_alterEdge(req);
      return recv_alterEdge();
    }

    public void send_alterEdge(AlterEdgeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.alterEdge", null);
      oprot_.writeMessageBegin(new TMessage("alterEdge", TMessageType.CALL, seqid_));
      alterEdge_args args = new alterEdge_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.alterEdge", args);
      return;
    }

    public ExecResp recv_alterEdge() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.alterEdge");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      alterEdge_result result = new alterEdge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.alterEdge", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "alterEdge failed: unknown result");
    }

    public ExecResp dropEdge(DropEdgeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropEdge", null);
      this.setContextStack(ctx);
      send_dropEdge(req);
      return recv_dropEdge();
    }

    public void send_dropEdge(DropEdgeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropEdge", null);
      oprot_.writeMessageBegin(new TMessage("dropEdge", TMessageType.CALL, seqid_));
      dropEdge_args args = new dropEdge_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropEdge", args);
      return;
    }

    public ExecResp recv_dropEdge() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropEdge");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropEdge_result result = new dropEdge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropEdge", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropEdge failed: unknown result");
    }

    public GetEdgeResp getEdge(GetEdgeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getEdge", null);
      this.setContextStack(ctx);
      send_getEdge(req);
      return recv_getEdge();
    }

    public void send_getEdge(GetEdgeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getEdge", null);
      oprot_.writeMessageBegin(new TMessage("getEdge", TMessageType.CALL, seqid_));
      getEdge_args args = new getEdge_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getEdge", args);
      return;
    }

    public GetEdgeResp recv_getEdge() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getEdge");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getEdge_result result = new getEdge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getEdge", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getEdge failed: unknown result");
    }

    public ListEdgesResp listEdges(ListEdgesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listEdges", null);
      this.setContextStack(ctx);
      send_listEdges(req);
      return recv_listEdges();
    }

    public void send_listEdges(ListEdgesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listEdges", null);
      oprot_.writeMessageBegin(new TMessage("listEdges", TMessageType.CALL, seqid_));
      listEdges_args args = new listEdges_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listEdges", args);
      return;
    }

    public ListEdgesResp recv_listEdges() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listEdges");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listEdges_result result = new listEdges_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listEdges", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listEdges failed: unknown result");
    }

    public ListHostsResp listHosts(ListHostsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listHosts", null);
      this.setContextStack(ctx);
      send_listHosts(req);
      return recv_listHosts();
    }

    public void send_listHosts(ListHostsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listHosts", null);
      oprot_.writeMessageBegin(new TMessage("listHosts", TMessageType.CALL, seqid_));
      listHosts_args args = new listHosts_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listHosts", args);
      return;
    }

    public ListHostsResp recv_listHosts() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listHosts");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listHosts_result result = new listHosts_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listHosts", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listHosts failed: unknown result");
    }

    public GetPartsAllocResp getPartsAlloc(GetPartsAllocReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getPartsAlloc", null);
      this.setContextStack(ctx);
      send_getPartsAlloc(req);
      return recv_getPartsAlloc();
    }

    public void send_getPartsAlloc(GetPartsAllocReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getPartsAlloc", null);
      oprot_.writeMessageBegin(new TMessage("getPartsAlloc", TMessageType.CALL, seqid_));
      getPartsAlloc_args args = new getPartsAlloc_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getPartsAlloc", args);
      return;
    }

    public GetPartsAllocResp recv_getPartsAlloc() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getPartsAlloc");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getPartsAlloc_result result = new getPartsAlloc_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getPartsAlloc", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getPartsAlloc failed: unknown result");
    }

    public ListPartsResp listParts(ListPartsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listParts", null);
      this.setContextStack(ctx);
      send_listParts(req);
      return recv_listParts();
    }

    public void send_listParts(ListPartsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listParts", null);
      oprot_.writeMessageBegin(new TMessage("listParts", TMessageType.CALL, seqid_));
      listParts_args args = new listParts_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listParts", args);
      return;
    }

    public ListPartsResp recv_listParts() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listParts");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listParts_result result = new listParts_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listParts", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listParts failed: unknown result");
    }

    public ExecResp multiPut(MultiPutReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.multiPut", null);
      this.setContextStack(ctx);
      send_multiPut(req);
      return recv_multiPut();
    }

    public void send_multiPut(MultiPutReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.multiPut", null);
      oprot_.writeMessageBegin(new TMessage("multiPut", TMessageType.CALL, seqid_));
      multiPut_args args = new multiPut_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.multiPut", args);
      return;
    }

    public ExecResp recv_multiPut() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.multiPut");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      multiPut_result result = new multiPut_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.multiPut", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiPut failed: unknown result");
    }

    public GetResp get(GetReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.get", null);
      this.setContextStack(ctx);
      send_get(req);
      return recv_get();
    }

    public void send_get(GetReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.get", null);
      oprot_.writeMessageBegin(new TMessage("get", TMessageType.CALL, seqid_));
      get_args args = new get_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.get", args);
      return;
    }

    public GetResp recv_get() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.get");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_result result = new get_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.get", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result");
    }

    public MultiGetResp multiGet(MultiGetReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.multiGet", null);
      this.setContextStack(ctx);
      send_multiGet(req);
      return recv_multiGet();
    }

    public void send_multiGet(MultiGetReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.multiGet", null);
      oprot_.writeMessageBegin(new TMessage("multiGet", TMessageType.CALL, seqid_));
      multiGet_args args = new multiGet_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.multiGet", args);
      return;
    }

    public MultiGetResp recv_multiGet() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.multiGet");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      multiGet_result result = new multiGet_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.multiGet", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiGet failed: unknown result");
    }

    public ExecResp remove(RemoveReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.remove", null);
      this.setContextStack(ctx);
      send_remove(req);
      return recv_remove();
    }

    public void send_remove(RemoveReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.remove", null);
      oprot_.writeMessageBegin(new TMessage("remove", TMessageType.CALL, seqid_));
      remove_args args = new remove_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.remove", args);
      return;
    }

    public ExecResp recv_remove() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.remove");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      remove_result result = new remove_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.remove", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "remove failed: unknown result");
    }

    public ExecResp removeRange(RemoveRangeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.removeRange", null);
      this.setContextStack(ctx);
      send_removeRange(req);
      return recv_removeRange();
    }

    public void send_removeRange(RemoveRangeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.removeRange", null);
      oprot_.writeMessageBegin(new TMessage("removeRange", TMessageType.CALL, seqid_));
      removeRange_args args = new removeRange_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.removeRange", args);
      return;
    }

    public ExecResp recv_removeRange() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.removeRange");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      removeRange_result result = new removeRange_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.removeRange", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "removeRange failed: unknown result");
    }

    public ScanResp scan(ScanReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.scan", null);
      this.setContextStack(ctx);
      send_scan(req);
      return recv_scan();
    }

    public void send_scan(ScanReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.scan", null);
      oprot_.writeMessageBegin(new TMessage("scan", TMessageType.CALL, seqid_));
      scan_args args = new scan_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.scan", args);
      return;
    }

    public ScanResp recv_scan() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.scan");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      scan_result result = new scan_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.scan", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "scan failed: unknown result");
    }

    public ExecResp createTagIndex(CreateTagIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createTagIndex", null);
      this.setContextStack(ctx);
      send_createTagIndex(req);
      return recv_createTagIndex();
    }

    public void send_createTagIndex(CreateTagIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createTagIndex", null);
      oprot_.writeMessageBegin(new TMessage("createTagIndex", TMessageType.CALL, seqid_));
      createTagIndex_args args = new createTagIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createTagIndex", args);
      return;
    }

    public ExecResp recv_createTagIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createTagIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createTagIndex_result result = new createTagIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createTagIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createTagIndex failed: unknown result");
    }

    public ExecResp dropTagIndex(DropTagIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropTagIndex", null);
      this.setContextStack(ctx);
      send_dropTagIndex(req);
      return recv_dropTagIndex();
    }

    public void send_dropTagIndex(DropTagIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropTagIndex", null);
      oprot_.writeMessageBegin(new TMessage("dropTagIndex", TMessageType.CALL, seqid_));
      dropTagIndex_args args = new dropTagIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropTagIndex", args);
      return;
    }

    public ExecResp recv_dropTagIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropTagIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropTagIndex_result result = new dropTagIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropTagIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropTagIndex failed: unknown result");
    }

    public GetTagIndexResp getTagIndex(GetTagIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getTagIndex", null);
      this.setContextStack(ctx);
      send_getTagIndex(req);
      return recv_getTagIndex();
    }

    public void send_getTagIndex(GetTagIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getTagIndex", null);
      oprot_.writeMessageBegin(new TMessage("getTagIndex", TMessageType.CALL, seqid_));
      getTagIndex_args args = new getTagIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getTagIndex", args);
      return;
    }

    public GetTagIndexResp recv_getTagIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getTagIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getTagIndex_result result = new getTagIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getTagIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTagIndex failed: unknown result");
    }

    public ListTagIndexesResp listTagIndexes(ListTagIndexesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listTagIndexes", null);
      this.setContextStack(ctx);
      send_listTagIndexes(req);
      return recv_listTagIndexes();
    }

    public void send_listTagIndexes(ListTagIndexesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listTagIndexes", null);
      oprot_.writeMessageBegin(new TMessage("listTagIndexes", TMessageType.CALL, seqid_));
      listTagIndexes_args args = new listTagIndexes_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listTagIndexes", args);
      return;
    }

    public ListTagIndexesResp recv_listTagIndexes() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listTagIndexes");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listTagIndexes_result result = new listTagIndexes_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listTagIndexes", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listTagIndexes failed: unknown result");
    }

    public ExecResp createEdgeIndex(CreateEdgeIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createEdgeIndex", null);
      this.setContextStack(ctx);
      send_createEdgeIndex(req);
      return recv_createEdgeIndex();
    }

    public void send_createEdgeIndex(CreateEdgeIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createEdgeIndex", null);
      oprot_.writeMessageBegin(new TMessage("createEdgeIndex", TMessageType.CALL, seqid_));
      createEdgeIndex_args args = new createEdgeIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createEdgeIndex", args);
      return;
    }

    public ExecResp recv_createEdgeIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createEdgeIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createEdgeIndex_result result = new createEdgeIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createEdgeIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createEdgeIndex failed: unknown result");
    }

    public ExecResp dropEdgeIndex(DropEdgeIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropEdgeIndex", null);
      this.setContextStack(ctx);
      send_dropEdgeIndex(req);
      return recv_dropEdgeIndex();
    }

    public void send_dropEdgeIndex(DropEdgeIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropEdgeIndex", null);
      oprot_.writeMessageBegin(new TMessage("dropEdgeIndex", TMessageType.CALL, seqid_));
      dropEdgeIndex_args args = new dropEdgeIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropEdgeIndex", args);
      return;
    }

    public ExecResp recv_dropEdgeIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropEdgeIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropEdgeIndex_result result = new dropEdgeIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropEdgeIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropEdgeIndex failed: unknown result");
    }

    public GetEdgeIndexResp getEdgeIndex(GetEdgeIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getEdgeIndex", null);
      this.setContextStack(ctx);
      send_getEdgeIndex(req);
      return recv_getEdgeIndex();
    }

    public void send_getEdgeIndex(GetEdgeIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getEdgeIndex", null);
      oprot_.writeMessageBegin(new TMessage("getEdgeIndex", TMessageType.CALL, seqid_));
      getEdgeIndex_args args = new getEdgeIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getEdgeIndex", args);
      return;
    }

    public GetEdgeIndexResp recv_getEdgeIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getEdgeIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getEdgeIndex_result result = new getEdgeIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getEdgeIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getEdgeIndex failed: unknown result");
    }

    public ListEdgeIndexesResp listEdgeIndexes(ListEdgeIndexesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listEdgeIndexes", null);
      this.setContextStack(ctx);
      send_listEdgeIndexes(req);
      return recv_listEdgeIndexes();
    }

    public void send_listEdgeIndexes(ListEdgeIndexesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listEdgeIndexes", null);
      oprot_.writeMessageBegin(new TMessage("listEdgeIndexes", TMessageType.CALL, seqid_));
      listEdgeIndexes_args args = new listEdgeIndexes_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listEdgeIndexes", args);
      return;
    }

    public ListEdgeIndexesResp recv_listEdgeIndexes() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listEdgeIndexes");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listEdgeIndexes_result result = new listEdgeIndexes_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listEdgeIndexes", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listEdgeIndexes failed: unknown result");
    }

    public ExecResp createUser(CreateUserReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createUser", null);
      this.setContextStack(ctx);
      send_createUser(req);
      return recv_createUser();
    }

    public void send_createUser(CreateUserReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createUser", null);
      oprot_.writeMessageBegin(new TMessage("createUser", TMessageType.CALL, seqid_));
      createUser_args args = new createUser_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createUser", args);
      return;
    }

    public ExecResp recv_createUser() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createUser");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createUser_result result = new createUser_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createUser", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createUser failed: unknown result");
    }

    public ExecResp dropUser(DropUserReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropUser", null);
      this.setContextStack(ctx);
      send_dropUser(req);
      return recv_dropUser();
    }

    public void send_dropUser(DropUserReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropUser", null);
      oprot_.writeMessageBegin(new TMessage("dropUser", TMessageType.CALL, seqid_));
      dropUser_args args = new dropUser_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropUser", args);
      return;
    }

    public ExecResp recv_dropUser() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropUser");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropUser_result result = new dropUser_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropUser", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropUser failed: unknown result");
    }

    public ExecResp alterUser(AlterUserReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.alterUser", null);
      this.setContextStack(ctx);
      send_alterUser(req);
      return recv_alterUser();
    }

    public void send_alterUser(AlterUserReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.alterUser", null);
      oprot_.writeMessageBegin(new TMessage("alterUser", TMessageType.CALL, seqid_));
      alterUser_args args = new alterUser_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.alterUser", args);
      return;
    }

    public ExecResp recv_alterUser() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.alterUser");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      alterUser_result result = new alterUser_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.alterUser", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "alterUser failed: unknown result");
    }

    public ExecResp grantRole(GrantRoleReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.grantRole", null);
      this.setContextStack(ctx);
      send_grantRole(req);
      return recv_grantRole();
    }

    public void send_grantRole(GrantRoleReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.grantRole", null);
      oprot_.writeMessageBegin(new TMessage("grantRole", TMessageType.CALL, seqid_));
      grantRole_args args = new grantRole_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.grantRole", args);
      return;
    }

    public ExecResp recv_grantRole() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.grantRole");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      grantRole_result result = new grantRole_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.grantRole", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "grantRole failed: unknown result");
    }

    public ExecResp revokeRole(RevokeRoleReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.revokeRole", null);
      this.setContextStack(ctx);
      send_revokeRole(req);
      return recv_revokeRole();
    }

    public void send_revokeRole(RevokeRoleReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.revokeRole", null);
      oprot_.writeMessageBegin(new TMessage("revokeRole", TMessageType.CALL, seqid_));
      revokeRole_args args = new revokeRole_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.revokeRole", args);
      return;
    }

    public ExecResp recv_revokeRole() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.revokeRole");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      revokeRole_result result = new revokeRole_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.revokeRole", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "revokeRole failed: unknown result");
    }

    public GetUserResp getUser(GetUserReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getUser", null);
      this.setContextStack(ctx);
      send_getUser(req);
      return recv_getUser();
    }

    public void send_getUser(GetUserReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getUser", null);
      oprot_.writeMessageBegin(new TMessage("getUser", TMessageType.CALL, seqid_));
      getUser_args args = new getUser_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getUser", args);
      return;
    }

    public GetUserResp recv_getUser() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getUser");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getUser_result result = new getUser_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getUser", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getUser failed: unknown result");
    }

    public ListUsersResp listUsers(ListUsersReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listUsers", null);
      this.setContextStack(ctx);
      send_listUsers(req);
      return recv_listUsers();
    }

    public void send_listUsers(ListUsersReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listUsers", null);
      oprot_.writeMessageBegin(new TMessage("listUsers", TMessageType.CALL, seqid_));
      listUsers_args args = new listUsers_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listUsers", args);
      return;
    }

    public ListUsersResp recv_listUsers() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listUsers");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listUsers_result result = new listUsers_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listUsers", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listUsers failed: unknown result");
    }

    public ListRolesResp listRoles(ListRolesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listRoles", null);
      this.setContextStack(ctx);
      send_listRoles(req);
      return recv_listRoles();
    }

    public void send_listRoles(ListRolesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listRoles", null);
      oprot_.writeMessageBegin(new TMessage("listRoles", TMessageType.CALL, seqid_));
      listRoles_args args = new listRoles_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listRoles", args);
      return;
    }

    public ListRolesResp recv_listRoles() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listRoles");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listRoles_result result = new listRoles_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listRoles", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listRoles failed: unknown result");
    }

    public ExecResp changePassword(ChangePasswordReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.changePassword", null);
      this.setContextStack(ctx);
      send_changePassword(req);
      return recv_changePassword();
    }

    public void send_changePassword(ChangePasswordReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.changePassword", null);
      oprot_.writeMessageBegin(new TMessage("changePassword", TMessageType.CALL, seqid_));
      changePassword_args args = new changePassword_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.changePassword", args);
      return;
    }

    public ExecResp recv_changePassword() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.changePassword");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      changePassword_result result = new changePassword_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.changePassword", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "changePassword failed: unknown result");
    }

    public ExecResp checkPassword(CheckPasswordReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.checkPassword", null);
      this.setContextStack(ctx);
      send_checkPassword(req);
      return recv_checkPassword();
    }

    public void send_checkPassword(CheckPasswordReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.checkPassword", null);
      oprot_.writeMessageBegin(new TMessage("checkPassword", TMessageType.CALL, seqid_));
      checkPassword_args args = new checkPassword_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.checkPassword", args);
      return;
    }

    public ExecResp recv_checkPassword() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.checkPassword");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      checkPassword_result result = new checkPassword_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.checkPassword", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "checkPassword failed: unknown result");
    }

    public HBResp heartBeat(HBReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.heartBeat", null);
      this.setContextStack(ctx);
      send_heartBeat(req);
      return recv_heartBeat();
    }

    public void send_heartBeat(HBReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.heartBeat", null);
      oprot_.writeMessageBegin(new TMessage("heartBeat", TMessageType.CALL, seqid_));
      heartBeat_args args = new heartBeat_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.heartBeat", args);
      return;
    }

    public HBResp recv_heartBeat() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.heartBeat");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      heartBeat_result result = new heartBeat_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.heartBeat", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "heartBeat failed: unknown result");
    }

    public BalanceResp balance(BalanceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.balance", null);
      this.setContextStack(ctx);
      send_balance(req);
      return recv_balance();
    }

    public void send_balance(BalanceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.balance", null);
      oprot_.writeMessageBegin(new TMessage("balance", TMessageType.CALL, seqid_));
      balance_args args = new balance_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.balance", args);
      return;
    }

    public BalanceResp recv_balance() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.balance");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      balance_result result = new balance_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.balance", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "balance failed: unknown result");
    }

    public ExecResp leaderBalance(LeaderBalanceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.leaderBalance", null);
      this.setContextStack(ctx);
      send_leaderBalance(req);
      return recv_leaderBalance();
    }

    public void send_leaderBalance(LeaderBalanceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.leaderBalance", null);
      oprot_.writeMessageBegin(new TMessage("leaderBalance", TMessageType.CALL, seqid_));
      leaderBalance_args args = new leaderBalance_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.leaderBalance", args);
      return;
    }

    public ExecResp recv_leaderBalance() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.leaderBalance");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      leaderBalance_result result = new leaderBalance_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.leaderBalance", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "leaderBalance failed: unknown result");
    }

    public ExecResp regConfig(RegConfigReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.regConfig", null);
      this.setContextStack(ctx);
      send_regConfig(req);
      return recv_regConfig();
    }

    public void send_regConfig(RegConfigReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.regConfig", null);
      oprot_.writeMessageBegin(new TMessage("regConfig", TMessageType.CALL, seqid_));
      regConfig_args args = new regConfig_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.regConfig", args);
      return;
    }

    public ExecResp recv_regConfig() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.regConfig");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      regConfig_result result = new regConfig_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.regConfig", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "regConfig failed: unknown result");
    }

    public GetConfigResp getConfig(GetConfigReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getConfig", null);
      this.setContextStack(ctx);
      send_getConfig(req);
      return recv_getConfig();
    }

    public void send_getConfig(GetConfigReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getConfig", null);
      oprot_.writeMessageBegin(new TMessage("getConfig", TMessageType.CALL, seqid_));
      getConfig_args args = new getConfig_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getConfig", args);
      return;
    }

    public GetConfigResp recv_getConfig() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getConfig");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getConfig_result result = new getConfig_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getConfig", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getConfig failed: unknown result");
    }

    public ExecResp setConfig(SetConfigReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.setConfig", null);
      this.setContextStack(ctx);
      send_setConfig(req);
      return recv_setConfig();
    }

    public void send_setConfig(SetConfigReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.setConfig", null);
      oprot_.writeMessageBegin(new TMessage("setConfig", TMessageType.CALL, seqid_));
      setConfig_args args = new setConfig_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.setConfig", args);
      return;
    }

    public ExecResp recv_setConfig() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.setConfig");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      setConfig_result result = new setConfig_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.setConfig", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "setConfig failed: unknown result");
    }

    public ListConfigsResp listConfigs(ListConfigsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listConfigs", null);
      this.setContextStack(ctx);
      send_listConfigs(req);
      return recv_listConfigs();
    }

    public void send_listConfigs(ListConfigsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listConfigs", null);
      oprot_.writeMessageBegin(new TMessage("listConfigs", TMessageType.CALL, seqid_));
      listConfigs_args args = new listConfigs_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listConfigs", args);
      return;
    }

    public ListConfigsResp recv_listConfigs() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listConfigs");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listConfigs_result result = new listConfigs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listConfigs", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listConfigs failed: unknown result");
    }

    public ExecResp createSnapshot(CreateSnapshotReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createSnapshot", null);
      this.setContextStack(ctx);
      send_createSnapshot(req);
      return recv_createSnapshot();
    }

    public void send_createSnapshot(CreateSnapshotReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createSnapshot", null);
      oprot_.writeMessageBegin(new TMessage("createSnapshot", TMessageType.CALL, seqid_));
      createSnapshot_args args = new createSnapshot_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createSnapshot", args);
      return;
    }

    public ExecResp recv_createSnapshot() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createSnapshot");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createSnapshot_result result = new createSnapshot_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createSnapshot", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createSnapshot failed: unknown result");
    }

    public ExecResp dropSnapshot(DropSnapshotReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropSnapshot", null);
      this.setContextStack(ctx);
      send_dropSnapshot(req);
      return recv_dropSnapshot();
    }

    public void send_dropSnapshot(DropSnapshotReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropSnapshot", null);
      oprot_.writeMessageBegin(new TMessage("dropSnapshot", TMessageType.CALL, seqid_));
      dropSnapshot_args args = new dropSnapshot_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropSnapshot", args);
      return;
    }

    public ExecResp recv_dropSnapshot() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropSnapshot");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropSnapshot_result result = new dropSnapshot_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropSnapshot", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropSnapshot failed: unknown result");
    }

    public ListSnapshotsResp listSnapshots(ListSnapshotsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listSnapshots", null);
      this.setContextStack(ctx);
      send_listSnapshots(req);
      return recv_listSnapshots();
    }

    public void send_listSnapshots(ListSnapshotsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listSnapshots", null);
      oprot_.writeMessageBegin(new TMessage("listSnapshots", TMessageType.CALL, seqid_));
      listSnapshots_args args = new listSnapshots_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listSnapshots", args);
      return;
    }

    public ListSnapshotsResp recv_listSnapshots() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listSnapshots");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listSnapshots_result result = new listSnapshots_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listSnapshots", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listSnapshots failed: unknown result");
    }

    public AdminJobResp runAdminJob(AdminJobReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.runAdminJob", null);
      this.setContextStack(ctx);
      send_runAdminJob(req);
      return recv_runAdminJob();
    }

    public void send_runAdminJob(AdminJobReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.runAdminJob", null);
      oprot_.writeMessageBegin(new TMessage("runAdminJob", TMessageType.CALL, seqid_));
      runAdminJob_args args = new runAdminJob_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.runAdminJob", args);
      return;
    }

    public AdminJobResp recv_runAdminJob() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.runAdminJob");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      runAdminJob_result result = new runAdminJob_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.runAdminJob", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "runAdminJob failed: unknown result");
    }

  }
  public static class AsyncClient extends TAsyncClient implements AsyncIface {
    public static class Factory implements TAsyncClientFactory<AsyncClient> {
      private TAsyncClientManager clientManager;
      private TProtocolFactory protocolFactory;
      public Factory(TAsyncClientManager clientManager, TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(TProtocolFactory protocolFactory, TAsyncClientManager clientManager, TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void createSpace(CreateSpaceReq req, AsyncMethodCallback resultHandler212) throws TException {
      checkReady();
      createSpace_call method_call = new createSpace_call(req, resultHandler212, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createSpace_call extends TAsyncMethodCall {
      private CreateSpaceReq req;
      public createSpace_call(CreateSpaceReq req, AsyncMethodCallback resultHandler213, TAsyncClient client209, TProtocolFactory protocolFactory210, TNonblockingTransport transport211) throws TException {
        super(client209, protocolFactory210, transport211, resultHandler213, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createSpace", TMessageType.CALL, 0));
        createSpace_args args = new createSpace_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createSpace();
      }
    }

    public void dropSpace(DropSpaceReq req, AsyncMethodCallback resultHandler217) throws TException {
      checkReady();
      dropSpace_call method_call = new dropSpace_call(req, resultHandler217, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropSpace_call extends TAsyncMethodCall {
      private DropSpaceReq req;
      public dropSpace_call(DropSpaceReq req, AsyncMethodCallback resultHandler218, TAsyncClient client214, TProtocolFactory protocolFactory215, TNonblockingTransport transport216) throws TException {
        super(client214, protocolFactory215, transport216, resultHandler218, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropSpace", TMessageType.CALL, 0));
        dropSpace_args args = new dropSpace_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropSpace();
      }
    }

    public void getSpace(GetSpaceReq req, AsyncMethodCallback resultHandler222) throws TException {
      checkReady();
      getSpace_call method_call = new getSpace_call(req, resultHandler222, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getSpace_call extends TAsyncMethodCall {
      private GetSpaceReq req;
      public getSpace_call(GetSpaceReq req, AsyncMethodCallback resultHandler223, TAsyncClient client219, TProtocolFactory protocolFactory220, TNonblockingTransport transport221) throws TException {
        super(client219, protocolFactory220, transport221, resultHandler223, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getSpace", TMessageType.CALL, 0));
        getSpace_args args = new getSpace_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetSpaceResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getSpace();
      }
    }

    public void listSpaces(ListSpacesReq req, AsyncMethodCallback resultHandler227) throws TException {
      checkReady();
      listSpaces_call method_call = new listSpaces_call(req, resultHandler227, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listSpaces_call extends TAsyncMethodCall {
      private ListSpacesReq req;
      public listSpaces_call(ListSpacesReq req, AsyncMethodCallback resultHandler228, TAsyncClient client224, TProtocolFactory protocolFactory225, TNonblockingTransport transport226) throws TException {
        super(client224, protocolFactory225, transport226, resultHandler228, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listSpaces", TMessageType.CALL, 0));
        listSpaces_args args = new listSpaces_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListSpacesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listSpaces();
      }
    }

    public void createTag(CreateTagReq req, AsyncMethodCallback resultHandler232) throws TException {
      checkReady();
      createTag_call method_call = new createTag_call(req, resultHandler232, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createTag_call extends TAsyncMethodCall {
      private CreateTagReq req;
      public createTag_call(CreateTagReq req, AsyncMethodCallback resultHandler233, TAsyncClient client229, TProtocolFactory protocolFactory230, TNonblockingTransport transport231) throws TException {
        super(client229, protocolFactory230, transport231, resultHandler233, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createTag", TMessageType.CALL, 0));
        createTag_args args = new createTag_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createTag();
      }
    }

    public void alterTag(AlterTagReq req, AsyncMethodCallback resultHandler237) throws TException {
      checkReady();
      alterTag_call method_call = new alterTag_call(req, resultHandler237, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class alterTag_call extends TAsyncMethodCall {
      private AlterTagReq req;
      public alterTag_call(AlterTagReq req, AsyncMethodCallback resultHandler238, TAsyncClient client234, TProtocolFactory protocolFactory235, TNonblockingTransport transport236) throws TException {
        super(client234, protocolFactory235, transport236, resultHandler238, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("alterTag", TMessageType.CALL, 0));
        alterTag_args args = new alterTag_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_alterTag();
      }
    }

    public void dropTag(DropTagReq req, AsyncMethodCallback resultHandler242) throws TException {
      checkReady();
      dropTag_call method_call = new dropTag_call(req, resultHandler242, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropTag_call extends TAsyncMethodCall {
      private DropTagReq req;
      public dropTag_call(DropTagReq req, AsyncMethodCallback resultHandler243, TAsyncClient client239, TProtocolFactory protocolFactory240, TNonblockingTransport transport241) throws TException {
        super(client239, protocolFactory240, transport241, resultHandler243, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropTag", TMessageType.CALL, 0));
        dropTag_args args = new dropTag_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropTag();
      }
    }

    public void getTag(GetTagReq req, AsyncMethodCallback resultHandler247) throws TException {
      checkReady();
      getTag_call method_call = new getTag_call(req, resultHandler247, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getTag_call extends TAsyncMethodCall {
      private GetTagReq req;
      public getTag_call(GetTagReq req, AsyncMethodCallback resultHandler248, TAsyncClient client244, TProtocolFactory protocolFactory245, TNonblockingTransport transport246) throws TException {
        super(client244, protocolFactory245, transport246, resultHandler248, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTag", TMessageType.CALL, 0));
        getTag_args args = new getTag_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetTagResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTag();
      }
    }

    public void listTags(ListTagsReq req, AsyncMethodCallback resultHandler252) throws TException {
      checkReady();
      listTags_call method_call = new listTags_call(req, resultHandler252, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listTags_call extends TAsyncMethodCall {
      private ListTagsReq req;
      public listTags_call(ListTagsReq req, AsyncMethodCallback resultHandler253, TAsyncClient client249, TProtocolFactory protocolFactory250, TNonblockingTransport transport251) throws TException {
        super(client249, protocolFactory250, transport251, resultHandler253, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listTags", TMessageType.CALL, 0));
        listTags_args args = new listTags_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListTagsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listTags();
      }
    }

    public void createEdge(CreateEdgeReq req, AsyncMethodCallback resultHandler257) throws TException {
      checkReady();
      createEdge_call method_call = new createEdge_call(req, resultHandler257, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createEdge_call extends TAsyncMethodCall {
      private CreateEdgeReq req;
      public createEdge_call(CreateEdgeReq req, AsyncMethodCallback resultHandler258, TAsyncClient client254, TProtocolFactory protocolFactory255, TNonblockingTransport transport256) throws TException {
        super(client254, protocolFactory255, transport256, resultHandler258, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createEdge", TMessageType.CALL, 0));
        createEdge_args args = new createEdge_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createEdge();
      }
    }

    public void alterEdge(AlterEdgeReq req, AsyncMethodCallback resultHandler262) throws TException {
      checkReady();
      alterEdge_call method_call = new alterEdge_call(req, resultHandler262, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class alterEdge_call extends TAsyncMethodCall {
      private AlterEdgeReq req;
      public alterEdge_call(AlterEdgeReq req, AsyncMethodCallback resultHandler263, TAsyncClient client259, TProtocolFactory protocolFactory260, TNonblockingTransport transport261) throws TException {
        super(client259, protocolFactory260, transport261, resultHandler263, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("alterEdge", TMessageType.CALL, 0));
        alterEdge_args args = new alterEdge_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_alterEdge();
      }
    }

    public void dropEdge(DropEdgeReq req, AsyncMethodCallback resultHandler267) throws TException {
      checkReady();
      dropEdge_call method_call = new dropEdge_call(req, resultHandler267, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropEdge_call extends TAsyncMethodCall {
      private DropEdgeReq req;
      public dropEdge_call(DropEdgeReq req, AsyncMethodCallback resultHandler268, TAsyncClient client264, TProtocolFactory protocolFactory265, TNonblockingTransport transport266) throws TException {
        super(client264, protocolFactory265, transport266, resultHandler268, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropEdge", TMessageType.CALL, 0));
        dropEdge_args args = new dropEdge_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropEdge();
      }
    }

    public void getEdge(GetEdgeReq req, AsyncMethodCallback resultHandler272) throws TException {
      checkReady();
      getEdge_call method_call = new getEdge_call(req, resultHandler272, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getEdge_call extends TAsyncMethodCall {
      private GetEdgeReq req;
      public getEdge_call(GetEdgeReq req, AsyncMethodCallback resultHandler273, TAsyncClient client269, TProtocolFactory protocolFactory270, TNonblockingTransport transport271) throws TException {
        super(client269, protocolFactory270, transport271, resultHandler273, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getEdge", TMessageType.CALL, 0));
        getEdge_args args = new getEdge_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetEdgeResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getEdge();
      }
    }

    public void listEdges(ListEdgesReq req, AsyncMethodCallback resultHandler277) throws TException {
      checkReady();
      listEdges_call method_call = new listEdges_call(req, resultHandler277, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listEdges_call extends TAsyncMethodCall {
      private ListEdgesReq req;
      public listEdges_call(ListEdgesReq req, AsyncMethodCallback resultHandler278, TAsyncClient client274, TProtocolFactory protocolFactory275, TNonblockingTransport transport276) throws TException {
        super(client274, protocolFactory275, transport276, resultHandler278, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listEdges", TMessageType.CALL, 0));
        listEdges_args args = new listEdges_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListEdgesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listEdges();
      }
    }

    public void listHosts(ListHostsReq req, AsyncMethodCallback resultHandler282) throws TException {
      checkReady();
      listHosts_call method_call = new listHosts_call(req, resultHandler282, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listHosts_call extends TAsyncMethodCall {
      private ListHostsReq req;
      public listHosts_call(ListHostsReq req, AsyncMethodCallback resultHandler283, TAsyncClient client279, TProtocolFactory protocolFactory280, TNonblockingTransport transport281) throws TException {
        super(client279, protocolFactory280, transport281, resultHandler283, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listHosts", TMessageType.CALL, 0));
        listHosts_args args = new listHosts_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListHostsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listHosts();
      }
    }

    public void getPartsAlloc(GetPartsAllocReq req, AsyncMethodCallback resultHandler287) throws TException {
      checkReady();
      getPartsAlloc_call method_call = new getPartsAlloc_call(req, resultHandler287, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getPartsAlloc_call extends TAsyncMethodCall {
      private GetPartsAllocReq req;
      public getPartsAlloc_call(GetPartsAllocReq req, AsyncMethodCallback resultHandler288, TAsyncClient client284, TProtocolFactory protocolFactory285, TNonblockingTransport transport286) throws TException {
        super(client284, protocolFactory285, transport286, resultHandler288, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getPartsAlloc", TMessageType.CALL, 0));
        getPartsAlloc_args args = new getPartsAlloc_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetPartsAllocResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getPartsAlloc();
      }
    }

    public void listParts(ListPartsReq req, AsyncMethodCallback resultHandler292) throws TException {
      checkReady();
      listParts_call method_call = new listParts_call(req, resultHandler292, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listParts_call extends TAsyncMethodCall {
      private ListPartsReq req;
      public listParts_call(ListPartsReq req, AsyncMethodCallback resultHandler293, TAsyncClient client289, TProtocolFactory protocolFactory290, TNonblockingTransport transport291) throws TException {
        super(client289, protocolFactory290, transport291, resultHandler293, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listParts", TMessageType.CALL, 0));
        listParts_args args = new listParts_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListPartsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listParts();
      }
    }

    public void multiPut(MultiPutReq req, AsyncMethodCallback resultHandler297) throws TException {
      checkReady();
      multiPut_call method_call = new multiPut_call(req, resultHandler297, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class multiPut_call extends TAsyncMethodCall {
      private MultiPutReq req;
      public multiPut_call(MultiPutReq req, AsyncMethodCallback resultHandler298, TAsyncClient client294, TProtocolFactory protocolFactory295, TNonblockingTransport transport296) throws TException {
        super(client294, protocolFactory295, transport296, resultHandler298, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("multiPut", TMessageType.CALL, 0));
        multiPut_args args = new multiPut_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_multiPut();
      }
    }

    public void get(GetReq req, AsyncMethodCallback resultHandler302) throws TException {
      checkReady();
      get_call method_call = new get_call(req, resultHandler302, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class get_call extends TAsyncMethodCall {
      private GetReq req;
      public get_call(GetReq req, AsyncMethodCallback resultHandler303, TAsyncClient client299, TProtocolFactory protocolFactory300, TNonblockingTransport transport301) throws TException {
        super(client299, protocolFactory300, transport301, resultHandler303, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get", TMessageType.CALL, 0));
        get_args args = new get_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get();
      }
    }

    public void multiGet(MultiGetReq req, AsyncMethodCallback resultHandler307) throws TException {
      checkReady();
      multiGet_call method_call = new multiGet_call(req, resultHandler307, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class multiGet_call extends TAsyncMethodCall {
      private MultiGetReq req;
      public multiGet_call(MultiGetReq req, AsyncMethodCallback resultHandler308, TAsyncClient client304, TProtocolFactory protocolFactory305, TNonblockingTransport transport306) throws TException {
        super(client304, protocolFactory305, transport306, resultHandler308, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("multiGet", TMessageType.CALL, 0));
        multiGet_args args = new multiGet_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public MultiGetResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_multiGet();
      }
    }

    public void remove(RemoveReq req, AsyncMethodCallback resultHandler312) throws TException {
      checkReady();
      remove_call method_call = new remove_call(req, resultHandler312, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class remove_call extends TAsyncMethodCall {
      private RemoveReq req;
      public remove_call(RemoveReq req, AsyncMethodCallback resultHandler313, TAsyncClient client309, TProtocolFactory protocolFactory310, TNonblockingTransport transport311) throws TException {
        super(client309, protocolFactory310, transport311, resultHandler313, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("remove", TMessageType.CALL, 0));
        remove_args args = new remove_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_remove();
      }
    }

    public void removeRange(RemoveRangeReq req, AsyncMethodCallback resultHandler317) throws TException {
      checkReady();
      removeRange_call method_call = new removeRange_call(req, resultHandler317, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class removeRange_call extends TAsyncMethodCall {
      private RemoveRangeReq req;
      public removeRange_call(RemoveRangeReq req, AsyncMethodCallback resultHandler318, TAsyncClient client314, TProtocolFactory protocolFactory315, TNonblockingTransport transport316) throws TException {
        super(client314, protocolFactory315, transport316, resultHandler318, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("removeRange", TMessageType.CALL, 0));
        removeRange_args args = new removeRange_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_removeRange();
      }
    }

    public void scan(ScanReq req, AsyncMethodCallback resultHandler322) throws TException {
      checkReady();
      scan_call method_call = new scan_call(req, resultHandler322, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class scan_call extends TAsyncMethodCall {
      private ScanReq req;
      public scan_call(ScanReq req, AsyncMethodCallback resultHandler323, TAsyncClient client319, TProtocolFactory protocolFactory320, TNonblockingTransport transport321) throws TException {
        super(client319, protocolFactory320, transport321, resultHandler323, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("scan", TMessageType.CALL, 0));
        scan_args args = new scan_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ScanResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_scan();
      }
    }

    public void createTagIndex(CreateTagIndexReq req, AsyncMethodCallback resultHandler327) throws TException {
      checkReady();
      createTagIndex_call method_call = new createTagIndex_call(req, resultHandler327, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createTagIndex_call extends TAsyncMethodCall {
      private CreateTagIndexReq req;
      public createTagIndex_call(CreateTagIndexReq req, AsyncMethodCallback resultHandler328, TAsyncClient client324, TProtocolFactory protocolFactory325, TNonblockingTransport transport326) throws TException {
        super(client324, protocolFactory325, transport326, resultHandler328, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createTagIndex", TMessageType.CALL, 0));
        createTagIndex_args args = new createTagIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createTagIndex();
      }
    }

    public void dropTagIndex(DropTagIndexReq req, AsyncMethodCallback resultHandler332) throws TException {
      checkReady();
      dropTagIndex_call method_call = new dropTagIndex_call(req, resultHandler332, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropTagIndex_call extends TAsyncMethodCall {
      private DropTagIndexReq req;
      public dropTagIndex_call(DropTagIndexReq req, AsyncMethodCallback resultHandler333, TAsyncClient client329, TProtocolFactory protocolFactory330, TNonblockingTransport transport331) throws TException {
        super(client329, protocolFactory330, transport331, resultHandler333, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropTagIndex", TMessageType.CALL, 0));
        dropTagIndex_args args = new dropTagIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropTagIndex();
      }
    }

    public void getTagIndex(GetTagIndexReq req, AsyncMethodCallback resultHandler337) throws TException {
      checkReady();
      getTagIndex_call method_call = new getTagIndex_call(req, resultHandler337, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getTagIndex_call extends TAsyncMethodCall {
      private GetTagIndexReq req;
      public getTagIndex_call(GetTagIndexReq req, AsyncMethodCallback resultHandler338, TAsyncClient client334, TProtocolFactory protocolFactory335, TNonblockingTransport transport336) throws TException {
        super(client334, protocolFactory335, transport336, resultHandler338, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTagIndex", TMessageType.CALL, 0));
        getTagIndex_args args = new getTagIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetTagIndexResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTagIndex();
      }
    }

    public void listTagIndexes(ListTagIndexesReq req, AsyncMethodCallback resultHandler342) throws TException {
      checkReady();
      listTagIndexes_call method_call = new listTagIndexes_call(req, resultHandler342, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listTagIndexes_call extends TAsyncMethodCall {
      private ListTagIndexesReq req;
      public listTagIndexes_call(ListTagIndexesReq req, AsyncMethodCallback resultHandler343, TAsyncClient client339, TProtocolFactory protocolFactory340, TNonblockingTransport transport341) throws TException {
        super(client339, protocolFactory340, transport341, resultHandler343, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listTagIndexes", TMessageType.CALL, 0));
        listTagIndexes_args args = new listTagIndexes_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListTagIndexesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listTagIndexes();
      }
    }

    public void createEdgeIndex(CreateEdgeIndexReq req, AsyncMethodCallback resultHandler347) throws TException {
      checkReady();
      createEdgeIndex_call method_call = new createEdgeIndex_call(req, resultHandler347, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createEdgeIndex_call extends TAsyncMethodCall {
      private CreateEdgeIndexReq req;
      public createEdgeIndex_call(CreateEdgeIndexReq req, AsyncMethodCallback resultHandler348, TAsyncClient client344, TProtocolFactory protocolFactory345, TNonblockingTransport transport346) throws TException {
        super(client344, protocolFactory345, transport346, resultHandler348, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createEdgeIndex", TMessageType.CALL, 0));
        createEdgeIndex_args args = new createEdgeIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createEdgeIndex();
      }
    }

    public void dropEdgeIndex(DropEdgeIndexReq req, AsyncMethodCallback resultHandler352) throws TException {
      checkReady();
      dropEdgeIndex_call method_call = new dropEdgeIndex_call(req, resultHandler352, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropEdgeIndex_call extends TAsyncMethodCall {
      private DropEdgeIndexReq req;
      public dropEdgeIndex_call(DropEdgeIndexReq req, AsyncMethodCallback resultHandler353, TAsyncClient client349, TProtocolFactory protocolFactory350, TNonblockingTransport transport351) throws TException {
        super(client349, protocolFactory350, transport351, resultHandler353, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropEdgeIndex", TMessageType.CALL, 0));
        dropEdgeIndex_args args = new dropEdgeIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropEdgeIndex();
      }
    }

    public void getEdgeIndex(GetEdgeIndexReq req, AsyncMethodCallback resultHandler357) throws TException {
      checkReady();
      getEdgeIndex_call method_call = new getEdgeIndex_call(req, resultHandler357, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getEdgeIndex_call extends TAsyncMethodCall {
      private GetEdgeIndexReq req;
      public getEdgeIndex_call(GetEdgeIndexReq req, AsyncMethodCallback resultHandler358, TAsyncClient client354, TProtocolFactory protocolFactory355, TNonblockingTransport transport356) throws TException {
        super(client354, protocolFactory355, transport356, resultHandler358, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getEdgeIndex", TMessageType.CALL, 0));
        getEdgeIndex_args args = new getEdgeIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetEdgeIndexResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getEdgeIndex();
      }
    }

    public void listEdgeIndexes(ListEdgeIndexesReq req, AsyncMethodCallback resultHandler362) throws TException {
      checkReady();
      listEdgeIndexes_call method_call = new listEdgeIndexes_call(req, resultHandler362, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listEdgeIndexes_call extends TAsyncMethodCall {
      private ListEdgeIndexesReq req;
      public listEdgeIndexes_call(ListEdgeIndexesReq req, AsyncMethodCallback resultHandler363, TAsyncClient client359, TProtocolFactory protocolFactory360, TNonblockingTransport transport361) throws TException {
        super(client359, protocolFactory360, transport361, resultHandler363, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listEdgeIndexes", TMessageType.CALL, 0));
        listEdgeIndexes_args args = new listEdgeIndexes_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListEdgeIndexesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listEdgeIndexes();
      }
    }

    public void createUser(CreateUserReq req, AsyncMethodCallback resultHandler367) throws TException {
      checkReady();
      createUser_call method_call = new createUser_call(req, resultHandler367, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createUser_call extends TAsyncMethodCall {
      private CreateUserReq req;
      public createUser_call(CreateUserReq req, AsyncMethodCallback resultHandler368, TAsyncClient client364, TProtocolFactory protocolFactory365, TNonblockingTransport transport366) throws TException {
        super(client364, protocolFactory365, transport366, resultHandler368, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createUser", TMessageType.CALL, 0));
        createUser_args args = new createUser_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createUser();
      }
    }

    public void dropUser(DropUserReq req, AsyncMethodCallback resultHandler372) throws TException {
      checkReady();
      dropUser_call method_call = new dropUser_call(req, resultHandler372, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropUser_call extends TAsyncMethodCall {
      private DropUserReq req;
      public dropUser_call(DropUserReq req, AsyncMethodCallback resultHandler373, TAsyncClient client369, TProtocolFactory protocolFactory370, TNonblockingTransport transport371) throws TException {
        super(client369, protocolFactory370, transport371, resultHandler373, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropUser", TMessageType.CALL, 0));
        dropUser_args args = new dropUser_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropUser();
      }
    }

    public void alterUser(AlterUserReq req, AsyncMethodCallback resultHandler377) throws TException {
      checkReady();
      alterUser_call method_call = new alterUser_call(req, resultHandler377, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class alterUser_call extends TAsyncMethodCall {
      private AlterUserReq req;
      public alterUser_call(AlterUserReq req, AsyncMethodCallback resultHandler378, TAsyncClient client374, TProtocolFactory protocolFactory375, TNonblockingTransport transport376) throws TException {
        super(client374, protocolFactory375, transport376, resultHandler378, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("alterUser", TMessageType.CALL, 0));
        alterUser_args args = new alterUser_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_alterUser();
      }
    }

    public void grantRole(GrantRoleReq req, AsyncMethodCallback resultHandler382) throws TException {
      checkReady();
      grantRole_call method_call = new grantRole_call(req, resultHandler382, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class grantRole_call extends TAsyncMethodCall {
      private GrantRoleReq req;
      public grantRole_call(GrantRoleReq req, AsyncMethodCallback resultHandler383, TAsyncClient client379, TProtocolFactory protocolFactory380, TNonblockingTransport transport381) throws TException {
        super(client379, protocolFactory380, transport381, resultHandler383, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("grantRole", TMessageType.CALL, 0));
        grantRole_args args = new grantRole_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_grantRole();
      }
    }

    public void revokeRole(RevokeRoleReq req, AsyncMethodCallback resultHandler387) throws TException {
      checkReady();
      revokeRole_call method_call = new revokeRole_call(req, resultHandler387, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class revokeRole_call extends TAsyncMethodCall {
      private RevokeRoleReq req;
      public revokeRole_call(RevokeRoleReq req, AsyncMethodCallback resultHandler388, TAsyncClient client384, TProtocolFactory protocolFactory385, TNonblockingTransport transport386) throws TException {
        super(client384, protocolFactory385, transport386, resultHandler388, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("revokeRole", TMessageType.CALL, 0));
        revokeRole_args args = new revokeRole_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_revokeRole();
      }
    }

    public void getUser(GetUserReq req, AsyncMethodCallback resultHandler392) throws TException {
      checkReady();
      getUser_call method_call = new getUser_call(req, resultHandler392, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getUser_call extends TAsyncMethodCall {
      private GetUserReq req;
      public getUser_call(GetUserReq req, AsyncMethodCallback resultHandler393, TAsyncClient client389, TProtocolFactory protocolFactory390, TNonblockingTransport transport391) throws TException {
        super(client389, protocolFactory390, transport391, resultHandler393, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getUser", TMessageType.CALL, 0));
        getUser_args args = new getUser_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetUserResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getUser();
      }
    }

    public void listUsers(ListUsersReq req, AsyncMethodCallback resultHandler397) throws TException {
      checkReady();
      listUsers_call method_call = new listUsers_call(req, resultHandler397, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listUsers_call extends TAsyncMethodCall {
      private ListUsersReq req;
      public listUsers_call(ListUsersReq req, AsyncMethodCallback resultHandler398, TAsyncClient client394, TProtocolFactory protocolFactory395, TNonblockingTransport transport396) throws TException {
        super(client394, protocolFactory395, transport396, resultHandler398, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listUsers", TMessageType.CALL, 0));
        listUsers_args args = new listUsers_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListUsersResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listUsers();
      }
    }

    public void listRoles(ListRolesReq req, AsyncMethodCallback resultHandler402) throws TException {
      checkReady();
      listRoles_call method_call = new listRoles_call(req, resultHandler402, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listRoles_call extends TAsyncMethodCall {
      private ListRolesReq req;
      public listRoles_call(ListRolesReq req, AsyncMethodCallback resultHandler403, TAsyncClient client399, TProtocolFactory protocolFactory400, TNonblockingTransport transport401) throws TException {
        super(client399, protocolFactory400, transport401, resultHandler403, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listRoles", TMessageType.CALL, 0));
        listRoles_args args = new listRoles_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListRolesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listRoles();
      }
    }

    public void changePassword(ChangePasswordReq req, AsyncMethodCallback resultHandler407) throws TException {
      checkReady();
      changePassword_call method_call = new changePassword_call(req, resultHandler407, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class changePassword_call extends TAsyncMethodCall {
      private ChangePasswordReq req;
      public changePassword_call(ChangePasswordReq req, AsyncMethodCallback resultHandler408, TAsyncClient client404, TProtocolFactory protocolFactory405, TNonblockingTransport transport406) throws TException {
        super(client404, protocolFactory405, transport406, resultHandler408, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("changePassword", TMessageType.CALL, 0));
        changePassword_args args = new changePassword_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_changePassword();
      }
    }

    public void checkPassword(CheckPasswordReq req, AsyncMethodCallback resultHandler412) throws TException {
      checkReady();
      checkPassword_call method_call = new checkPassword_call(req, resultHandler412, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class checkPassword_call extends TAsyncMethodCall {
      private CheckPasswordReq req;
      public checkPassword_call(CheckPasswordReq req, AsyncMethodCallback resultHandler413, TAsyncClient client409, TProtocolFactory protocolFactory410, TNonblockingTransport transport411) throws TException {
        super(client409, protocolFactory410, transport411, resultHandler413, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("checkPassword", TMessageType.CALL, 0));
        checkPassword_args args = new checkPassword_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_checkPassword();
      }
    }

    public void heartBeat(HBReq req, AsyncMethodCallback resultHandler417) throws TException {
      checkReady();
      heartBeat_call method_call = new heartBeat_call(req, resultHandler417, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class heartBeat_call extends TAsyncMethodCall {
      private HBReq req;
      public heartBeat_call(HBReq req, AsyncMethodCallback resultHandler418, TAsyncClient client414, TProtocolFactory protocolFactory415, TNonblockingTransport transport416) throws TException {
        super(client414, protocolFactory415, transport416, resultHandler418, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("heartBeat", TMessageType.CALL, 0));
        heartBeat_args args = new heartBeat_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public HBResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_heartBeat();
      }
    }

    public void balance(BalanceReq req, AsyncMethodCallback resultHandler422) throws TException {
      checkReady();
      balance_call method_call = new balance_call(req, resultHandler422, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class balance_call extends TAsyncMethodCall {
      private BalanceReq req;
      public balance_call(BalanceReq req, AsyncMethodCallback resultHandler423, TAsyncClient client419, TProtocolFactory protocolFactory420, TNonblockingTransport transport421) throws TException {
        super(client419, protocolFactory420, transport421, resultHandler423, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("balance", TMessageType.CALL, 0));
        balance_args args = new balance_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public BalanceResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_balance();
      }
    }

    public void leaderBalance(LeaderBalanceReq req, AsyncMethodCallback resultHandler427) throws TException {
      checkReady();
      leaderBalance_call method_call = new leaderBalance_call(req, resultHandler427, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class leaderBalance_call extends TAsyncMethodCall {
      private LeaderBalanceReq req;
      public leaderBalance_call(LeaderBalanceReq req, AsyncMethodCallback resultHandler428, TAsyncClient client424, TProtocolFactory protocolFactory425, TNonblockingTransport transport426) throws TException {
        super(client424, protocolFactory425, transport426, resultHandler428, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("leaderBalance", TMessageType.CALL, 0));
        leaderBalance_args args = new leaderBalance_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_leaderBalance();
      }
    }

    public void regConfig(RegConfigReq req, AsyncMethodCallback resultHandler432) throws TException {
      checkReady();
      regConfig_call method_call = new regConfig_call(req, resultHandler432, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class regConfig_call extends TAsyncMethodCall {
      private RegConfigReq req;
      public regConfig_call(RegConfigReq req, AsyncMethodCallback resultHandler433, TAsyncClient client429, TProtocolFactory protocolFactory430, TNonblockingTransport transport431) throws TException {
        super(client429, protocolFactory430, transport431, resultHandler433, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("regConfig", TMessageType.CALL, 0));
        regConfig_args args = new regConfig_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_regConfig();
      }
    }

    public void getConfig(GetConfigReq req, AsyncMethodCallback resultHandler437) throws TException {
      checkReady();
      getConfig_call method_call = new getConfig_call(req, resultHandler437, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getConfig_call extends TAsyncMethodCall {
      private GetConfigReq req;
      public getConfig_call(GetConfigReq req, AsyncMethodCallback resultHandler438, TAsyncClient client434, TProtocolFactory protocolFactory435, TNonblockingTransport transport436) throws TException {
        super(client434, protocolFactory435, transport436, resultHandler438, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getConfig", TMessageType.CALL, 0));
        getConfig_args args = new getConfig_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetConfigResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getConfig();
      }
    }

    public void setConfig(SetConfigReq req, AsyncMethodCallback resultHandler442) throws TException {
      checkReady();
      setConfig_call method_call = new setConfig_call(req, resultHandler442, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class setConfig_call extends TAsyncMethodCall {
      private SetConfigReq req;
      public setConfig_call(SetConfigReq req, AsyncMethodCallback resultHandler443, TAsyncClient client439, TProtocolFactory protocolFactory440, TNonblockingTransport transport441) throws TException {
        super(client439, protocolFactory440, transport441, resultHandler443, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("setConfig", TMessageType.CALL, 0));
        setConfig_args args = new setConfig_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_setConfig();
      }
    }

    public void listConfigs(ListConfigsReq req, AsyncMethodCallback resultHandler447) throws TException {
      checkReady();
      listConfigs_call method_call = new listConfigs_call(req, resultHandler447, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listConfigs_call extends TAsyncMethodCall {
      private ListConfigsReq req;
      public listConfigs_call(ListConfigsReq req, AsyncMethodCallback resultHandler448, TAsyncClient client444, TProtocolFactory protocolFactory445, TNonblockingTransport transport446) throws TException {
        super(client444, protocolFactory445, transport446, resultHandler448, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listConfigs", TMessageType.CALL, 0));
        listConfigs_args args = new listConfigs_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListConfigsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listConfigs();
      }
    }

    public void createSnapshot(CreateSnapshotReq req, AsyncMethodCallback resultHandler452) throws TException {
      checkReady();
      createSnapshot_call method_call = new createSnapshot_call(req, resultHandler452, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createSnapshot_call extends TAsyncMethodCall {
      private CreateSnapshotReq req;
      public createSnapshot_call(CreateSnapshotReq req, AsyncMethodCallback resultHandler453, TAsyncClient client449, TProtocolFactory protocolFactory450, TNonblockingTransport transport451) throws TException {
        super(client449, protocolFactory450, transport451, resultHandler453, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createSnapshot", TMessageType.CALL, 0));
        createSnapshot_args args = new createSnapshot_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createSnapshot();
      }
    }

    public void dropSnapshot(DropSnapshotReq req, AsyncMethodCallback resultHandler457) throws TException {
      checkReady();
      dropSnapshot_call method_call = new dropSnapshot_call(req, resultHandler457, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropSnapshot_call extends TAsyncMethodCall {
      private DropSnapshotReq req;
      public dropSnapshot_call(DropSnapshotReq req, AsyncMethodCallback resultHandler458, TAsyncClient client454, TProtocolFactory protocolFactory455, TNonblockingTransport transport456) throws TException {
        super(client454, protocolFactory455, transport456, resultHandler458, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropSnapshot", TMessageType.CALL, 0));
        dropSnapshot_args args = new dropSnapshot_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropSnapshot();
      }
    }

    public void listSnapshots(ListSnapshotsReq req, AsyncMethodCallback resultHandler462) throws TException {
      checkReady();
      listSnapshots_call method_call = new listSnapshots_call(req, resultHandler462, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listSnapshots_call extends TAsyncMethodCall {
      private ListSnapshotsReq req;
      public listSnapshots_call(ListSnapshotsReq req, AsyncMethodCallback resultHandler463, TAsyncClient client459, TProtocolFactory protocolFactory460, TNonblockingTransport transport461) throws TException {
        super(client459, protocolFactory460, transport461, resultHandler463, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listSnapshots", TMessageType.CALL, 0));
        listSnapshots_args args = new listSnapshots_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListSnapshotsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listSnapshots();
      }
    }

    public void runAdminJob(AdminJobReq req, AsyncMethodCallback resultHandler467) throws TException {
      checkReady();
      runAdminJob_call method_call = new runAdminJob_call(req, resultHandler467, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class runAdminJob_call extends TAsyncMethodCall {
      private AdminJobReq req;
      public runAdminJob_call(AdminJobReq req, AsyncMethodCallback resultHandler468, TAsyncClient client464, TProtocolFactory protocolFactory465, TNonblockingTransport transport466) throws TException {
        super(client464, protocolFactory465, transport466, resultHandler468, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("runAdminJob", TMessageType.CALL, 0));
        runAdminJob_args args = new runAdminJob_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public AdminJobResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_runAdminJob();
      }
    }

  }

  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      event_handler_ = new TProcessorEventHandler(); // Empty handler
      processMap_.put("createSpace", new createSpace());
      processMap_.put("dropSpace", new dropSpace());
      processMap_.put("getSpace", new getSpace());
      processMap_.put("listSpaces", new listSpaces());
      processMap_.put("createTag", new createTag());
      processMap_.put("alterTag", new alterTag());
      processMap_.put("dropTag", new dropTag());
      processMap_.put("getTag", new getTag());
      processMap_.put("listTags", new listTags());
      processMap_.put("createEdge", new createEdge());
      processMap_.put("alterEdge", new alterEdge());
      processMap_.put("dropEdge", new dropEdge());
      processMap_.put("getEdge", new getEdge());
      processMap_.put("listEdges", new listEdges());
      processMap_.put("listHosts", new listHosts());
      processMap_.put("getPartsAlloc", new getPartsAlloc());
      processMap_.put("listParts", new listParts());
      processMap_.put("multiPut", new multiPut());
      processMap_.put("get", new get());
      processMap_.put("multiGet", new multiGet());
      processMap_.put("remove", new remove());
      processMap_.put("removeRange", new removeRange());
      processMap_.put("scan", new scan());
      processMap_.put("createTagIndex", new createTagIndex());
      processMap_.put("dropTagIndex", new dropTagIndex());
      processMap_.put("getTagIndex", new getTagIndex());
      processMap_.put("listTagIndexes", new listTagIndexes());
      processMap_.put("createEdgeIndex", new createEdgeIndex());
      processMap_.put("dropEdgeIndex", new dropEdgeIndex());
      processMap_.put("getEdgeIndex", new getEdgeIndex());
      processMap_.put("listEdgeIndexes", new listEdgeIndexes());
      processMap_.put("createUser", new createUser());
      processMap_.put("dropUser", new dropUser());
      processMap_.put("alterUser", new alterUser());
      processMap_.put("grantRole", new grantRole());
      processMap_.put("revokeRole", new revokeRole());
      processMap_.put("getUser", new getUser());
      processMap_.put("listUsers", new listUsers());
      processMap_.put("listRoles", new listRoles());
      processMap_.put("changePassword", new changePassword());
      processMap_.put("checkPassword", new checkPassword());
      processMap_.put("heartBeat", new heartBeat());
      processMap_.put("balance", new balance());
      processMap_.put("leaderBalance", new leaderBalance());
      processMap_.put("regConfig", new regConfig());
      processMap_.put("getConfig", new getConfig());
      processMap_.put("setConfig", new setConfig());
      processMap_.put("listConfigs", new listConfigs());
      processMap_.put("createSnapshot", new createSnapshot());
      processMap_.put("dropSnapshot", new dropSnapshot());
      processMap_.put("listSnapshots", new listSnapshots());
      processMap_.put("runAdminJob", new runAdminJob());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException;
    }

    public void setEventHandler(TProcessorEventHandler handler) {
      this.event_handler_ = handler;
    }

    private Iface iface_;
    protected TProcessorEventHandler event_handler_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot, server_ctx);
      return true;
    }

    private class createSpace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createSpace", server_ctx);
        createSpace_args args = new createSpace_args();
        event_handler_.preRead(handler_ctx, "MetaService.createSpace");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createSpace", args);
        createSpace_result result = new createSpace_result();
        result.success = iface_.createSpace(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createSpace", result);
        oprot.writeMessageBegin(new TMessage("createSpace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createSpace", result);
      }

    }

    private class dropSpace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropSpace", server_ctx);
        dropSpace_args args = new dropSpace_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropSpace");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropSpace", args);
        dropSpace_result result = new dropSpace_result();
        result.success = iface_.dropSpace(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropSpace", result);
        oprot.writeMessageBegin(new TMessage("dropSpace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropSpace", result);
      }

    }

    private class getSpace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getSpace", server_ctx);
        getSpace_args args = new getSpace_args();
        event_handler_.preRead(handler_ctx, "MetaService.getSpace");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getSpace", args);
        getSpace_result result = new getSpace_result();
        result.success = iface_.getSpace(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getSpace", result);
        oprot.writeMessageBegin(new TMessage("getSpace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getSpace", result);
      }

    }

    private class listSpaces implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listSpaces", server_ctx);
        listSpaces_args args = new listSpaces_args();
        event_handler_.preRead(handler_ctx, "MetaService.listSpaces");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listSpaces", args);
        listSpaces_result result = new listSpaces_result();
        result.success = iface_.listSpaces(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listSpaces", result);
        oprot.writeMessageBegin(new TMessage("listSpaces", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listSpaces", result);
      }

    }

    private class createTag implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createTag", server_ctx);
        createTag_args args = new createTag_args();
        event_handler_.preRead(handler_ctx, "MetaService.createTag");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createTag", args);
        createTag_result result = new createTag_result();
        result.success = iface_.createTag(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createTag", result);
        oprot.writeMessageBegin(new TMessage("createTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createTag", result);
      }

    }

    private class alterTag implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.alterTag", server_ctx);
        alterTag_args args = new alterTag_args();
        event_handler_.preRead(handler_ctx, "MetaService.alterTag");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.alterTag", args);
        alterTag_result result = new alterTag_result();
        result.success = iface_.alterTag(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.alterTag", result);
        oprot.writeMessageBegin(new TMessage("alterTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.alterTag", result);
      }

    }

    private class dropTag implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropTag", server_ctx);
        dropTag_args args = new dropTag_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropTag");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropTag", args);
        dropTag_result result = new dropTag_result();
        result.success = iface_.dropTag(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropTag", result);
        oprot.writeMessageBegin(new TMessage("dropTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropTag", result);
      }

    }

    private class getTag implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getTag", server_ctx);
        getTag_args args = new getTag_args();
        event_handler_.preRead(handler_ctx, "MetaService.getTag");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getTag", args);
        getTag_result result = new getTag_result();
        result.success = iface_.getTag(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getTag", result);
        oprot.writeMessageBegin(new TMessage("getTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getTag", result);
      }

    }

    private class listTags implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listTags", server_ctx);
        listTags_args args = new listTags_args();
        event_handler_.preRead(handler_ctx, "MetaService.listTags");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listTags", args);
        listTags_result result = new listTags_result();
        result.success = iface_.listTags(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listTags", result);
        oprot.writeMessageBegin(new TMessage("listTags", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listTags", result);
      }

    }

    private class createEdge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createEdge", server_ctx);
        createEdge_args args = new createEdge_args();
        event_handler_.preRead(handler_ctx, "MetaService.createEdge");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createEdge", args);
        createEdge_result result = new createEdge_result();
        result.success = iface_.createEdge(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createEdge", result);
        oprot.writeMessageBegin(new TMessage("createEdge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createEdge", result);
      }

    }

    private class alterEdge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.alterEdge", server_ctx);
        alterEdge_args args = new alterEdge_args();
        event_handler_.preRead(handler_ctx, "MetaService.alterEdge");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.alterEdge", args);
        alterEdge_result result = new alterEdge_result();
        result.success = iface_.alterEdge(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.alterEdge", result);
        oprot.writeMessageBegin(new TMessage("alterEdge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.alterEdge", result);
      }

    }

    private class dropEdge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropEdge", server_ctx);
        dropEdge_args args = new dropEdge_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropEdge");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropEdge", args);
        dropEdge_result result = new dropEdge_result();
        result.success = iface_.dropEdge(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropEdge", result);
        oprot.writeMessageBegin(new TMessage("dropEdge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropEdge", result);
      }

    }

    private class getEdge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getEdge", server_ctx);
        getEdge_args args = new getEdge_args();
        event_handler_.preRead(handler_ctx, "MetaService.getEdge");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getEdge", args);
        getEdge_result result = new getEdge_result();
        result.success = iface_.getEdge(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getEdge", result);
        oprot.writeMessageBegin(new TMessage("getEdge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getEdge", result);
      }

    }

    private class listEdges implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listEdges", server_ctx);
        listEdges_args args = new listEdges_args();
        event_handler_.preRead(handler_ctx, "MetaService.listEdges");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listEdges", args);
        listEdges_result result = new listEdges_result();
        result.success = iface_.listEdges(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listEdges", result);
        oprot.writeMessageBegin(new TMessage("listEdges", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listEdges", result);
      }

    }

    private class listHosts implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listHosts", server_ctx);
        listHosts_args args = new listHosts_args();
        event_handler_.preRead(handler_ctx, "MetaService.listHosts");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listHosts", args);
        listHosts_result result = new listHosts_result();
        result.success = iface_.listHosts(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listHosts", result);
        oprot.writeMessageBegin(new TMessage("listHosts", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listHosts", result);
      }

    }

    private class getPartsAlloc implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getPartsAlloc", server_ctx);
        getPartsAlloc_args args = new getPartsAlloc_args();
        event_handler_.preRead(handler_ctx, "MetaService.getPartsAlloc");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getPartsAlloc", args);
        getPartsAlloc_result result = new getPartsAlloc_result();
        result.success = iface_.getPartsAlloc(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getPartsAlloc", result);
        oprot.writeMessageBegin(new TMessage("getPartsAlloc", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getPartsAlloc", result);
      }

    }

    private class listParts implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listParts", server_ctx);
        listParts_args args = new listParts_args();
        event_handler_.preRead(handler_ctx, "MetaService.listParts");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listParts", args);
        listParts_result result = new listParts_result();
        result.success = iface_.listParts(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listParts", result);
        oprot.writeMessageBegin(new TMessage("listParts", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listParts", result);
      }

    }

    private class multiPut implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.multiPut", server_ctx);
        multiPut_args args = new multiPut_args();
        event_handler_.preRead(handler_ctx, "MetaService.multiPut");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.multiPut", args);
        multiPut_result result = new multiPut_result();
        result.success = iface_.multiPut(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.multiPut", result);
        oprot.writeMessageBegin(new TMessage("multiPut", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.multiPut", result);
      }

    }

    private class get implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.get", server_ctx);
        get_args args = new get_args();
        event_handler_.preRead(handler_ctx, "MetaService.get");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.get", args);
        get_result result = new get_result();
        result.success = iface_.get(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.get", result);
        oprot.writeMessageBegin(new TMessage("get", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.get", result);
      }

    }

    private class multiGet implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.multiGet", server_ctx);
        multiGet_args args = new multiGet_args();
        event_handler_.preRead(handler_ctx, "MetaService.multiGet");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.multiGet", args);
        multiGet_result result = new multiGet_result();
        result.success = iface_.multiGet(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.multiGet", result);
        oprot.writeMessageBegin(new TMessage("multiGet", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.multiGet", result);
      }

    }

    private class remove implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.remove", server_ctx);
        remove_args args = new remove_args();
        event_handler_.preRead(handler_ctx, "MetaService.remove");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.remove", args);
        remove_result result = new remove_result();
        result.success = iface_.remove(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.remove", result);
        oprot.writeMessageBegin(new TMessage("remove", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.remove", result);
      }

    }

    private class removeRange implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.removeRange", server_ctx);
        removeRange_args args = new removeRange_args();
        event_handler_.preRead(handler_ctx, "MetaService.removeRange");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.removeRange", args);
        removeRange_result result = new removeRange_result();
        result.success = iface_.removeRange(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.removeRange", result);
        oprot.writeMessageBegin(new TMessage("removeRange", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.removeRange", result);
      }

    }

    private class scan implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.scan", server_ctx);
        scan_args args = new scan_args();
        event_handler_.preRead(handler_ctx, "MetaService.scan");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.scan", args);
        scan_result result = new scan_result();
        result.success = iface_.scan(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.scan", result);
        oprot.writeMessageBegin(new TMessage("scan", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.scan", result);
      }

    }

    private class createTagIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createTagIndex", server_ctx);
        createTagIndex_args args = new createTagIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.createTagIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createTagIndex", args);
        createTagIndex_result result = new createTagIndex_result();
        result.success = iface_.createTagIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createTagIndex", result);
        oprot.writeMessageBegin(new TMessage("createTagIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createTagIndex", result);
      }

    }

    private class dropTagIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropTagIndex", server_ctx);
        dropTagIndex_args args = new dropTagIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropTagIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropTagIndex", args);
        dropTagIndex_result result = new dropTagIndex_result();
        result.success = iface_.dropTagIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropTagIndex", result);
        oprot.writeMessageBegin(new TMessage("dropTagIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropTagIndex", result);
      }

    }

    private class getTagIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getTagIndex", server_ctx);
        getTagIndex_args args = new getTagIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.getTagIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getTagIndex", args);
        getTagIndex_result result = new getTagIndex_result();
        result.success = iface_.getTagIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getTagIndex", result);
        oprot.writeMessageBegin(new TMessage("getTagIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getTagIndex", result);
      }

    }

    private class listTagIndexes implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listTagIndexes", server_ctx);
        listTagIndexes_args args = new listTagIndexes_args();
        event_handler_.preRead(handler_ctx, "MetaService.listTagIndexes");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listTagIndexes", args);
        listTagIndexes_result result = new listTagIndexes_result();
        result.success = iface_.listTagIndexes(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listTagIndexes", result);
        oprot.writeMessageBegin(new TMessage("listTagIndexes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listTagIndexes", result);
      }

    }

    private class createEdgeIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createEdgeIndex", server_ctx);
        createEdgeIndex_args args = new createEdgeIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.createEdgeIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createEdgeIndex", args);
        createEdgeIndex_result result = new createEdgeIndex_result();
        result.success = iface_.createEdgeIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createEdgeIndex", result);
        oprot.writeMessageBegin(new TMessage("createEdgeIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createEdgeIndex", result);
      }

    }

    private class dropEdgeIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropEdgeIndex", server_ctx);
        dropEdgeIndex_args args = new dropEdgeIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropEdgeIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropEdgeIndex", args);
        dropEdgeIndex_result result = new dropEdgeIndex_result();
        result.success = iface_.dropEdgeIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropEdgeIndex", result);
        oprot.writeMessageBegin(new TMessage("dropEdgeIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropEdgeIndex", result);
      }

    }

    private class getEdgeIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getEdgeIndex", server_ctx);
        getEdgeIndex_args args = new getEdgeIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.getEdgeIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getEdgeIndex", args);
        getEdgeIndex_result result = new getEdgeIndex_result();
        result.success = iface_.getEdgeIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getEdgeIndex", result);
        oprot.writeMessageBegin(new TMessage("getEdgeIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getEdgeIndex", result);
      }

    }

    private class listEdgeIndexes implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listEdgeIndexes", server_ctx);
        listEdgeIndexes_args args = new listEdgeIndexes_args();
        event_handler_.preRead(handler_ctx, "MetaService.listEdgeIndexes");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listEdgeIndexes", args);
        listEdgeIndexes_result result = new listEdgeIndexes_result();
        result.success = iface_.listEdgeIndexes(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listEdgeIndexes", result);
        oprot.writeMessageBegin(new TMessage("listEdgeIndexes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listEdgeIndexes", result);
      }

    }

    private class createUser implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createUser", server_ctx);
        createUser_args args = new createUser_args();
        event_handler_.preRead(handler_ctx, "MetaService.createUser");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createUser", args);
        createUser_result result = new createUser_result();
        result.success = iface_.createUser(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createUser", result);
        oprot.writeMessageBegin(new TMessage("createUser", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createUser", result);
      }

    }

    private class dropUser implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropUser", server_ctx);
        dropUser_args args = new dropUser_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropUser");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropUser", args);
        dropUser_result result = new dropUser_result();
        result.success = iface_.dropUser(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropUser", result);
        oprot.writeMessageBegin(new TMessage("dropUser", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropUser", result);
      }

    }

    private class alterUser implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.alterUser", server_ctx);
        alterUser_args args = new alterUser_args();
        event_handler_.preRead(handler_ctx, "MetaService.alterUser");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.alterUser", args);
        alterUser_result result = new alterUser_result();
        result.success = iface_.alterUser(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.alterUser", result);
        oprot.writeMessageBegin(new TMessage("alterUser", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.alterUser", result);
      }

    }

    private class grantRole implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.grantRole", server_ctx);
        grantRole_args args = new grantRole_args();
        event_handler_.preRead(handler_ctx, "MetaService.grantRole");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.grantRole", args);
        grantRole_result result = new grantRole_result();
        result.success = iface_.grantRole(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.grantRole", result);
        oprot.writeMessageBegin(new TMessage("grantRole", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.grantRole", result);
      }

    }

    private class revokeRole implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.revokeRole", server_ctx);
        revokeRole_args args = new revokeRole_args();
        event_handler_.preRead(handler_ctx, "MetaService.revokeRole");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.revokeRole", args);
        revokeRole_result result = new revokeRole_result();
        result.success = iface_.revokeRole(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.revokeRole", result);
        oprot.writeMessageBegin(new TMessage("revokeRole", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.revokeRole", result);
      }

    }

    private class getUser implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getUser", server_ctx);
        getUser_args args = new getUser_args();
        event_handler_.preRead(handler_ctx, "MetaService.getUser");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getUser", args);
        getUser_result result = new getUser_result();
        result.success = iface_.getUser(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getUser", result);
        oprot.writeMessageBegin(new TMessage("getUser", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getUser", result);
      }

    }

    private class listUsers implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listUsers", server_ctx);
        listUsers_args args = new listUsers_args();
        event_handler_.preRead(handler_ctx, "MetaService.listUsers");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listUsers", args);
        listUsers_result result = new listUsers_result();
        result.success = iface_.listUsers(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listUsers", result);
        oprot.writeMessageBegin(new TMessage("listUsers", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listUsers", result);
      }

    }

    private class listRoles implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listRoles", server_ctx);
        listRoles_args args = new listRoles_args();
        event_handler_.preRead(handler_ctx, "MetaService.listRoles");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listRoles", args);
        listRoles_result result = new listRoles_result();
        result.success = iface_.listRoles(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listRoles", result);
        oprot.writeMessageBegin(new TMessage("listRoles", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listRoles", result);
      }

    }

    private class changePassword implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.changePassword", server_ctx);
        changePassword_args args = new changePassword_args();
        event_handler_.preRead(handler_ctx, "MetaService.changePassword");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.changePassword", args);
        changePassword_result result = new changePassword_result();
        result.success = iface_.changePassword(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.changePassword", result);
        oprot.writeMessageBegin(new TMessage("changePassword", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.changePassword", result);
      }

    }

    private class checkPassword implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.checkPassword", server_ctx);
        checkPassword_args args = new checkPassword_args();
        event_handler_.preRead(handler_ctx, "MetaService.checkPassword");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.checkPassword", args);
        checkPassword_result result = new checkPassword_result();
        result.success = iface_.checkPassword(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.checkPassword", result);
        oprot.writeMessageBegin(new TMessage("checkPassword", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.checkPassword", result);
      }

    }

    private class heartBeat implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.heartBeat", server_ctx);
        heartBeat_args args = new heartBeat_args();
        event_handler_.preRead(handler_ctx, "MetaService.heartBeat");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.heartBeat", args);
        heartBeat_result result = new heartBeat_result();
        result.success = iface_.heartBeat(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.heartBeat", result);
        oprot.writeMessageBegin(new TMessage("heartBeat", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.heartBeat", result);
      }

    }

    private class balance implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.balance", server_ctx);
        balance_args args = new balance_args();
        event_handler_.preRead(handler_ctx, "MetaService.balance");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.balance", args);
        balance_result result = new balance_result();
        result.success = iface_.balance(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.balance", result);
        oprot.writeMessageBegin(new TMessage("balance", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.balance", result);
      }

    }

    private class leaderBalance implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.leaderBalance", server_ctx);
        leaderBalance_args args = new leaderBalance_args();
        event_handler_.preRead(handler_ctx, "MetaService.leaderBalance");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.leaderBalance", args);
        leaderBalance_result result = new leaderBalance_result();
        result.success = iface_.leaderBalance(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.leaderBalance", result);
        oprot.writeMessageBegin(new TMessage("leaderBalance", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.leaderBalance", result);
      }

    }

    private class regConfig implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.regConfig", server_ctx);
        regConfig_args args = new regConfig_args();
        event_handler_.preRead(handler_ctx, "MetaService.regConfig");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.regConfig", args);
        regConfig_result result = new regConfig_result();
        result.success = iface_.regConfig(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.regConfig", result);
        oprot.writeMessageBegin(new TMessage("regConfig", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.regConfig", result);
      }

    }

    private class getConfig implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getConfig", server_ctx);
        getConfig_args args = new getConfig_args();
        event_handler_.preRead(handler_ctx, "MetaService.getConfig");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getConfig", args);
        getConfig_result result = new getConfig_result();
        result.success = iface_.getConfig(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getConfig", result);
        oprot.writeMessageBegin(new TMessage("getConfig", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getConfig", result);
      }

    }

    private class setConfig implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.setConfig", server_ctx);
        setConfig_args args = new setConfig_args();
        event_handler_.preRead(handler_ctx, "MetaService.setConfig");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.setConfig", args);
        setConfig_result result = new setConfig_result();
        result.success = iface_.setConfig(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.setConfig", result);
        oprot.writeMessageBegin(new TMessage("setConfig", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.setConfig", result);
      }

    }

    private class listConfigs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listConfigs", server_ctx);
        listConfigs_args args = new listConfigs_args();
        event_handler_.preRead(handler_ctx, "MetaService.listConfigs");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listConfigs", args);
        listConfigs_result result = new listConfigs_result();
        result.success = iface_.listConfigs(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listConfigs", result);
        oprot.writeMessageBegin(new TMessage("listConfigs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listConfigs", result);
      }

    }

    private class createSnapshot implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createSnapshot", server_ctx);
        createSnapshot_args args = new createSnapshot_args();
        event_handler_.preRead(handler_ctx, "MetaService.createSnapshot");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createSnapshot", args);
        createSnapshot_result result = new createSnapshot_result();
        result.success = iface_.createSnapshot(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createSnapshot", result);
        oprot.writeMessageBegin(new TMessage("createSnapshot", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createSnapshot", result);
      }

    }

    private class dropSnapshot implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropSnapshot", server_ctx);
        dropSnapshot_args args = new dropSnapshot_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropSnapshot");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropSnapshot", args);
        dropSnapshot_result result = new dropSnapshot_result();
        result.success = iface_.dropSnapshot(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropSnapshot", result);
        oprot.writeMessageBegin(new TMessage("dropSnapshot", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropSnapshot", result);
      }

    }

    private class listSnapshots implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listSnapshots", server_ctx);
        listSnapshots_args args = new listSnapshots_args();
        event_handler_.preRead(handler_ctx, "MetaService.listSnapshots");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listSnapshots", args);
        listSnapshots_result result = new listSnapshots_result();
        result.success = iface_.listSnapshots(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listSnapshots", result);
        oprot.writeMessageBegin(new TMessage("listSnapshots", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listSnapshots", result);
      }

    }

    private class runAdminJob implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.runAdminJob", server_ctx);
        runAdminJob_args args = new runAdminJob_args();
        event_handler_.preRead(handler_ctx, "MetaService.runAdminJob");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.runAdminJob", args);
        runAdminJob_result result = new runAdminJob_result();
        result.success = iface_.runAdminJob(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.runAdminJob", result);
        oprot.writeMessageBegin(new TMessage("runAdminJob", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.runAdminJob", result);
      }

    }

  }

  public static class createSpace_args implements TBase, java.io.Serializable, Cloneable, Comparable<createSpace_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSpace_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateSpaceReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateSpaceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSpace_args.class, metaDataMap);
    }

    public createSpace_args() {
    }

    public createSpace_args(
      CreateSpaceReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSpace_args(createSpace_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createSpace_args deepCopy() {
      return new createSpace_args(this);
    }

    @Deprecated
    public createSpace_args clone() {
      return new createSpace_args(this);
    }

    public CreateSpaceReq  getReq() {
      return this.req;
    }

    public createSpace_args setReq(CreateSpaceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((CreateSpaceReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createSpace_args)
        return this.equals((createSpace_args)that);
      return false;
    }

    public boolean equals(createSpace_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createSpace_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new CreateSpaceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSpace_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createSpace_result implements TBase, java.io.Serializable, Cloneable, Comparable<createSpace_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSpace_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSpace_result.class, metaDataMap);
    }

    public createSpace_result() {
    }

    public createSpace_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSpace_result(createSpace_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createSpace_result deepCopy() {
      return new createSpace_result(this);
    }

    @Deprecated
    public createSpace_result clone() {
      return new createSpace_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public createSpace_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createSpace_result)
        return this.equals((createSpace_result)that);
      return false;
    }

    public boolean equals(createSpace_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createSpace_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSpace_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropSpace_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropSpace_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropSpace_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropSpaceReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropSpaceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropSpace_args.class, metaDataMap);
    }

    public dropSpace_args() {
    }

    public dropSpace_args(
      DropSpaceReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropSpace_args(dropSpace_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropSpace_args deepCopy() {
      return new dropSpace_args(this);
    }

    @Deprecated
    public dropSpace_args clone() {
      return new dropSpace_args(this);
    }

    public DropSpaceReq  getReq() {
      return this.req;
    }

    public dropSpace_args setReq(DropSpaceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((DropSpaceReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropSpace_args)
        return this.equals((dropSpace_args)that);
      return false;
    }

    public boolean equals(dropSpace_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropSpace_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new DropSpaceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropSpace_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropSpace_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropSpace_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropSpace_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropSpace_result.class, metaDataMap);
    }

    public dropSpace_result() {
    }

    public dropSpace_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropSpace_result(dropSpace_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropSpace_result deepCopy() {
      return new dropSpace_result(this);
    }

    @Deprecated
    public dropSpace_result clone() {
      return new dropSpace_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public dropSpace_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropSpace_result)
        return this.equals((dropSpace_result)that);
      return false;
    }

    public boolean equals(dropSpace_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropSpace_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropSpace_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getSpace_args implements TBase, java.io.Serializable, Cloneable, Comparable<getSpace_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getSpace_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetSpaceReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetSpaceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getSpace_args.class, metaDataMap);
    }

    public getSpace_args() {
    }

    public getSpace_args(
      GetSpaceReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getSpace_args(getSpace_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getSpace_args deepCopy() {
      return new getSpace_args(this);
    }

    @Deprecated
    public getSpace_args clone() {
      return new getSpace_args(this);
    }

    public GetSpaceReq  getReq() {
      return this.req;
    }

    public getSpace_args setReq(GetSpaceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetSpaceReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getSpace_args)
        return this.equals((getSpace_args)that);
      return false;
    }

    public boolean equals(getSpace_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getSpace_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetSpaceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getSpace_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getSpace_result implements TBase, java.io.Serializable, Cloneable, Comparable<getSpace_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getSpace_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetSpaceResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetSpaceResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getSpace_result.class, metaDataMap);
    }

    public getSpace_result() {
    }

    public getSpace_result(
      GetSpaceResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getSpace_result(getSpace_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getSpace_result deepCopy() {
      return new getSpace_result(this);
    }

    @Deprecated
    public getSpace_result clone() {
      return new getSpace_result(this);
    }

    public GetSpaceResp  getSuccess() {
      return this.success;
    }

    public getSpace_result setSuccess(GetSpaceResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetSpaceResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getSpace_result)
        return this.equals((getSpace_result)that);
      return false;
    }

    public boolean equals(getSpace_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getSpace_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GetSpaceResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getSpace_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listSpaces_args implements TBase, java.io.Serializable, Cloneable, Comparable<listSpaces_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSpaces_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListSpacesReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSpacesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSpaces_args.class, metaDataMap);
    }

    public listSpaces_args() {
    }

    public listSpaces_args(
      ListSpacesReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSpaces_args(listSpaces_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listSpaces_args deepCopy() {
      return new listSpaces_args(this);
    }

    @Deprecated
    public listSpaces_args clone() {
      return new listSpaces_args(this);
    }

    public ListSpacesReq  getReq() {
      return this.req;
    }

    public listSpaces_args setReq(ListSpacesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListSpacesReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listSpaces_args)
        return this.equals((listSpaces_args)that);
      return false;
    }

    public boolean equals(listSpaces_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listSpaces_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListSpacesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSpaces_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listSpaces_result implements TBase, java.io.Serializable, Cloneable, Comparable<listSpaces_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSpaces_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListSpacesResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSpacesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSpaces_result.class, metaDataMap);
    }

    public listSpaces_result() {
    }

    public listSpaces_result(
      ListSpacesResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSpaces_result(listSpaces_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listSpaces_result deepCopy() {
      return new listSpaces_result(this);
    }

    @Deprecated
    public listSpaces_result clone() {
      return new listSpaces_result(this);
    }

    public ListSpacesResp  getSuccess() {
      return this.success;
    }

    public listSpaces_result setSuccess(ListSpacesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListSpacesResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listSpaces_result)
        return this.equals((listSpaces_result)that);
      return false;
    }

    public boolean equals(listSpaces_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listSpaces_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListSpacesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSpaces_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createTag_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("createTag_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateTagReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateTagReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createTag_args.class, metaDataMap);
    }

    public createTag_args() {
    }

    public createTag_args(
      CreateTagReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTag_args(createTag_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createTag_args deepCopy() {
      return new createTag_args(this);
    }

    @Deprecated
    public createTag_args clone() {
      return new createTag_args(this);
    }

    public CreateTagReq  getReq() {
      return this.req;
    }

    public createTag_args setReq(CreateTagReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((CreateTagReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createTag_args)
        return this.equals((createTag_args)that);
      return false;
    }

    public boolean equals(createTag_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new CreateTagReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createTag_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createTag_result implements TBase, java.io.Serializable, Cloneable, Comparable<createTag_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createTag_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createTag_result.class, metaDataMap);
    }

    public createTag_result() {
    }

    public createTag_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTag_result(createTag_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createTag_result deepCopy() {
      return new createTag_result(this);
    }

    @Deprecated
    public createTag_result clone() {
      return new createTag_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public createTag_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createTag_result)
        return this.equals((createTag_result)that);
      return false;
    }

    public boolean equals(createTag_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createTag_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createTag_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class alterTag_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("alterTag_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AlterTagReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AlterTagReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterTag_args.class, metaDataMap);
    }

    public alterTag_args() {
    }

    public alterTag_args(
      AlterTagReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterTag_args(alterTag_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public alterTag_args deepCopy() {
      return new alterTag_args(this);
    }

    @Deprecated
    public alterTag_args clone() {
      return new alterTag_args(this);
    }

    public AlterTagReq  getReq() {
      return this.req;
    }

    public alterTag_args setReq(AlterTagReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((AlterTagReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alterTag_args)
        return this.equals((alterTag_args)that);
      return false;
    }

    public boolean equals(alterTag_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new AlterTagReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterTag_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class alterTag_result implements TBase, java.io.Serializable, Cloneable, Comparable<alterTag_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterTag_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterTag_result.class, metaDataMap);
    }

    public alterTag_result() {
    }

    public alterTag_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterTag_result(alterTag_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public alterTag_result deepCopy() {
      return new alterTag_result(this);
    }

    @Deprecated
    public alterTag_result clone() {
      return new alterTag_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public alterTag_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alterTag_result)
        return this.equals((alterTag_result)that);
      return false;
    }

    public boolean equals(alterTag_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(alterTag_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterTag_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropTag_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropTag_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTag_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropTagReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropTagReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropTag_args.class, metaDataMap);
    }

    public dropTag_args() {
    }

    public dropTag_args(
      DropTagReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTag_args(dropTag_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropTag_args deepCopy() {
      return new dropTag_args(this);
    }

    @Deprecated
    public dropTag_args clone() {
      return new dropTag_args(this);
    }

    public DropTagReq  getReq() {
      return this.req;
    }

    public dropTag_args setReq(DropTagReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((DropTagReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropTag_args)
        return this.equals((dropTag_args)that);
      return false;
    }

    public boolean equals(dropTag_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropTag_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new DropTagReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropTag_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropTag_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropTag_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTag_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropTag_result.class, metaDataMap);
    }

    public dropTag_result() {
    }

    public dropTag_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTag_result(dropTag_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropTag_result deepCopy() {
      return new dropTag_result(this);
    }

    @Deprecated
    public dropTag_result clone() {
      return new dropTag_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public dropTag_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropTag_result)
        return this.equals((dropTag_result)that);
      return false;
    }

    public boolean equals(dropTag_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropTag_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropTag_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getTag_args implements TBase, java.io.Serializable, Cloneable, Comparable<getTag_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getTag_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetTagReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetTagReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getTag_args.class, metaDataMap);
    }

    public getTag_args() {
    }

    public getTag_args(
      GetTagReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTag_args(getTag_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getTag_args deepCopy() {
      return new getTag_args(this);
    }

    @Deprecated
    public getTag_args clone() {
      return new getTag_args(this);
    }

    public GetTagReq  getReq() {
      return this.req;
    }

    public getTag_args setReq(GetTagReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetTagReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTag_args)
        return this.equals((getTag_args)that);
      return false;
    }

    public boolean equals(getTag_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getTag_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetTagReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getTag_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getTag_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTag_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetTagResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetTagResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getTag_result.class, metaDataMap);
    }

    public getTag_result() {
    }

    public getTag_result(
      GetTagResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTag_result(getTag_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getTag_result deepCopy() {
      return new getTag_result(this);
    }

    @Deprecated
    public getTag_result clone() {
      return new getTag_result(this);
    }

    public GetTagResp  getSuccess() {
      return this.success;
    }

    public getTag_result setSuccess(GetTagResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetTagResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTag_result)
        return this.equals((getTag_result)that);
      return false;
    }

    public boolean equals(getTag_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GetTagResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getTag_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listTags_args implements TBase, java.io.Serializable, Cloneable, Comparable<listTags_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTags_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListTagsReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListTagsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTags_args.class, metaDataMap);
    }

    public listTags_args() {
    }

    public listTags_args(
      ListTagsReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTags_args(listTags_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listTags_args deepCopy() {
      return new listTags_args(this);
    }

    @Deprecated
    public listTags_args clone() {
      return new listTags_args(this);
    }

    public ListTagsReq  getReq() {
      return this.req;
    }

    public listTags_args setReq(ListTagsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListTagsReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listTags_args)
        return this.equals((listTags_args)that);
      return false;
    }

    public boolean equals(listTags_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listTags_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListTagsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTags_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listTags_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("listTags_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListTagsResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListTagsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTags_result.class, metaDataMap);
    }

    public listTags_result() {
    }

    public listTags_result(
      ListTagsResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTags_result(listTags_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listTags_result deepCopy() {
      return new listTags_result(this);
    }

    @Deprecated
    public listTags_result clone() {
      return new listTags_result(this);
    }

    public ListTagsResp  getSuccess() {
      return this.success;
    }

    public listTags_result setSuccess(ListTagsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListTagsResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listTags_result)
        return this.equals((listTags_result)that);
      return false;
    }

    public boolean equals(listTags_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListTagsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTags_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createEdge_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("createEdge_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateEdgeReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateEdgeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createEdge_args.class, metaDataMap);
    }

    public createEdge_args() {
    }

    public createEdge_args(
      CreateEdgeReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createEdge_args(createEdge_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createEdge_args deepCopy() {
      return new createEdge_args(this);
    }

    @Deprecated
    public createEdge_args clone() {
      return new createEdge_args(this);
    }

    public CreateEdgeReq  getReq() {
      return this.req;
    }

    public createEdge_args setReq(CreateEdgeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((CreateEdgeReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createEdge_args)
        return this.equals((createEdge_args)that);
      return false;
    }

    public boolean equals(createEdge_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new CreateEdgeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createEdge_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createEdge_result implements TBase, java.io.Serializable, Cloneable, Comparable<createEdge_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createEdge_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createEdge_result.class, metaDataMap);
    }

    public createEdge_result() {
    }

    public createEdge_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createEdge_result(createEdge_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createEdge_result deepCopy() {
      return new createEdge_result(this);
    }

    @Deprecated
    public createEdge_result clone() {
      return new createEdge_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public createEdge_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createEdge_result)
        return this.equals((createEdge_result)that);
      return false;
    }

    public boolean equals(createEdge_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createEdge_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createEdge_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class alterEdge_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("alterEdge_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AlterEdgeReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AlterEdgeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterEdge_args.class, metaDataMap);
    }

    public alterEdge_args() {
    }

    public alterEdge_args(
      AlterEdgeReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterEdge_args(alterEdge_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public alterEdge_args deepCopy() {
      return new alterEdge_args(this);
    }

    @Deprecated
    public alterEdge_args clone() {
      return new alterEdge_args(this);
    }

    public AlterEdgeReq  getReq() {
      return this.req;
    }

    public alterEdge_args setReq(AlterEdgeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((AlterEdgeReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alterEdge_args)
        return this.equals((alterEdge_args)that);
      return false;
    }

    public boolean equals(alterEdge_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new AlterEdgeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterEdge_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class alterEdge_result implements TBase, java.io.Serializable, Cloneable, Comparable<alterEdge_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterEdge_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterEdge_result.class, metaDataMap);
    }

    public alterEdge_result() {
    }

    public alterEdge_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterEdge_result(alterEdge_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public alterEdge_result deepCopy() {
      return new alterEdge_result(this);
    }

    @Deprecated
    public alterEdge_result clone() {
      return new alterEdge_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public alterEdge_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alterEdge_result)
        return this.equals((alterEdge_result)that);
      return false;
    }

    public boolean equals(alterEdge_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(alterEdge_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterEdge_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropEdge_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropEdge_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropEdge_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropEdgeReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropEdgeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropEdge_args.class, metaDataMap);
    }

    public dropEdge_args() {
    }

    public dropEdge_args(
      DropEdgeReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropEdge_args(dropEdge_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropEdge_args deepCopy() {
      return new dropEdge_args(this);
    }

    @Deprecated
    public dropEdge_args clone() {
      return new dropEdge_args(this);
    }

    public DropEdgeReq  getReq() {
      return this.req;
    }

    public dropEdge_args setReq(DropEdgeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((DropEdgeReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropEdge_args)
        return this.equals((dropEdge_args)that);
      return false;
    }

    public boolean equals(dropEdge_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropEdge_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new DropEdgeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropEdge_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropEdge_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropEdge_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropEdge_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropEdge_result.class, metaDataMap);
    }

    public dropEdge_result() {
    }

    public dropEdge_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropEdge_result(dropEdge_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropEdge_result deepCopy() {
      return new dropEdge_result(this);
    }

    @Deprecated
    public dropEdge_result clone() {
      return new dropEdge_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public dropEdge_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropEdge_result)
        return this.equals((dropEdge_result)that);
      return false;
    }

    public boolean equals(dropEdge_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropEdge_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropEdge_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getEdge_args implements TBase, java.io.Serializable, Cloneable, Comparable<getEdge_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getEdge_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetEdgeReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetEdgeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getEdge_args.class, metaDataMap);
    }

    public getEdge_args() {
    }

    public getEdge_args(
      GetEdgeReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEdge_args(getEdge_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getEdge_args deepCopy() {
      return new getEdge_args(this);
    }

    @Deprecated
    public getEdge_args clone() {
      return new getEdge_args(this);
    }

    public GetEdgeReq  getReq() {
      return this.req;
    }

    public getEdge_args setReq(GetEdgeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetEdgeReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getEdge_args)
        return this.equals((getEdge_args)that);
      return false;
    }

    public boolean equals(getEdge_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getEdge_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetEdgeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getEdge_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getEdge_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getEdge_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetEdgeResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetEdgeResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getEdge_result.class, metaDataMap);
    }

    public getEdge_result() {
    }

    public getEdge_result(
      GetEdgeResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEdge_result(getEdge_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getEdge_result deepCopy() {
      return new getEdge_result(this);
    }

    @Deprecated
    public getEdge_result clone() {
      return new getEdge_result(this);
    }

    public GetEdgeResp  getSuccess() {
      return this.success;
    }

    public getEdge_result setSuccess(GetEdgeResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetEdgeResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getEdge_result)
        return this.equals((getEdge_result)that);
      return false;
    }

    public boolean equals(getEdge_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GetEdgeResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getEdge_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listEdges_args implements TBase, java.io.Serializable, Cloneable, Comparable<listEdges_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdges_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListEdgesReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListEdgesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdges_args.class, metaDataMap);
    }

    public listEdges_args() {
    }

    public listEdges_args(
      ListEdgesReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdges_args(listEdges_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listEdges_args deepCopy() {
      return new listEdges_args(this);
    }

    @Deprecated
    public listEdges_args clone() {
      return new listEdges_args(this);
    }

    public ListEdgesReq  getReq() {
      return this.req;
    }

    public listEdges_args setReq(ListEdgesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListEdgesReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listEdges_args)
        return this.equals((listEdges_args)that);
      return false;
    }

    public boolean equals(listEdges_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listEdges_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListEdgesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdges_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listEdges_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdges_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListEdgesResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListEdgesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdges_result.class, metaDataMap);
    }

    public listEdges_result() {
    }

    public listEdges_result(
      ListEdgesResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdges_result(listEdges_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listEdges_result deepCopy() {
      return new listEdges_result(this);
    }

    @Deprecated
    public listEdges_result clone() {
      return new listEdges_result(this);
    }

    public ListEdgesResp  getSuccess() {
      return this.success;
    }

    public listEdges_result setSuccess(ListEdgesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListEdgesResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listEdges_result)
        return this.equals((listEdges_result)that);
      return false;
    }

    public boolean equals(listEdges_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListEdgesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdges_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listHosts_args implements TBase, java.io.Serializable, Cloneable, Comparable<listHosts_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listHosts_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListHostsReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListHostsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listHosts_args.class, metaDataMap);
    }

    public listHosts_args() {
    }

    public listHosts_args(
      ListHostsReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listHosts_args(listHosts_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listHosts_args deepCopy() {
      return new listHosts_args(this);
    }

    @Deprecated
    public listHosts_args clone() {
      return new listHosts_args(this);
    }

    public ListHostsReq  getReq() {
      return this.req;
    }

    public listHosts_args setReq(ListHostsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListHostsReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listHosts_args)
        return this.equals((listHosts_args)that);
      return false;
    }

    public boolean equals(listHosts_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listHosts_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListHostsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listHosts_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listHosts_result implements TBase, java.io.Serializable, Cloneable, Comparable<listHosts_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listHosts_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListHostsResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListHostsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listHosts_result.class, metaDataMap);
    }

    public listHosts_result() {
    }

    public listHosts_result(
      ListHostsResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listHosts_result(listHosts_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listHosts_result deepCopy() {
      return new listHosts_result(this);
    }

    @Deprecated
    public listHosts_result clone() {
      return new listHosts_result(this);
    }

    public ListHostsResp  getSuccess() {
      return this.success;
    }

    public listHosts_result setSuccess(ListHostsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListHostsResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listHosts_result)
        return this.equals((listHosts_result)that);
      return false;
    }

    public boolean equals(listHosts_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listHosts_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListHostsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listHosts_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getPartsAlloc_args implements TBase, java.io.Serializable, Cloneable, Comparable<getPartsAlloc_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getPartsAlloc_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetPartsAllocReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetPartsAllocReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getPartsAlloc_args.class, metaDataMap);
    }

    public getPartsAlloc_args() {
    }

    public getPartsAlloc_args(
      GetPartsAllocReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPartsAlloc_args(getPartsAlloc_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getPartsAlloc_args deepCopy() {
      return new getPartsAlloc_args(this);
    }

    @Deprecated
    public getPartsAlloc_args clone() {
      return new getPartsAlloc_args(this);
    }

    public GetPartsAllocReq  getReq() {
      return this.req;
    }

    public getPartsAlloc_args setReq(GetPartsAllocReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetPartsAllocReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getPartsAlloc_args)
        return this.equals((getPartsAlloc_args)that);
      return false;
    }

    public boolean equals(getPartsAlloc_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getPartsAlloc_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetPartsAllocReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getPartsAlloc_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getPartsAlloc_result implements TBase, java.io.Serializable, Cloneable, Comparable<getPartsAlloc_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getPartsAlloc_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetPartsAllocResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetPartsAllocResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getPartsAlloc_result.class, metaDataMap);
    }

    public getPartsAlloc_result() {
    }

    public getPartsAlloc_result(
      GetPartsAllocResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPartsAlloc_result(getPartsAlloc_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getPartsAlloc_result deepCopy() {
      return new getPartsAlloc_result(this);
    }

    @Deprecated
    public getPartsAlloc_result clone() {
      return new getPartsAlloc_result(this);
    }

    public GetPartsAllocResp  getSuccess() {
      return this.success;
    }

    public getPartsAlloc_result setSuccess(GetPartsAllocResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetPartsAllocResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getPartsAlloc_result)
        return this.equals((getPartsAlloc_result)that);
      return false;
    }

    public boolean equals(getPartsAlloc_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getPartsAlloc_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GetPartsAllocResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getPartsAlloc_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listParts_args implements TBase, java.io.Serializable, Cloneable, Comparable<listParts_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listParts_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListPartsReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListPartsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listParts_args.class, metaDataMap);
    }

    public listParts_args() {
    }

    public listParts_args(
      ListPartsReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listParts_args(listParts_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listParts_args deepCopy() {
      return new listParts_args(this);
    }

    @Deprecated
    public listParts_args clone() {
      return new listParts_args(this);
    }

    public ListPartsReq  getReq() {
      return this.req;
    }

    public listParts_args setReq(ListPartsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListPartsReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listParts_args)
        return this.equals((listParts_args)that);
      return false;
    }

    public boolean equals(listParts_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listParts_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListPartsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listParts_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listParts_result implements TBase, java.io.Serializable, Cloneable, Comparable<listParts_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listParts_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListPartsResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListPartsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listParts_result.class, metaDataMap);
    }

    public listParts_result() {
    }

    public listParts_result(
      ListPartsResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listParts_result(listParts_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listParts_result deepCopy() {
      return new listParts_result(this);
    }

    @Deprecated
    public listParts_result clone() {
      return new listParts_result(this);
    }

    public ListPartsResp  getSuccess() {
      return this.success;
    }

    public listParts_result setSuccess(ListPartsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListPartsResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listParts_result)
        return this.equals((listParts_result)that);
      return false;
    }

    public boolean equals(listParts_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listParts_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListPartsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listParts_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class multiPut_args implements TBase, java.io.Serializable, Cloneable, Comparable<multiPut_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("multiPut_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public MultiPutReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, MultiPutReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(multiPut_args.class, metaDataMap);
    }

    public multiPut_args() {
    }

    public multiPut_args(
      MultiPutReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiPut_args(multiPut_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public multiPut_args deepCopy() {
      return new multiPut_args(this);
    }

    @Deprecated
    public multiPut_args clone() {
      return new multiPut_args(this);
    }

    public MultiPutReq  getReq() {
      return this.req;
    }

    public multiPut_args setReq(MultiPutReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((MultiPutReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof multiPut_args)
        return this.equals((multiPut_args)that);
      return false;
    }

    public boolean equals(multiPut_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(multiPut_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new MultiPutReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("multiPut_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class multiPut_result implements TBase, java.io.Serializable, Cloneable, Comparable<multiPut_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("multiPut_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(multiPut_result.class, metaDataMap);
    }

    public multiPut_result() {
    }

    public multiPut_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiPut_result(multiPut_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public multiPut_result deepCopy() {
      return new multiPut_result(this);
    }

    @Deprecated
    public multiPut_result clone() {
      return new multiPut_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public multiPut_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof multiPut_result)
        return this.equals((multiPut_result)that);
      return false;
    }

    public boolean equals(multiPut_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(multiPut_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("multiPut_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(get_args.class, metaDataMap);
    }

    public get_args() {
    }

    public get_args(
      GetReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_args(get_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public get_args deepCopy() {
      return new get_args(this);
    }

    @Deprecated
    public get_args clone() {
      return new get_args(this);
    }

    public GetReq  getReq() {
      return this.req;
    }

    public get_args setReq(GetReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_args)
        return this.equals((get_args)that);
      return false;
    }

    public boolean equals(get_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(get_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("get_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(get_result.class, metaDataMap);
    }

    public get_result() {
    }

    public get_result(
      GetResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_result(get_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public get_result deepCopy() {
      return new get_result(this);
    }

    @Deprecated
    public get_result clone() {
      return new get_result(this);
    }

    public GetResp  getSuccess() {
      return this.success;
    }

    public get_result setSuccess(GetResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_result)
        return this.equals((get_result)that);
      return false;
    }

    public boolean equals(get_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(get_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GetResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("get_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class multiGet_args implements TBase, java.io.Serializable, Cloneable, Comparable<multiGet_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("multiGet_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public MultiGetReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, MultiGetReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(multiGet_args.class, metaDataMap);
    }

    public multiGet_args() {
    }

    public multiGet_args(
      MultiGetReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiGet_args(multiGet_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public multiGet_args deepCopy() {
      return new multiGet_args(this);
    }

    @Deprecated
    public multiGet_args clone() {
      return new multiGet_args(this);
    }

    public MultiGetReq  getReq() {
      return this.req;
    }

    public multiGet_args setReq(MultiGetReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((MultiGetReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof multiGet_args)
        return this.equals((multiGet_args)that);
      return false;
    }

    public boolean equals(multiGet_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(multiGet_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new MultiGetReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("multiGet_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class multiGet_result implements TBase, java.io.Serializable, Cloneable, Comparable<multiGet_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("multiGet_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public MultiGetResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, MultiGetResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(multiGet_result.class, metaDataMap);
    }

    public multiGet_result() {
    }

    public multiGet_result(
      MultiGetResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiGet_result(multiGet_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public multiGet_result deepCopy() {
      return new multiGet_result(this);
    }

    @Deprecated
    public multiGet_result clone() {
      return new multiGet_result(this);
    }

    public MultiGetResp  getSuccess() {
      return this.success;
    }

    public multiGet_result setSuccess(MultiGetResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((MultiGetResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof multiGet_result)
        return this.equals((multiGet_result)that);
      return false;
    }

    public boolean equals(multiGet_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(multiGet_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new MultiGetResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("multiGet_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class remove_args implements TBase, java.io.Serializable, Cloneable, Comparable<remove_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RemoveReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RemoveReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(remove_args.class, metaDataMap);
    }

    public remove_args() {
    }

    public remove_args(
      RemoveReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_args(remove_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public remove_args deepCopy() {
      return new remove_args(this);
    }

    @Deprecated
    public remove_args clone() {
      return new remove_args(this);
    }

    public RemoveReq  getReq() {
      return this.req;
    }

    public remove_args setReq(RemoveReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((RemoveReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_args)
        return this.equals((remove_args)that);
      return false;
    }

    public boolean equals(remove_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(remove_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new RemoveReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("remove_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class remove_result implements TBase, java.io.Serializable, Cloneable, Comparable<remove_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(remove_result.class, metaDataMap);
    }

    public remove_result() {
    }

    public remove_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_result(remove_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public remove_result deepCopy() {
      return new remove_result(this);
    }

    @Deprecated
    public remove_result clone() {
      return new remove_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public remove_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_result)
        return this.equals((remove_result)that);
      return false;
    }

    public boolean equals(remove_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(remove_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("remove_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class removeRange_args implements TBase, java.io.Serializable, Cloneable, Comparable<removeRange_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeRange_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RemoveRangeReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RemoveRangeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(removeRange_args.class, metaDataMap);
    }

    public removeRange_args() {
    }

    public removeRange_args(
      RemoveRangeReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeRange_args(removeRange_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public removeRange_args deepCopy() {
      return new removeRange_args(this);
    }

    @Deprecated
    public removeRange_args clone() {
      return new removeRange_args(this);
    }

    public RemoveRangeReq  getReq() {
      return this.req;
    }

    public removeRange_args setReq(RemoveRangeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((RemoveRangeReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof removeRange_args)
        return this.equals((removeRange_args)that);
      return false;
    }

    public boolean equals(removeRange_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(removeRange_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new RemoveRangeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("removeRange_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class removeRange_result implements TBase, java.io.Serializable, Cloneable, Comparable<removeRange_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeRange_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(removeRange_result.class, metaDataMap);
    }

    public removeRange_result() {
    }

    public removeRange_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeRange_result(removeRange_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public removeRange_result deepCopy() {
      return new removeRange_result(this);
    }

    @Deprecated
    public removeRange_result clone() {
      return new removeRange_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public removeRange_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof removeRange_result)
        return this.equals((removeRange_result)that);
      return false;
    }

    public boolean equals(removeRange_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(removeRange_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("removeRange_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class scan_args implements TBase, java.io.Serializable, Cloneable, Comparable<scan_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("scan_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ScanReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ScanReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(scan_args.class, metaDataMap);
    }

    public scan_args() {
    }

    public scan_args(
      ScanReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scan_args(scan_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public scan_args deepCopy() {
      return new scan_args(this);
    }

    @Deprecated
    public scan_args clone() {
      return new scan_args(this);
    }

    public ScanReq  getReq() {
      return this.req;
    }

    public scan_args setReq(ScanReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ScanReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scan_args)
        return this.equals((scan_args)that);
      return false;
    }

    public boolean equals(scan_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(scan_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ScanReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("scan_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class scan_result implements TBase, java.io.Serializable, Cloneable, Comparable<scan_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("scan_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ScanResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ScanResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(scan_result.class, metaDataMap);
    }

    public scan_result() {
    }

    public scan_result(
      ScanResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scan_result(scan_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public scan_result deepCopy() {
      return new scan_result(this);
    }

    @Deprecated
    public scan_result clone() {
      return new scan_result(this);
    }

    public ScanResp  getSuccess() {
      return this.success;
    }

    public scan_result setSuccess(ScanResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ScanResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scan_result)
        return this.equals((scan_result)that);
      return false;
    }

    public boolean equals(scan_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(scan_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ScanResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("scan_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createTagIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<createTagIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createTagIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateTagIndexReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateTagIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createTagIndex_args.class, metaDataMap);
    }

    public createTagIndex_args() {
    }

    public createTagIndex_args(
      CreateTagIndexReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTagIndex_args(createTagIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createTagIndex_args deepCopy() {
      return new createTagIndex_args(this);
    }

    @Deprecated
    public createTagIndex_args clone() {
      return new createTagIndex_args(this);
    }

    public CreateTagIndexReq  getReq() {
      return this.req;
    }

    public createTagIndex_args setReq(CreateTagIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((CreateTagIndexReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createTagIndex_args)
        return this.equals((createTagIndex_args)that);
      return false;
    }

    public boolean equals(createTagIndex_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createTagIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new CreateTagIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createTagIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createTagIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<createTagIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createTagIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createTagIndex_result.class, metaDataMap);
    }

    public createTagIndex_result() {
    }

    public createTagIndex_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTagIndex_result(createTagIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createTagIndex_result deepCopy() {
      return new createTagIndex_result(this);
    }

    @Deprecated
    public createTagIndex_result clone() {
      return new createTagIndex_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public createTagIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createTagIndex_result)
        return this.equals((createTagIndex_result)that);
      return false;
    }

    public boolean equals(createTagIndex_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createTagIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createTagIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropTagIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropTagIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTagIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropTagIndexReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropTagIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropTagIndex_args.class, metaDataMap);
    }

    public dropTagIndex_args() {
    }

    public dropTagIndex_args(
      DropTagIndexReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTagIndex_args(dropTagIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropTagIndex_args deepCopy() {
      return new dropTagIndex_args(this);
    }

    @Deprecated
    public dropTagIndex_args clone() {
      return new dropTagIndex_args(this);
    }

    public DropTagIndexReq  getReq() {
      return this.req;
    }

    public dropTagIndex_args setReq(DropTagIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((DropTagIndexReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropTagIndex_args)
        return this.equals((dropTagIndex_args)that);
      return false;
    }

    public boolean equals(dropTagIndex_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropTagIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new DropTagIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropTagIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropTagIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropTagIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTagIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropTagIndex_result.class, metaDataMap);
    }

    public dropTagIndex_result() {
    }

    public dropTagIndex_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTagIndex_result(dropTagIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropTagIndex_result deepCopy() {
      return new dropTagIndex_result(this);
    }

    @Deprecated
    public dropTagIndex_result clone() {
      return new dropTagIndex_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public dropTagIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropTagIndex_result)
        return this.equals((dropTagIndex_result)that);
      return false;
    }

    public boolean equals(dropTagIndex_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropTagIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropTagIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getTagIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<getTagIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getTagIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetTagIndexReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetTagIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getTagIndex_args.class, metaDataMap);
    }

    public getTagIndex_args() {
    }

    public getTagIndex_args(
      GetTagIndexReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTagIndex_args(getTagIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getTagIndex_args deepCopy() {
      return new getTagIndex_args(this);
    }

    @Deprecated
    public getTagIndex_args clone() {
      return new getTagIndex_args(this);
    }

    public GetTagIndexReq  getReq() {
      return this.req;
    }

    public getTagIndex_args setReq(GetTagIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetTagIndexReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTagIndex_args)
        return this.equals((getTagIndex_args)that);
      return false;
    }

    public boolean equals(getTagIndex_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getTagIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetTagIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getTagIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getTagIndex_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTagIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetTagIndexResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetTagIndexResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getTagIndex_result.class, metaDataMap);
    }

    public getTagIndex_result() {
    }

    public getTagIndex_result(
      GetTagIndexResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTagIndex_result(getTagIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getTagIndex_result deepCopy() {
      return new getTagIndex_result(this);
    }

    @Deprecated
    public getTagIndex_result clone() {
      return new getTagIndex_result(this);
    }

    public GetTagIndexResp  getSuccess() {
      return this.success;
    }

    public getTagIndex_result setSuccess(GetTagIndexResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetTagIndexResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTagIndex_result)
        return this.equals((getTagIndex_result)that);
      return false;
    }

    public boolean equals(getTagIndex_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GetTagIndexResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getTagIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listTagIndexes_args implements TBase, java.io.Serializable, Cloneable, Comparable<listTagIndexes_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTagIndexes_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListTagIndexesReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListTagIndexesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTagIndexes_args.class, metaDataMap);
    }

    public listTagIndexes_args() {
    }

    public listTagIndexes_args(
      ListTagIndexesReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTagIndexes_args(listTagIndexes_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listTagIndexes_args deepCopy() {
      return new listTagIndexes_args(this);
    }

    @Deprecated
    public listTagIndexes_args clone() {
      return new listTagIndexes_args(this);
    }

    public ListTagIndexesReq  getReq() {
      return this.req;
    }

    public listTagIndexes_args setReq(ListTagIndexesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListTagIndexesReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listTagIndexes_args)
        return this.equals((listTagIndexes_args)that);
      return false;
    }

    public boolean equals(listTagIndexes_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listTagIndexes_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListTagIndexesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTagIndexes_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listTagIndexes_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("listTagIndexes_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListTagIndexesResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListTagIndexesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTagIndexes_result.class, metaDataMap);
    }

    public listTagIndexes_result() {
    }

    public listTagIndexes_result(
      ListTagIndexesResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTagIndexes_result(listTagIndexes_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listTagIndexes_result deepCopy() {
      return new listTagIndexes_result(this);
    }

    @Deprecated
    public listTagIndexes_result clone() {
      return new listTagIndexes_result(this);
    }

    public ListTagIndexesResp  getSuccess() {
      return this.success;
    }

    public listTagIndexes_result setSuccess(ListTagIndexesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListTagIndexesResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listTagIndexes_result)
        return this.equals((listTagIndexes_result)that);
      return false;
    }

    public boolean equals(listTagIndexes_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListTagIndexesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTagIndexes_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createEdgeIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<createEdgeIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createEdgeIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateEdgeIndexReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateEdgeIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createEdgeIndex_args.class, metaDataMap);
    }

    public createEdgeIndex_args() {
    }

    public createEdgeIndex_args(
      CreateEdgeIndexReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createEdgeIndex_args(createEdgeIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createEdgeIndex_args deepCopy() {
      return new createEdgeIndex_args(this);
    }

    @Deprecated
    public createEdgeIndex_args clone() {
      return new createEdgeIndex_args(this);
    }

    public CreateEdgeIndexReq  getReq() {
      return this.req;
    }

    public createEdgeIndex_args setReq(CreateEdgeIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((CreateEdgeIndexReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createEdgeIndex_args)
        return this.equals((createEdgeIndex_args)that);
      return false;
    }

    public boolean equals(createEdgeIndex_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createEdgeIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new CreateEdgeIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createEdgeIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createEdgeIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<createEdgeIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createEdgeIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createEdgeIndex_result.class, metaDataMap);
    }

    public createEdgeIndex_result() {
    }

    public createEdgeIndex_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createEdgeIndex_result(createEdgeIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createEdgeIndex_result deepCopy() {
      return new createEdgeIndex_result(this);
    }

    @Deprecated
    public createEdgeIndex_result clone() {
      return new createEdgeIndex_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public createEdgeIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createEdgeIndex_result)
        return this.equals((createEdgeIndex_result)that);
      return false;
    }

    public boolean equals(createEdgeIndex_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createEdgeIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createEdgeIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropEdgeIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropEdgeIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropEdgeIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropEdgeIndexReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropEdgeIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropEdgeIndex_args.class, metaDataMap);
    }

    public dropEdgeIndex_args() {
    }

    public dropEdgeIndex_args(
      DropEdgeIndexReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropEdgeIndex_args(dropEdgeIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropEdgeIndex_args deepCopy() {
      return new dropEdgeIndex_args(this);
    }

    @Deprecated
    public dropEdgeIndex_args clone() {
      return new dropEdgeIndex_args(this);
    }

    public DropEdgeIndexReq  getReq() {
      return this.req;
    }

    public dropEdgeIndex_args setReq(DropEdgeIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((DropEdgeIndexReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropEdgeIndex_args)
        return this.equals((dropEdgeIndex_args)that);
      return false;
    }

    public boolean equals(dropEdgeIndex_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropEdgeIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new DropEdgeIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropEdgeIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropEdgeIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropEdgeIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropEdgeIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropEdgeIndex_result.class, metaDataMap);
    }

    public dropEdgeIndex_result() {
    }

    public dropEdgeIndex_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropEdgeIndex_result(dropEdgeIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropEdgeIndex_result deepCopy() {
      return new dropEdgeIndex_result(this);
    }

    @Deprecated
    public dropEdgeIndex_result clone() {
      return new dropEdgeIndex_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public dropEdgeIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropEdgeIndex_result)
        return this.equals((dropEdgeIndex_result)that);
      return false;
    }

    public boolean equals(dropEdgeIndex_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropEdgeIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropEdgeIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getEdgeIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<getEdgeIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getEdgeIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetEdgeIndexReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetEdgeIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getEdgeIndex_args.class, metaDataMap);
    }

    public getEdgeIndex_args() {
    }

    public getEdgeIndex_args(
      GetEdgeIndexReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEdgeIndex_args(getEdgeIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getEdgeIndex_args deepCopy() {
      return new getEdgeIndex_args(this);
    }

    @Deprecated
    public getEdgeIndex_args clone() {
      return new getEdgeIndex_args(this);
    }

    public GetEdgeIndexReq  getReq() {
      return this.req;
    }

    public getEdgeIndex_args setReq(GetEdgeIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetEdgeIndexReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getEdgeIndex_args)
        return this.equals((getEdgeIndex_args)that);
      return false;
    }

    public boolean equals(getEdgeIndex_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getEdgeIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetEdgeIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getEdgeIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getEdgeIndex_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getEdgeIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetEdgeIndexResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetEdgeIndexResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getEdgeIndex_result.class, metaDataMap);
    }

    public getEdgeIndex_result() {
    }

    public getEdgeIndex_result(
      GetEdgeIndexResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEdgeIndex_result(getEdgeIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getEdgeIndex_result deepCopy() {
      return new getEdgeIndex_result(this);
    }

    @Deprecated
    public getEdgeIndex_result clone() {
      return new getEdgeIndex_result(this);
    }

    public GetEdgeIndexResp  getSuccess() {
      return this.success;
    }

    public getEdgeIndex_result setSuccess(GetEdgeIndexResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetEdgeIndexResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getEdgeIndex_result)
        return this.equals((getEdgeIndex_result)that);
      return false;
    }

    public boolean equals(getEdgeIndex_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GetEdgeIndexResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getEdgeIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listEdgeIndexes_args implements TBase, java.io.Serializable, Cloneable, Comparable<listEdgeIndexes_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdgeIndexes_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListEdgeIndexesReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListEdgeIndexesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdgeIndexes_args.class, metaDataMap);
    }

    public listEdgeIndexes_args() {
    }

    public listEdgeIndexes_args(
      ListEdgeIndexesReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdgeIndexes_args(listEdgeIndexes_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listEdgeIndexes_args deepCopy() {
      return new listEdgeIndexes_args(this);
    }

    @Deprecated
    public listEdgeIndexes_args clone() {
      return new listEdgeIndexes_args(this);
    }

    public ListEdgeIndexesReq  getReq() {
      return this.req;
    }

    public listEdgeIndexes_args setReq(ListEdgeIndexesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListEdgeIndexesReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listEdgeIndexes_args)
        return this.equals((listEdgeIndexes_args)that);
      return false;
    }

    public boolean equals(listEdgeIndexes_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listEdgeIndexes_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListEdgeIndexesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdgeIndexes_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listEdgeIndexes_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdgeIndexes_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListEdgeIndexesResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListEdgeIndexesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdgeIndexes_result.class, metaDataMap);
    }

    public listEdgeIndexes_result() {
    }

    public listEdgeIndexes_result(
      ListEdgeIndexesResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdgeIndexes_result(listEdgeIndexes_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listEdgeIndexes_result deepCopy() {
      return new listEdgeIndexes_result(this);
    }

    @Deprecated
    public listEdgeIndexes_result clone() {
      return new listEdgeIndexes_result(this);
    }

    public ListEdgeIndexesResp  getSuccess() {
      return this.success;
    }

    public listEdgeIndexes_result setSuccess(ListEdgeIndexesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListEdgeIndexesResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listEdgeIndexes_result)
        return this.equals((listEdgeIndexes_result)that);
      return false;
    }

    public boolean equals(listEdgeIndexes_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListEdgeIndexesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdgeIndexes_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createUser_args implements TBase, java.io.Serializable, Cloneable, Comparable<createUser_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createUser_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateUserReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateUserReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createUser_args.class, metaDataMap);
    }

    public createUser_args() {
    }

    public createUser_args(
      CreateUserReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createUser_args(createUser_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createUser_args deepCopy() {
      return new createUser_args(this);
    }

    @Deprecated
    public createUser_args clone() {
      return new createUser_args(this);
    }

    public CreateUserReq  getReq() {
      return this.req;
    }

    public createUser_args setReq(CreateUserReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((CreateUserReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createUser_args)
        return this.equals((createUser_args)that);
      return false;
    }

    public boolean equals(createUser_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createUser_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new CreateUserReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createUser_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createUser_result implements TBase, java.io.Serializable, Cloneable, Comparable<createUser_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createUser_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createUser_result.class, metaDataMap);
    }

    public createUser_result() {
    }

    public createUser_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createUser_result(createUser_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createUser_result deepCopy() {
      return new createUser_result(this);
    }

    @Deprecated
    public createUser_result clone() {
      return new createUser_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public createUser_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createUser_result)
        return this.equals((createUser_result)that);
      return false;
    }

    public boolean equals(createUser_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createUser_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createUser_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropUser_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropUser_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropUser_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropUserReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropUserReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropUser_args.class, metaDataMap);
    }

    public dropUser_args() {
    }

    public dropUser_args(
      DropUserReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropUser_args(dropUser_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropUser_args deepCopy() {
      return new dropUser_args(this);
    }

    @Deprecated
    public dropUser_args clone() {
      return new dropUser_args(this);
    }

    public DropUserReq  getReq() {
      return this.req;
    }

    public dropUser_args setReq(DropUserReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((DropUserReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropUser_args)
        return this.equals((dropUser_args)that);
      return false;
    }

    public boolean equals(dropUser_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropUser_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new DropUserReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropUser_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropUser_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropUser_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropUser_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropUser_result.class, metaDataMap);
    }

    public dropUser_result() {
    }

    public dropUser_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropUser_result(dropUser_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropUser_result deepCopy() {
      return new dropUser_result(this);
    }

    @Deprecated
    public dropUser_result clone() {
      return new dropUser_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public dropUser_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropUser_result)
        return this.equals((dropUser_result)that);
      return false;
    }

    public boolean equals(dropUser_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropUser_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropUser_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class alterUser_args implements TBase, java.io.Serializable, Cloneable, Comparable<alterUser_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterUser_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AlterUserReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AlterUserReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterUser_args.class, metaDataMap);
    }

    public alterUser_args() {
    }

    public alterUser_args(
      AlterUserReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterUser_args(alterUser_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public alterUser_args deepCopy() {
      return new alterUser_args(this);
    }

    @Deprecated
    public alterUser_args clone() {
      return new alterUser_args(this);
    }

    public AlterUserReq  getReq() {
      return this.req;
    }

    public alterUser_args setReq(AlterUserReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((AlterUserReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alterUser_args)
        return this.equals((alterUser_args)that);
      return false;
    }

    public boolean equals(alterUser_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(alterUser_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new AlterUserReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterUser_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class alterUser_result implements TBase, java.io.Serializable, Cloneable, Comparable<alterUser_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterUser_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterUser_result.class, metaDataMap);
    }

    public alterUser_result() {
    }

    public alterUser_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterUser_result(alterUser_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public alterUser_result deepCopy() {
      return new alterUser_result(this);
    }

    @Deprecated
    public alterUser_result clone() {
      return new alterUser_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public alterUser_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alterUser_result)
        return this.equals((alterUser_result)that);
      return false;
    }

    public boolean equals(alterUser_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(alterUser_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterUser_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class grantRole_args implements TBase, java.io.Serializable, Cloneable, Comparable<grantRole_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("grantRole_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GrantRoleReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GrantRoleReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(grantRole_args.class, metaDataMap);
    }

    public grantRole_args() {
    }

    public grantRole_args(
      GrantRoleReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public grantRole_args(grantRole_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public grantRole_args deepCopy() {
      return new grantRole_args(this);
    }

    @Deprecated
    public grantRole_args clone() {
      return new grantRole_args(this);
    }

    public GrantRoleReq  getReq() {
      return this.req;
    }

    public grantRole_args setReq(GrantRoleReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GrantRoleReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof grantRole_args)
        return this.equals((grantRole_args)that);
      return false;
    }

    public boolean equals(grantRole_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(grantRole_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GrantRoleReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("grantRole_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class grantRole_result implements TBase, java.io.Serializable, Cloneable, Comparable<grantRole_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("grantRole_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(grantRole_result.class, metaDataMap);
    }

    public grantRole_result() {
    }

    public grantRole_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public grantRole_result(grantRole_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public grantRole_result deepCopy() {
      return new grantRole_result(this);
    }

    @Deprecated
    public grantRole_result clone() {
      return new grantRole_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public grantRole_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof grantRole_result)
        return this.equals((grantRole_result)that);
      return false;
    }

    public boolean equals(grantRole_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(grantRole_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("grantRole_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class revokeRole_args implements TBase, java.io.Serializable, Cloneable, Comparable<revokeRole_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("revokeRole_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RevokeRoleReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RevokeRoleReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(revokeRole_args.class, metaDataMap);
    }

    public revokeRole_args() {
    }

    public revokeRole_args(
      RevokeRoleReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public revokeRole_args(revokeRole_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public revokeRole_args deepCopy() {
      return new revokeRole_args(this);
    }

    @Deprecated
    public revokeRole_args clone() {
      return new revokeRole_args(this);
    }

    public RevokeRoleReq  getReq() {
      return this.req;
    }

    public revokeRole_args setReq(RevokeRoleReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((RevokeRoleReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof revokeRole_args)
        return this.equals((revokeRole_args)that);
      return false;
    }

    public boolean equals(revokeRole_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(revokeRole_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new RevokeRoleReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("revokeRole_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class revokeRole_result implements TBase, java.io.Serializable, Cloneable, Comparable<revokeRole_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("revokeRole_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(revokeRole_result.class, metaDataMap);
    }

    public revokeRole_result() {
    }

    public revokeRole_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public revokeRole_result(revokeRole_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public revokeRole_result deepCopy() {
      return new revokeRole_result(this);
    }

    @Deprecated
    public revokeRole_result clone() {
      return new revokeRole_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public revokeRole_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof revokeRole_result)
        return this.equals((revokeRole_result)that);
      return false;
    }

    public boolean equals(revokeRole_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(revokeRole_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("revokeRole_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getUser_args implements TBase, java.io.Serializable, Cloneable, Comparable<getUser_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getUser_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetUserReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetUserReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getUser_args.class, metaDataMap);
    }

    public getUser_args() {
    }

    public getUser_args(
      GetUserReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getUser_args(getUser_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getUser_args deepCopy() {
      return new getUser_args(this);
    }

    @Deprecated
    public getUser_args clone() {
      return new getUser_args(this);
    }

    public GetUserReq  getReq() {
      return this.req;
    }

    public getUser_args setReq(GetUserReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetUserReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getUser_args)
        return this.equals((getUser_args)that);
      return false;
    }

    public boolean equals(getUser_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getUser_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetUserReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getUser_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getUser_result implements TBase, java.io.Serializable, Cloneable, Comparable<getUser_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getUser_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetUserResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetUserResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getUser_result.class, metaDataMap);
    }

    public getUser_result() {
    }

    public getUser_result(
      GetUserResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getUser_result(getUser_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getUser_result deepCopy() {
      return new getUser_result(this);
    }

    @Deprecated
    public getUser_result clone() {
      return new getUser_result(this);
    }

    public GetUserResp  getSuccess() {
      return this.success;
    }

    public getUser_result setSuccess(GetUserResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetUserResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getUser_result)
        return this.equals((getUser_result)that);
      return false;
    }

    public boolean equals(getUser_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getUser_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GetUserResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getUser_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listUsers_args implements TBase, java.io.Serializable, Cloneable, Comparable<listUsers_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listUsers_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListUsersReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListUsersReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listUsers_args.class, metaDataMap);
    }

    public listUsers_args() {
    }

    public listUsers_args(
      ListUsersReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listUsers_args(listUsers_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listUsers_args deepCopy() {
      return new listUsers_args(this);
    }

    @Deprecated
    public listUsers_args clone() {
      return new listUsers_args(this);
    }

    public ListUsersReq  getReq() {
      return this.req;
    }

    public listUsers_args setReq(ListUsersReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListUsersReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listUsers_args)
        return this.equals((listUsers_args)that);
      return false;
    }

    public boolean equals(listUsers_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listUsers_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListUsersReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listUsers_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listUsers_result implements TBase, java.io.Serializable, Cloneable, Comparable<listUsers_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listUsers_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListUsersResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListUsersResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listUsers_result.class, metaDataMap);
    }

    public listUsers_result() {
    }

    public listUsers_result(
      ListUsersResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listUsers_result(listUsers_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listUsers_result deepCopy() {
      return new listUsers_result(this);
    }

    @Deprecated
    public listUsers_result clone() {
      return new listUsers_result(this);
    }

    public ListUsersResp  getSuccess() {
      return this.success;
    }

    public listUsers_result setSuccess(ListUsersResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListUsersResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listUsers_result)
        return this.equals((listUsers_result)that);
      return false;
    }

    public boolean equals(listUsers_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listUsers_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListUsersResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listUsers_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listRoles_args implements TBase, java.io.Serializable, Cloneable, Comparable<listRoles_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listRoles_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListRolesReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListRolesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listRoles_args.class, metaDataMap);
    }

    public listRoles_args() {
    }

    public listRoles_args(
      ListRolesReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listRoles_args(listRoles_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listRoles_args deepCopy() {
      return new listRoles_args(this);
    }

    @Deprecated
    public listRoles_args clone() {
      return new listRoles_args(this);
    }

    public ListRolesReq  getReq() {
      return this.req;
    }

    public listRoles_args setReq(ListRolesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListRolesReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listRoles_args)
        return this.equals((listRoles_args)that);
      return false;
    }

    public boolean equals(listRoles_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listRoles_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListRolesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listRoles_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listRoles_result implements TBase, java.io.Serializable, Cloneable, Comparable<listRoles_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listRoles_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListRolesResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListRolesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listRoles_result.class, metaDataMap);
    }

    public listRoles_result() {
    }

    public listRoles_result(
      ListRolesResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listRoles_result(listRoles_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listRoles_result deepCopy() {
      return new listRoles_result(this);
    }

    @Deprecated
    public listRoles_result clone() {
      return new listRoles_result(this);
    }

    public ListRolesResp  getSuccess() {
      return this.success;
    }

    public listRoles_result setSuccess(ListRolesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListRolesResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listRoles_result)
        return this.equals((listRoles_result)that);
      return false;
    }

    public boolean equals(listRoles_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listRoles_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListRolesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listRoles_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class changePassword_args implements TBase, java.io.Serializable, Cloneable, Comparable<changePassword_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("changePassword_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ChangePasswordReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ChangePasswordReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(changePassword_args.class, metaDataMap);
    }

    public changePassword_args() {
    }

    public changePassword_args(
      ChangePasswordReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public changePassword_args(changePassword_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public changePassword_args deepCopy() {
      return new changePassword_args(this);
    }

    @Deprecated
    public changePassword_args clone() {
      return new changePassword_args(this);
    }

    public ChangePasswordReq  getReq() {
      return this.req;
    }

    public changePassword_args setReq(ChangePasswordReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ChangePasswordReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof changePassword_args)
        return this.equals((changePassword_args)that);
      return false;
    }

    public boolean equals(changePassword_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(changePassword_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ChangePasswordReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("changePassword_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class changePassword_result implements TBase, java.io.Serializable, Cloneable, Comparable<changePassword_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("changePassword_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(changePassword_result.class, metaDataMap);
    }

    public changePassword_result() {
    }

    public changePassword_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public changePassword_result(changePassword_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public changePassword_result deepCopy() {
      return new changePassword_result(this);
    }

    @Deprecated
    public changePassword_result clone() {
      return new changePassword_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public changePassword_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof changePassword_result)
        return this.equals((changePassword_result)that);
      return false;
    }

    public boolean equals(changePassword_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(changePassword_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("changePassword_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class checkPassword_args implements TBase, java.io.Serializable, Cloneable, Comparable<checkPassword_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("checkPassword_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CheckPasswordReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CheckPasswordReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(checkPassword_args.class, metaDataMap);
    }

    public checkPassword_args() {
    }

    public checkPassword_args(
      CheckPasswordReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkPassword_args(checkPassword_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public checkPassword_args deepCopy() {
      return new checkPassword_args(this);
    }

    @Deprecated
    public checkPassword_args clone() {
      return new checkPassword_args(this);
    }

    public CheckPasswordReq  getReq() {
      return this.req;
    }

    public checkPassword_args setReq(CheckPasswordReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((CheckPasswordReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkPassword_args)
        return this.equals((checkPassword_args)that);
      return false;
    }

    public boolean equals(checkPassword_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(checkPassword_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new CheckPasswordReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("checkPassword_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class checkPassword_result implements TBase, java.io.Serializable, Cloneable, Comparable<checkPassword_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("checkPassword_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(checkPassword_result.class, metaDataMap);
    }

    public checkPassword_result() {
    }

    public checkPassword_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkPassword_result(checkPassword_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public checkPassword_result deepCopy() {
      return new checkPassword_result(this);
    }

    @Deprecated
    public checkPassword_result clone() {
      return new checkPassword_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public checkPassword_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkPassword_result)
        return this.equals((checkPassword_result)that);
      return false;
    }

    public boolean equals(checkPassword_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(checkPassword_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("checkPassword_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class heartBeat_args implements TBase, java.io.Serializable, Cloneable, Comparable<heartBeat_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("heartBeat_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public HBReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, HBReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(heartBeat_args.class, metaDataMap);
    }

    public heartBeat_args() {
    }

    public heartBeat_args(
      HBReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public heartBeat_args(heartBeat_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public heartBeat_args deepCopy() {
      return new heartBeat_args(this);
    }

    @Deprecated
    public heartBeat_args clone() {
      return new heartBeat_args(this);
    }

    public HBReq  getReq() {
      return this.req;
    }

    public heartBeat_args setReq(HBReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((HBReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof heartBeat_args)
        return this.equals((heartBeat_args)that);
      return false;
    }

    public boolean equals(heartBeat_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(heartBeat_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new HBReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("heartBeat_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class heartBeat_result implements TBase, java.io.Serializable, Cloneable, Comparable<heartBeat_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("heartBeat_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public HBResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, HBResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(heartBeat_result.class, metaDataMap);
    }

    public heartBeat_result() {
    }

    public heartBeat_result(
      HBResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public heartBeat_result(heartBeat_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public heartBeat_result deepCopy() {
      return new heartBeat_result(this);
    }

    @Deprecated
    public heartBeat_result clone() {
      return new heartBeat_result(this);
    }

    public HBResp  getSuccess() {
      return this.success;
    }

    public heartBeat_result setSuccess(HBResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((HBResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof heartBeat_result)
        return this.equals((heartBeat_result)that);
      return false;
    }

    public boolean equals(heartBeat_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(heartBeat_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new HBResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("heartBeat_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class balance_args implements TBase, java.io.Serializable, Cloneable, Comparable<balance_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("balance_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public BalanceReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, BalanceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(balance_args.class, metaDataMap);
    }

    public balance_args() {
    }

    public balance_args(
      BalanceReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public balance_args(balance_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public balance_args deepCopy() {
      return new balance_args(this);
    }

    @Deprecated
    public balance_args clone() {
      return new balance_args(this);
    }

    public BalanceReq  getReq() {
      return this.req;
    }

    public balance_args setReq(BalanceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((BalanceReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof balance_args)
        return this.equals((balance_args)that);
      return false;
    }

    public boolean equals(balance_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(balance_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new BalanceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("balance_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class balance_result implements TBase, java.io.Serializable, Cloneable, Comparable<balance_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("balance_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public BalanceResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, BalanceResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(balance_result.class, metaDataMap);
    }

    public balance_result() {
    }

    public balance_result(
      BalanceResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public balance_result(balance_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public balance_result deepCopy() {
      return new balance_result(this);
    }

    @Deprecated
    public balance_result clone() {
      return new balance_result(this);
    }

    public BalanceResp  getSuccess() {
      return this.success;
    }

    public balance_result setSuccess(BalanceResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((BalanceResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof balance_result)
        return this.equals((balance_result)that);
      return false;
    }

    public boolean equals(balance_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(balance_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new BalanceResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("balance_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class leaderBalance_args implements TBase, java.io.Serializable, Cloneable, Comparable<leaderBalance_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("leaderBalance_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public LeaderBalanceReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, LeaderBalanceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(leaderBalance_args.class, metaDataMap);
    }

    public leaderBalance_args() {
    }

    public leaderBalance_args(
      LeaderBalanceReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public leaderBalance_args(leaderBalance_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public leaderBalance_args deepCopy() {
      return new leaderBalance_args(this);
    }

    @Deprecated
    public leaderBalance_args clone() {
      return new leaderBalance_args(this);
    }

    public LeaderBalanceReq  getReq() {
      return this.req;
    }

    public leaderBalance_args setReq(LeaderBalanceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((LeaderBalanceReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof leaderBalance_args)
        return this.equals((leaderBalance_args)that);
      return false;
    }

    public boolean equals(leaderBalance_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(leaderBalance_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new LeaderBalanceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("leaderBalance_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class leaderBalance_result implements TBase, java.io.Serializable, Cloneable, Comparable<leaderBalance_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("leaderBalance_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(leaderBalance_result.class, metaDataMap);
    }

    public leaderBalance_result() {
    }

    public leaderBalance_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public leaderBalance_result(leaderBalance_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public leaderBalance_result deepCopy() {
      return new leaderBalance_result(this);
    }

    @Deprecated
    public leaderBalance_result clone() {
      return new leaderBalance_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public leaderBalance_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof leaderBalance_result)
        return this.equals((leaderBalance_result)that);
      return false;
    }

    public boolean equals(leaderBalance_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(leaderBalance_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("leaderBalance_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class regConfig_args implements TBase, java.io.Serializable, Cloneable, Comparable<regConfig_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("regConfig_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RegConfigReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RegConfigReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(regConfig_args.class, metaDataMap);
    }

    public regConfig_args() {
    }

    public regConfig_args(
      RegConfigReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public regConfig_args(regConfig_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public regConfig_args deepCopy() {
      return new regConfig_args(this);
    }

    @Deprecated
    public regConfig_args clone() {
      return new regConfig_args(this);
    }

    public RegConfigReq  getReq() {
      return this.req;
    }

    public regConfig_args setReq(RegConfigReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((RegConfigReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof regConfig_args)
        return this.equals((regConfig_args)that);
      return false;
    }

    public boolean equals(regConfig_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(regConfig_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new RegConfigReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("regConfig_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class regConfig_result implements TBase, java.io.Serializable, Cloneable, Comparable<regConfig_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("regConfig_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(regConfig_result.class, metaDataMap);
    }

    public regConfig_result() {
    }

    public regConfig_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public regConfig_result(regConfig_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public regConfig_result deepCopy() {
      return new regConfig_result(this);
    }

    @Deprecated
    public regConfig_result clone() {
      return new regConfig_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public regConfig_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof regConfig_result)
        return this.equals((regConfig_result)that);
      return false;
    }

    public boolean equals(regConfig_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(regConfig_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("regConfig_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getConfig_args implements TBase, java.io.Serializable, Cloneable, Comparable<getConfig_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getConfig_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetConfigReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetConfigReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getConfig_args.class, metaDataMap);
    }

    public getConfig_args() {
    }

    public getConfig_args(
      GetConfigReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConfig_args(getConfig_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getConfig_args deepCopy() {
      return new getConfig_args(this);
    }

    @Deprecated
    public getConfig_args clone() {
      return new getConfig_args(this);
    }

    public GetConfigReq  getReq() {
      return this.req;
    }

    public getConfig_args setReq(GetConfigReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((GetConfigReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getConfig_args)
        return this.equals((getConfig_args)that);
      return false;
    }

    public boolean equals(getConfig_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getConfig_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new GetConfigReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getConfig_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getConfig_result implements TBase, java.io.Serializable, Cloneable, Comparable<getConfig_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getConfig_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetConfigResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetConfigResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getConfig_result.class, metaDataMap);
    }

    public getConfig_result() {
    }

    public getConfig_result(
      GetConfigResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConfig_result(getConfig_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getConfig_result deepCopy() {
      return new getConfig_result(this);
    }

    @Deprecated
    public getConfig_result clone() {
      return new getConfig_result(this);
    }

    public GetConfigResp  getSuccess() {
      return this.success;
    }

    public getConfig_result setSuccess(GetConfigResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetConfigResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getConfig_result)
        return this.equals((getConfig_result)that);
      return false;
    }

    public boolean equals(getConfig_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(getConfig_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new GetConfigResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getConfig_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class setConfig_args implements TBase, java.io.Serializable, Cloneable, Comparable<setConfig_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("setConfig_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public SetConfigReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, SetConfigReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(setConfig_args.class, metaDataMap);
    }

    public setConfig_args() {
    }

    public setConfig_args(
      SetConfigReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setConfig_args(setConfig_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public setConfig_args deepCopy() {
      return new setConfig_args(this);
    }

    @Deprecated
    public setConfig_args clone() {
      return new setConfig_args(this);
    }

    public SetConfigReq  getReq() {
      return this.req;
    }

    public setConfig_args setReq(SetConfigReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((SetConfigReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setConfig_args)
        return this.equals((setConfig_args)that);
      return false;
    }

    public boolean equals(setConfig_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(setConfig_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new SetConfigReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("setConfig_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class setConfig_result implements TBase, java.io.Serializable, Cloneable, Comparable<setConfig_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("setConfig_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(setConfig_result.class, metaDataMap);
    }

    public setConfig_result() {
    }

    public setConfig_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setConfig_result(setConfig_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public setConfig_result deepCopy() {
      return new setConfig_result(this);
    }

    @Deprecated
    public setConfig_result clone() {
      return new setConfig_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public setConfig_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setConfig_result)
        return this.equals((setConfig_result)that);
      return false;
    }

    public boolean equals(setConfig_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(setConfig_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("setConfig_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listConfigs_args implements TBase, java.io.Serializable, Cloneable, Comparable<listConfigs_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listConfigs_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListConfigsReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListConfigsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listConfigs_args.class, metaDataMap);
    }

    public listConfigs_args() {
    }

    public listConfigs_args(
      ListConfigsReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listConfigs_args(listConfigs_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listConfigs_args deepCopy() {
      return new listConfigs_args(this);
    }

    @Deprecated
    public listConfigs_args clone() {
      return new listConfigs_args(this);
    }

    public ListConfigsReq  getReq() {
      return this.req;
    }

    public listConfigs_args setReq(ListConfigsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListConfigsReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listConfigs_args)
        return this.equals((listConfigs_args)that);
      return false;
    }

    public boolean equals(listConfigs_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listConfigs_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListConfigsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listConfigs_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listConfigs_result implements TBase, java.io.Serializable, Cloneable, Comparable<listConfigs_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listConfigs_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListConfigsResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListConfigsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listConfigs_result.class, metaDataMap);
    }

    public listConfigs_result() {
    }

    public listConfigs_result(
      ListConfigsResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listConfigs_result(listConfigs_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listConfigs_result deepCopy() {
      return new listConfigs_result(this);
    }

    @Deprecated
    public listConfigs_result clone() {
      return new listConfigs_result(this);
    }

    public ListConfigsResp  getSuccess() {
      return this.success;
    }

    public listConfigs_result setSuccess(ListConfigsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListConfigsResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listConfigs_result)
        return this.equals((listConfigs_result)that);
      return false;
    }

    public boolean equals(listConfigs_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listConfigs_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListConfigsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listConfigs_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createSnapshot_args implements TBase, java.io.Serializable, Cloneable, Comparable<createSnapshot_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSnapshot_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateSnapshotReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateSnapshotReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSnapshot_args.class, metaDataMap);
    }

    public createSnapshot_args() {
    }

    public createSnapshot_args(
      CreateSnapshotReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSnapshot_args(createSnapshot_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createSnapshot_args deepCopy() {
      return new createSnapshot_args(this);
    }

    @Deprecated
    public createSnapshot_args clone() {
      return new createSnapshot_args(this);
    }

    public CreateSnapshotReq  getReq() {
      return this.req;
    }

    public createSnapshot_args setReq(CreateSnapshotReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((CreateSnapshotReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createSnapshot_args)
        return this.equals((createSnapshot_args)that);
      return false;
    }

    public boolean equals(createSnapshot_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createSnapshot_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new CreateSnapshotReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSnapshot_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createSnapshot_result implements TBase, java.io.Serializable, Cloneable, Comparable<createSnapshot_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSnapshot_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSnapshot_result.class, metaDataMap);
    }

    public createSnapshot_result() {
    }

    public createSnapshot_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSnapshot_result(createSnapshot_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createSnapshot_result deepCopy() {
      return new createSnapshot_result(this);
    }

    @Deprecated
    public createSnapshot_result clone() {
      return new createSnapshot_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public createSnapshot_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createSnapshot_result)
        return this.equals((createSnapshot_result)that);
      return false;
    }

    public boolean equals(createSnapshot_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(createSnapshot_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSnapshot_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropSnapshot_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropSnapshot_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropSnapshot_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropSnapshotReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropSnapshotReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropSnapshot_args.class, metaDataMap);
    }

    public dropSnapshot_args() {
    }

    public dropSnapshot_args(
      DropSnapshotReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropSnapshot_args(dropSnapshot_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropSnapshot_args deepCopy() {
      return new dropSnapshot_args(this);
    }

    @Deprecated
    public dropSnapshot_args clone() {
      return new dropSnapshot_args(this);
    }

    public DropSnapshotReq  getReq() {
      return this.req;
    }

    public dropSnapshot_args setReq(DropSnapshotReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((DropSnapshotReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropSnapshot_args)
        return this.equals((dropSnapshot_args)that);
      return false;
    }

    public boolean equals(dropSnapshot_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropSnapshot_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new DropSnapshotReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropSnapshot_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dropSnapshot_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropSnapshot_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropSnapshot_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropSnapshot_result.class, metaDataMap);
    }

    public dropSnapshot_result() {
    }

    public dropSnapshot_result(
      ExecResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropSnapshot_result(dropSnapshot_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropSnapshot_result deepCopy() {
      return new dropSnapshot_result(this);
    }

    @Deprecated
    public dropSnapshot_result clone() {
      return new dropSnapshot_result(this);
    }

    public ExecResp  getSuccess() {
      return this.success;
    }

    public dropSnapshot_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropSnapshot_result)
        return this.equals((dropSnapshot_result)that);
      return false;
    }

    public boolean equals(dropSnapshot_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(dropSnapshot_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropSnapshot_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listSnapshots_args implements TBase, java.io.Serializable, Cloneable, Comparable<listSnapshots_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSnapshots_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListSnapshotsReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSnapshotsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSnapshots_args.class, metaDataMap);
    }

    public listSnapshots_args() {
    }

    public listSnapshots_args(
      ListSnapshotsReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSnapshots_args(listSnapshots_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listSnapshots_args deepCopy() {
      return new listSnapshots_args(this);
    }

    @Deprecated
    public listSnapshots_args clone() {
      return new listSnapshots_args(this);
    }

    public ListSnapshotsReq  getReq() {
      return this.req;
    }

    public listSnapshots_args setReq(ListSnapshotsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((ListSnapshotsReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listSnapshots_args)
        return this.equals((listSnapshots_args)that);
      return false;
    }

    public boolean equals(listSnapshots_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listSnapshots_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new ListSnapshotsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSnapshots_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listSnapshots_result implements TBase, java.io.Serializable, Cloneable, Comparable<listSnapshots_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSnapshots_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListSnapshotsResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSnapshotsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSnapshots_result.class, metaDataMap);
    }

    public listSnapshots_result() {
    }

    public listSnapshots_result(
      ListSnapshotsResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSnapshots_result(listSnapshots_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listSnapshots_result deepCopy() {
      return new listSnapshots_result(this);
    }

    @Deprecated
    public listSnapshots_result clone() {
      return new listSnapshots_result(this);
    }

    public ListSnapshotsResp  getSuccess() {
      return this.success;
    }

    public listSnapshots_result setSuccess(ListSnapshotsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListSnapshotsResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listSnapshots_result)
        return this.equals((listSnapshots_result)that);
      return false;
    }

    public boolean equals(listSnapshots_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(listSnapshots_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ListSnapshotsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSnapshots_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class runAdminJob_args implements TBase, java.io.Serializable, Cloneable, Comparable<runAdminJob_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("runAdminJob_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AdminJobReq req;
    public static final int REQ = 1;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AdminJobReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(runAdminJob_args.class, metaDataMap);
    }

    public runAdminJob_args() {
    }

    public runAdminJob_args(
      AdminJobReq req)
    {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public runAdminJob_args(runAdminJob_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public runAdminJob_args deepCopy() {
      return new runAdminJob_args(this);
    }

    @Deprecated
    public runAdminJob_args clone() {
      return new runAdminJob_args(this);
    }

    public AdminJobReq  getReq() {
      return this.req;
    }

    public runAdminJob_args setReq(AdminJobReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean value) {
      if (!value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          setReq((AdminJobReq)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof runAdminJob_args)
        return this.equals((runAdminJob_args)that);
      return false;
    }

    public boolean equals(runAdminJob_args that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_req = true && this.isSetReq();
      boolean that_present_req = true && that.isSetReq();
      if (this_present_req || that_present_req) {
        if (!(this_present_req && that_present_req))
          return false;
        if (!TBaseHelper.equalsNobinary(this.req, that.req))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_req = true && (isSetReq());
      builder.append(present_req);
      if (present_req)
        builder.append(req);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(runAdminJob_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REQ:
            if (field.type == TType.STRUCT) {
              this.req = new AdminJobReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("runAdminJob_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class runAdminJob_result implements TBase, java.io.Serializable, Cloneable, Comparable<runAdminJob_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("runAdminJob_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public AdminJobResp success;
    public static final int SUCCESS = 0;
    public static boolean DEFAULT_PRETTY_PRINT = true;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;
    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AdminJobResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(runAdminJob_result.class, metaDataMap);
    }

    public runAdminJob_result() {
    }

    public runAdminJob_result(
      AdminJobResp success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public runAdminJob_result(runAdminJob_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public runAdminJob_result deepCopy() {
      return new runAdminJob_result(this);
    }

    @Deprecated
    public runAdminJob_result clone() {
      return new runAdminJob_result(this);
    }

    public AdminJobResp  getSuccess() {
      return this.success;
    }

    public runAdminJob_result setSuccess(AdminJobResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((AdminJobResp)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof runAdminJob_result)
        return this.equals((runAdminJob_result)that);
      return false;
    }

    public boolean equals(runAdminJob_result that) {
      if (that == null)
        return false;
      if (this == that)
        return true;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!TBaseHelper.equalsNobinary(this.success, that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    @Override
    public int compareTo(runAdminJob_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new AdminJobResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(DEFAULT_PRETTY_PRINT);
    }

    @Override
    public String toString(boolean prettyPrint) {
      return toString(1, prettyPrint);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("runAdminJob_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this. getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this. getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

}
