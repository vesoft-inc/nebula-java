/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package com.vesoft.nebula.meta;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import java.util.BitSet;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.facebook.thrift.*;
import com.facebook.thrift.annotations.*;
import com.facebook.thrift.async.*;
import com.facebook.thrift.meta_data.*;
import com.facebook.thrift.server.*;
import com.facebook.thrift.transport.*;
import com.facebook.thrift.protocol.*;

@SuppressWarnings({ "unused", "serial" })
public class MetaService {

  public interface Iface {

    public ExecResp createSpace(CreateSpaceReq req) throws TException;

    public ExecResp dropSpace(DropSpaceReq req) throws TException;

    public GetSpaceResp getSpace(GetSpaceReq req) throws TException;

    public ListSpacesResp listSpaces(ListSpacesReq req) throws TException;

    public ExecResp createTag(CreateTagReq req) throws TException;

    public ExecResp alterTag(AlterTagReq req) throws TException;

    public ExecResp dropTag(DropTagReq req) throws TException;

    public GetTagResp getTag(GetTagReq req) throws TException;

    public ListTagsResp listTags(ListTagsReq req) throws TException;

    public ExecResp createEdge(CreateEdgeReq req) throws TException;

    public ExecResp alterEdge(AlterEdgeReq req) throws TException;

    public ExecResp dropEdge(DropEdgeReq req) throws TException;

    public GetEdgeResp getEdge(GetEdgeReq req) throws TException;

    public ListEdgesResp listEdges(ListEdgesReq req) throws TException;

    public ListHostsResp listHosts(ListHostsReq req) throws TException;

    public GetPartsAllocResp getPartsAlloc(GetPartsAllocReq req) throws TException;

    public ListPartsResp listParts(ListPartsReq req) throws TException;

    public ExecResp multiPut(MultiPutReq req) throws TException;

    public GetResp get(GetReq req) throws TException;

    public MultiGetResp multiGet(MultiGetReq req) throws TException;

    public ExecResp remove(RemoveReq req) throws TException;

    public ExecResp removeRange(RemoveRangeReq req) throws TException;

    public ScanResp scan(ScanReq req) throws TException;

    public ExecResp createTagIndex(CreateTagIndexReq req) throws TException;

    public ExecResp dropTagIndex(DropTagIndexReq req) throws TException;

    public GetTagIndexResp getTagIndex(GetTagIndexReq req) throws TException;

    public ListTagIndexesResp listTagIndexes(ListTagIndexesReq req) throws TException;

    public ExecResp rebuildTagIndex(RebuildIndexReq req) throws TException;

    public ListIndexStatusResp listTagIndexStatus(ListIndexStatusReq req) throws TException;

    public ExecResp createEdgeIndex(CreateEdgeIndexReq req) throws TException;

    public ExecResp dropEdgeIndex(DropEdgeIndexReq req) throws TException;

    public GetEdgeIndexResp getEdgeIndex(GetEdgeIndexReq req) throws TException;

    public ListEdgeIndexesResp listEdgeIndexes(ListEdgeIndexesReq req) throws TException;

    public ExecResp rebuildEdgeIndex(RebuildIndexReq req) throws TException;

    public ListIndexStatusResp listEdgeIndexStatus(ListIndexStatusReq req) throws TException;

    public ExecResp createUser(CreateUserReq req) throws TException;

    public ExecResp dropUser(DropUserReq req) throws TException;

    public ExecResp alterUser(AlterUserReq req) throws TException;

    public ExecResp grantRole(GrantRoleReq req) throws TException;

    public ExecResp revokeRole(RevokeRoleReq req) throws TException;

    public ListUsersResp listUsers(ListUsersReq req) throws TException;

    public ListRolesResp listRoles(ListRolesReq req) throws TException;

    public ListRolesResp getUserRoles(GetUserRolesReq req) throws TException;

    public ExecResp changePassword(ChangePasswordReq req) throws TException;

    public HBResp heartBeat(HBReq req) throws TException;

    public BalanceResp balance(BalanceReq req) throws TException;

    public ExecResp leaderBalance(LeaderBalanceReq req) throws TException;

    public ExecResp regConfig(RegConfigReq req) throws TException;

    public GetConfigResp getConfig(GetConfigReq req) throws TException;

    public ExecResp setConfig(SetConfigReq req) throws TException;

    public ListConfigsResp listConfigs(ListConfigsReq req) throws TException;

    public ExecResp createSnapshot(CreateSnapshotReq req) throws TException;

    public ExecResp dropSnapshot(DropSnapshotReq req) throws TException;

    public ListSnapshotsResp listSnapshots(ListSnapshotsReq req) throws TException;

    public AdminJobResp runAdminJob(AdminJobReq req) throws TException;

    public ExecResp addZone(AddZoneReq req) throws TException;

    public ExecResp dropZone(DropZoneReq req) throws TException;

    public ExecResp addHostIntoZone(AddHostIntoZoneReq req) throws TException;

    public ExecResp dropHostFromZone(DropHostFromZoneReq req) throws TException;

    public GetZoneResp getZone(GetZoneReq req) throws TException;

    public ListZonesResp listZones(ListZonesReq req) throws TException;

    public ExecResp addGroup(AddGroupReq req) throws TException;

    public ExecResp dropGroup(DropGroupReq req) throws TException;

    public ExecResp addZoneIntoGroup(AddZoneIntoGroupReq req) throws TException;

    public ExecResp dropZoneFromGroup(DropZoneFromGroupReq req) throws TException;

    public GetGroupResp getGroup(GetGroupReq req) throws TException;

    public ListGroupsResp listGroups(ListGroupsReq req) throws TException;

    public CreateBackupResp createBackup(CreateBackupReq req) throws TException;

    public ExecResp restoreMeta(RestoreMetaReq req) throws TException;

    public ExecResp addListener(AddListenerReq req) throws TException;

    public ExecResp removeListener(RemoveListenerReq req) throws TException;

    public ListListenerResp listListener(ListListenerReq req) throws TException;

    public GetStatisResp getStatis(GetStatisReq req) throws TException;

    public ExecResp signInFTService(SignInFTServiceReq req) throws TException;

    public ExecResp signOutFTService(SignOutFTServiceReq req) throws TException;

    public ListFTClientsResp listFTClients(ListFTClientsReq req) throws TException;

    public ExecResp createFTIndex(CreateFTIndexReq req) throws TException;

    public ExecResp dropFTIndex(DropFTIndexReq req) throws TException;

    public ListFTIndexesResp listFTIndexes(ListFTIndexesReq req) throws TException;

    public CreateSessionResp createSession(CreateSessionReq req) throws TException;

    public UpdateSessionsResp updateSessions(UpdateSessionsReq req) throws TException;

    public ListSessionsResp listSessions(ListSessionsReq req) throws TException;

    public GetSessionResp getSession(GetSessionReq req) throws TException;

    public ExecResp removeSession(RemoveSessionReq req) throws TException;

    public ExecResp killQuery(KillQueryReq req) throws TException;

    public ExecResp reportTaskFinish(ReportTaskReq req) throws TException;

    public ListClusterInfoResp listCluster(ListClusterInfoReq req) throws TException;

    public GetMetaDirInfoResp getMetaDirInfo(GetMetaDirInfoReq req) throws TException;

  }

  public interface AsyncIface {

    public void createSpace(CreateSpaceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropSpace(DropSpaceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getSpace(GetSpaceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listSpaces(ListSpacesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createTag(CreateTagReq req, AsyncMethodCallback resultHandler) throws TException;

    public void alterTag(AlterTagReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropTag(DropTagReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getTag(GetTagReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listTags(ListTagsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createEdge(CreateEdgeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void alterEdge(AlterEdgeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropEdge(DropEdgeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getEdge(GetEdgeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listEdges(ListEdgesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listHosts(ListHostsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getPartsAlloc(GetPartsAllocReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listParts(ListPartsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void multiPut(MultiPutReq req, AsyncMethodCallback resultHandler) throws TException;

    public void get(GetReq req, AsyncMethodCallback resultHandler) throws TException;

    public void multiGet(MultiGetReq req, AsyncMethodCallback resultHandler) throws TException;

    public void remove(RemoveReq req, AsyncMethodCallback resultHandler) throws TException;

    public void removeRange(RemoveRangeReq req, AsyncMethodCallback resultHandler) throws TException;

    public void scan(ScanReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createTagIndex(CreateTagIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropTagIndex(DropTagIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getTagIndex(GetTagIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listTagIndexes(ListTagIndexesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void rebuildTagIndex(RebuildIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listTagIndexStatus(ListIndexStatusReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createEdgeIndex(CreateEdgeIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropEdgeIndex(DropEdgeIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getEdgeIndex(GetEdgeIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listEdgeIndexes(ListEdgeIndexesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void rebuildEdgeIndex(RebuildIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listEdgeIndexStatus(ListIndexStatusReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createUser(CreateUserReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropUser(DropUserReq req, AsyncMethodCallback resultHandler) throws TException;

    public void alterUser(AlterUserReq req, AsyncMethodCallback resultHandler) throws TException;

    public void grantRole(GrantRoleReq req, AsyncMethodCallback resultHandler) throws TException;

    public void revokeRole(RevokeRoleReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listUsers(ListUsersReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listRoles(ListRolesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getUserRoles(GetUserRolesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void changePassword(ChangePasswordReq req, AsyncMethodCallback resultHandler) throws TException;

    public void heartBeat(HBReq req, AsyncMethodCallback resultHandler) throws TException;

    public void balance(BalanceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void leaderBalance(LeaderBalanceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void regConfig(RegConfigReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getConfig(GetConfigReq req, AsyncMethodCallback resultHandler) throws TException;

    public void setConfig(SetConfigReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listConfigs(ListConfigsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createSnapshot(CreateSnapshotReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropSnapshot(DropSnapshotReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listSnapshots(ListSnapshotsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void runAdminJob(AdminJobReq req, AsyncMethodCallback resultHandler) throws TException;

    public void addZone(AddZoneReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropZone(DropZoneReq req, AsyncMethodCallback resultHandler) throws TException;

    public void addHostIntoZone(AddHostIntoZoneReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropHostFromZone(DropHostFromZoneReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getZone(GetZoneReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listZones(ListZonesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void addGroup(AddGroupReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropGroup(DropGroupReq req, AsyncMethodCallback resultHandler) throws TException;

    public void addZoneIntoGroup(AddZoneIntoGroupReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropZoneFromGroup(DropZoneFromGroupReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getGroup(GetGroupReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listGroups(ListGroupsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createBackup(CreateBackupReq req, AsyncMethodCallback resultHandler) throws TException;

    public void restoreMeta(RestoreMetaReq req, AsyncMethodCallback resultHandler) throws TException;

    public void addListener(AddListenerReq req, AsyncMethodCallback resultHandler) throws TException;

    public void removeListener(RemoveListenerReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listListener(ListListenerReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getStatis(GetStatisReq req, AsyncMethodCallback resultHandler) throws TException;

    public void signInFTService(SignInFTServiceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void signOutFTService(SignOutFTServiceReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listFTClients(ListFTClientsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createFTIndex(CreateFTIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void dropFTIndex(DropFTIndexReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listFTIndexes(ListFTIndexesReq req, AsyncMethodCallback resultHandler) throws TException;

    public void createSession(CreateSessionReq req, AsyncMethodCallback resultHandler) throws TException;

    public void updateSessions(UpdateSessionsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listSessions(ListSessionsReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getSession(GetSessionReq req, AsyncMethodCallback resultHandler) throws TException;

    public void removeSession(RemoveSessionReq req, AsyncMethodCallback resultHandler) throws TException;

    public void killQuery(KillQueryReq req, AsyncMethodCallback resultHandler) throws TException;

    public void reportTaskFinish(ReportTaskReq req, AsyncMethodCallback resultHandler) throws TException;

    public void listCluster(ListClusterInfoReq req, AsyncMethodCallback resultHandler) throws TException;

    public void getMetaDirInfo(GetMetaDirInfoReq req, AsyncMethodCallback resultHandler) throws TException;

  }

  public static class Client extends EventHandlerBase implements Iface, TClientIf {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    @Override
    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    @Override
    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public ExecResp createSpace(CreateSpaceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createSpace", null);
      this.setContextStack(ctx);
      send_createSpace(req);
      return recv_createSpace();
    }

    public void send_createSpace(CreateSpaceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createSpace", null);
      oprot_.writeMessageBegin(new TMessage("createSpace", TMessageType.CALL, seqid_));
      createSpace_args args = new createSpace_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createSpace", args);
      return;
    }

    public ExecResp recv_createSpace() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createSpace");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createSpace_result result = new createSpace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createSpace", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createSpace failed: unknown result");
    }

    public ExecResp dropSpace(DropSpaceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropSpace", null);
      this.setContextStack(ctx);
      send_dropSpace(req);
      return recv_dropSpace();
    }

    public void send_dropSpace(DropSpaceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropSpace", null);
      oprot_.writeMessageBegin(new TMessage("dropSpace", TMessageType.CALL, seqid_));
      dropSpace_args args = new dropSpace_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropSpace", args);
      return;
    }

    public ExecResp recv_dropSpace() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropSpace");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropSpace_result result = new dropSpace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropSpace", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropSpace failed: unknown result");
    }

    public GetSpaceResp getSpace(GetSpaceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getSpace", null);
      this.setContextStack(ctx);
      send_getSpace(req);
      return recv_getSpace();
    }

    public void send_getSpace(GetSpaceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getSpace", null);
      oprot_.writeMessageBegin(new TMessage("getSpace", TMessageType.CALL, seqid_));
      getSpace_args args = new getSpace_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getSpace", args);
      return;
    }

    public GetSpaceResp recv_getSpace() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getSpace");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getSpace_result result = new getSpace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getSpace", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getSpace failed: unknown result");
    }

    public ListSpacesResp listSpaces(ListSpacesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listSpaces", null);
      this.setContextStack(ctx);
      send_listSpaces(req);
      return recv_listSpaces();
    }

    public void send_listSpaces(ListSpacesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listSpaces", null);
      oprot_.writeMessageBegin(new TMessage("listSpaces", TMessageType.CALL, seqid_));
      listSpaces_args args = new listSpaces_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listSpaces", args);
      return;
    }

    public ListSpacesResp recv_listSpaces() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listSpaces");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listSpaces_result result = new listSpaces_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listSpaces", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listSpaces failed: unknown result");
    }

    public ExecResp createTag(CreateTagReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createTag", null);
      this.setContextStack(ctx);
      send_createTag(req);
      return recv_createTag();
    }

    public void send_createTag(CreateTagReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createTag", null);
      oprot_.writeMessageBegin(new TMessage("createTag", TMessageType.CALL, seqid_));
      createTag_args args = new createTag_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createTag", args);
      return;
    }

    public ExecResp recv_createTag() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createTag");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createTag_result result = new createTag_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createTag", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createTag failed: unknown result");
    }

    public ExecResp alterTag(AlterTagReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.alterTag", null);
      this.setContextStack(ctx);
      send_alterTag(req);
      return recv_alterTag();
    }

    public void send_alterTag(AlterTagReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.alterTag", null);
      oprot_.writeMessageBegin(new TMessage("alterTag", TMessageType.CALL, seqid_));
      alterTag_args args = new alterTag_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.alterTag", args);
      return;
    }

    public ExecResp recv_alterTag() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.alterTag");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      alterTag_result result = new alterTag_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.alterTag", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "alterTag failed: unknown result");
    }

    public ExecResp dropTag(DropTagReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropTag", null);
      this.setContextStack(ctx);
      send_dropTag(req);
      return recv_dropTag();
    }

    public void send_dropTag(DropTagReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropTag", null);
      oprot_.writeMessageBegin(new TMessage("dropTag", TMessageType.CALL, seqid_));
      dropTag_args args = new dropTag_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropTag", args);
      return;
    }

    public ExecResp recv_dropTag() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropTag");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropTag_result result = new dropTag_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropTag", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropTag failed: unknown result");
    }

    public GetTagResp getTag(GetTagReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getTag", null);
      this.setContextStack(ctx);
      send_getTag(req);
      return recv_getTag();
    }

    public void send_getTag(GetTagReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getTag", null);
      oprot_.writeMessageBegin(new TMessage("getTag", TMessageType.CALL, seqid_));
      getTag_args args = new getTag_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getTag", args);
      return;
    }

    public GetTagResp recv_getTag() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getTag");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getTag_result result = new getTag_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getTag", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTag failed: unknown result");
    }

    public ListTagsResp listTags(ListTagsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listTags", null);
      this.setContextStack(ctx);
      send_listTags(req);
      return recv_listTags();
    }

    public void send_listTags(ListTagsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listTags", null);
      oprot_.writeMessageBegin(new TMessage("listTags", TMessageType.CALL, seqid_));
      listTags_args args = new listTags_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listTags", args);
      return;
    }

    public ListTagsResp recv_listTags() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listTags");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listTags_result result = new listTags_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listTags", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listTags failed: unknown result");
    }

    public ExecResp createEdge(CreateEdgeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createEdge", null);
      this.setContextStack(ctx);
      send_createEdge(req);
      return recv_createEdge();
    }

    public void send_createEdge(CreateEdgeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createEdge", null);
      oprot_.writeMessageBegin(new TMessage("createEdge", TMessageType.CALL, seqid_));
      createEdge_args args = new createEdge_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createEdge", args);
      return;
    }

    public ExecResp recv_createEdge() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createEdge");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createEdge_result result = new createEdge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createEdge", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createEdge failed: unknown result");
    }

    public ExecResp alterEdge(AlterEdgeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.alterEdge", null);
      this.setContextStack(ctx);
      send_alterEdge(req);
      return recv_alterEdge();
    }

    public void send_alterEdge(AlterEdgeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.alterEdge", null);
      oprot_.writeMessageBegin(new TMessage("alterEdge", TMessageType.CALL, seqid_));
      alterEdge_args args = new alterEdge_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.alterEdge", args);
      return;
    }

    public ExecResp recv_alterEdge() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.alterEdge");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      alterEdge_result result = new alterEdge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.alterEdge", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "alterEdge failed: unknown result");
    }

    public ExecResp dropEdge(DropEdgeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropEdge", null);
      this.setContextStack(ctx);
      send_dropEdge(req);
      return recv_dropEdge();
    }

    public void send_dropEdge(DropEdgeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropEdge", null);
      oprot_.writeMessageBegin(new TMessage("dropEdge", TMessageType.CALL, seqid_));
      dropEdge_args args = new dropEdge_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropEdge", args);
      return;
    }

    public ExecResp recv_dropEdge() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropEdge");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropEdge_result result = new dropEdge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropEdge", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropEdge failed: unknown result");
    }

    public GetEdgeResp getEdge(GetEdgeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getEdge", null);
      this.setContextStack(ctx);
      send_getEdge(req);
      return recv_getEdge();
    }

    public void send_getEdge(GetEdgeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getEdge", null);
      oprot_.writeMessageBegin(new TMessage("getEdge", TMessageType.CALL, seqid_));
      getEdge_args args = new getEdge_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getEdge", args);
      return;
    }

    public GetEdgeResp recv_getEdge() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getEdge");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getEdge_result result = new getEdge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getEdge", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getEdge failed: unknown result");
    }

    public ListEdgesResp listEdges(ListEdgesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listEdges", null);
      this.setContextStack(ctx);
      send_listEdges(req);
      return recv_listEdges();
    }

    public void send_listEdges(ListEdgesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listEdges", null);
      oprot_.writeMessageBegin(new TMessage("listEdges", TMessageType.CALL, seqid_));
      listEdges_args args = new listEdges_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listEdges", args);
      return;
    }

    public ListEdgesResp recv_listEdges() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listEdges");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listEdges_result result = new listEdges_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listEdges", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listEdges failed: unknown result");
    }

    public ListHostsResp listHosts(ListHostsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listHosts", null);
      this.setContextStack(ctx);
      send_listHosts(req);
      return recv_listHosts();
    }

    public void send_listHosts(ListHostsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listHosts", null);
      oprot_.writeMessageBegin(new TMessage("listHosts", TMessageType.CALL, seqid_));
      listHosts_args args = new listHosts_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listHosts", args);
      return;
    }

    public ListHostsResp recv_listHosts() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listHosts");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listHosts_result result = new listHosts_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listHosts", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listHosts failed: unknown result");
    }

    public GetPartsAllocResp getPartsAlloc(GetPartsAllocReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getPartsAlloc", null);
      this.setContextStack(ctx);
      send_getPartsAlloc(req);
      return recv_getPartsAlloc();
    }

    public void send_getPartsAlloc(GetPartsAllocReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getPartsAlloc", null);
      oprot_.writeMessageBegin(new TMessage("getPartsAlloc", TMessageType.CALL, seqid_));
      getPartsAlloc_args args = new getPartsAlloc_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getPartsAlloc", args);
      return;
    }

    public GetPartsAllocResp recv_getPartsAlloc() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getPartsAlloc");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getPartsAlloc_result result = new getPartsAlloc_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getPartsAlloc", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getPartsAlloc failed: unknown result");
    }

    public ListPartsResp listParts(ListPartsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listParts", null);
      this.setContextStack(ctx);
      send_listParts(req);
      return recv_listParts();
    }

    public void send_listParts(ListPartsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listParts", null);
      oprot_.writeMessageBegin(new TMessage("listParts", TMessageType.CALL, seqid_));
      listParts_args args = new listParts_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listParts", args);
      return;
    }

    public ListPartsResp recv_listParts() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listParts");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listParts_result result = new listParts_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listParts", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listParts failed: unknown result");
    }

    public ExecResp multiPut(MultiPutReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.multiPut", null);
      this.setContextStack(ctx);
      send_multiPut(req);
      return recv_multiPut();
    }

    public void send_multiPut(MultiPutReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.multiPut", null);
      oprot_.writeMessageBegin(new TMessage("multiPut", TMessageType.CALL, seqid_));
      multiPut_args args = new multiPut_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.multiPut", args);
      return;
    }

    public ExecResp recv_multiPut() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.multiPut");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      multiPut_result result = new multiPut_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.multiPut", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiPut failed: unknown result");
    }

    public GetResp get(GetReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.get", null);
      this.setContextStack(ctx);
      send_get(req);
      return recv_get();
    }

    public void send_get(GetReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.get", null);
      oprot_.writeMessageBegin(new TMessage("get", TMessageType.CALL, seqid_));
      get_args args = new get_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.get", args);
      return;
    }

    public GetResp recv_get() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.get");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_result result = new get_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.get", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result");
    }

    public MultiGetResp multiGet(MultiGetReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.multiGet", null);
      this.setContextStack(ctx);
      send_multiGet(req);
      return recv_multiGet();
    }

    public void send_multiGet(MultiGetReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.multiGet", null);
      oprot_.writeMessageBegin(new TMessage("multiGet", TMessageType.CALL, seqid_));
      multiGet_args args = new multiGet_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.multiGet", args);
      return;
    }

    public MultiGetResp recv_multiGet() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.multiGet");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      multiGet_result result = new multiGet_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.multiGet", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiGet failed: unknown result");
    }

    public ExecResp remove(RemoveReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.remove", null);
      this.setContextStack(ctx);
      send_remove(req);
      return recv_remove();
    }

    public void send_remove(RemoveReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.remove", null);
      oprot_.writeMessageBegin(new TMessage("remove", TMessageType.CALL, seqid_));
      remove_args args = new remove_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.remove", args);
      return;
    }

    public ExecResp recv_remove() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.remove");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      remove_result result = new remove_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.remove", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "remove failed: unknown result");
    }

    public ExecResp removeRange(RemoveRangeReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.removeRange", null);
      this.setContextStack(ctx);
      send_removeRange(req);
      return recv_removeRange();
    }

    public void send_removeRange(RemoveRangeReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.removeRange", null);
      oprot_.writeMessageBegin(new TMessage("removeRange", TMessageType.CALL, seqid_));
      removeRange_args args = new removeRange_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.removeRange", args);
      return;
    }

    public ExecResp recv_removeRange() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.removeRange");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      removeRange_result result = new removeRange_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.removeRange", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "removeRange failed: unknown result");
    }

    public ScanResp scan(ScanReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.scan", null);
      this.setContextStack(ctx);
      send_scan(req);
      return recv_scan();
    }

    public void send_scan(ScanReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.scan", null);
      oprot_.writeMessageBegin(new TMessage("scan", TMessageType.CALL, seqid_));
      scan_args args = new scan_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.scan", args);
      return;
    }

    public ScanResp recv_scan() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.scan");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      scan_result result = new scan_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.scan", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "scan failed: unknown result");
    }

    public ExecResp createTagIndex(CreateTagIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createTagIndex", null);
      this.setContextStack(ctx);
      send_createTagIndex(req);
      return recv_createTagIndex();
    }

    public void send_createTagIndex(CreateTagIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createTagIndex", null);
      oprot_.writeMessageBegin(new TMessage("createTagIndex", TMessageType.CALL, seqid_));
      createTagIndex_args args = new createTagIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createTagIndex", args);
      return;
    }

    public ExecResp recv_createTagIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createTagIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createTagIndex_result result = new createTagIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createTagIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createTagIndex failed: unknown result");
    }

    public ExecResp dropTagIndex(DropTagIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropTagIndex", null);
      this.setContextStack(ctx);
      send_dropTagIndex(req);
      return recv_dropTagIndex();
    }

    public void send_dropTagIndex(DropTagIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropTagIndex", null);
      oprot_.writeMessageBegin(new TMessage("dropTagIndex", TMessageType.CALL, seqid_));
      dropTagIndex_args args = new dropTagIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropTagIndex", args);
      return;
    }

    public ExecResp recv_dropTagIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropTagIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropTagIndex_result result = new dropTagIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropTagIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropTagIndex failed: unknown result");
    }

    public GetTagIndexResp getTagIndex(GetTagIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getTagIndex", null);
      this.setContextStack(ctx);
      send_getTagIndex(req);
      return recv_getTagIndex();
    }

    public void send_getTagIndex(GetTagIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getTagIndex", null);
      oprot_.writeMessageBegin(new TMessage("getTagIndex", TMessageType.CALL, seqid_));
      getTagIndex_args args = new getTagIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getTagIndex", args);
      return;
    }

    public GetTagIndexResp recv_getTagIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getTagIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getTagIndex_result result = new getTagIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getTagIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTagIndex failed: unknown result");
    }

    public ListTagIndexesResp listTagIndexes(ListTagIndexesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listTagIndexes", null);
      this.setContextStack(ctx);
      send_listTagIndexes(req);
      return recv_listTagIndexes();
    }

    public void send_listTagIndexes(ListTagIndexesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listTagIndexes", null);
      oprot_.writeMessageBegin(new TMessage("listTagIndexes", TMessageType.CALL, seqid_));
      listTagIndexes_args args = new listTagIndexes_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listTagIndexes", args);
      return;
    }

    public ListTagIndexesResp recv_listTagIndexes() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listTagIndexes");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listTagIndexes_result result = new listTagIndexes_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listTagIndexes", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listTagIndexes failed: unknown result");
    }

    public ExecResp rebuildTagIndex(RebuildIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.rebuildTagIndex", null);
      this.setContextStack(ctx);
      send_rebuildTagIndex(req);
      return recv_rebuildTagIndex();
    }

    public void send_rebuildTagIndex(RebuildIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.rebuildTagIndex", null);
      oprot_.writeMessageBegin(new TMessage("rebuildTagIndex", TMessageType.CALL, seqid_));
      rebuildTagIndex_args args = new rebuildTagIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.rebuildTagIndex", args);
      return;
    }

    public ExecResp recv_rebuildTagIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.rebuildTagIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      rebuildTagIndex_result result = new rebuildTagIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.rebuildTagIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "rebuildTagIndex failed: unknown result");
    }

    public ListIndexStatusResp listTagIndexStatus(ListIndexStatusReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listTagIndexStatus", null);
      this.setContextStack(ctx);
      send_listTagIndexStatus(req);
      return recv_listTagIndexStatus();
    }

    public void send_listTagIndexStatus(ListIndexStatusReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listTagIndexStatus", null);
      oprot_.writeMessageBegin(new TMessage("listTagIndexStatus", TMessageType.CALL, seqid_));
      listTagIndexStatus_args args = new listTagIndexStatus_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listTagIndexStatus", args);
      return;
    }

    public ListIndexStatusResp recv_listTagIndexStatus() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listTagIndexStatus");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listTagIndexStatus_result result = new listTagIndexStatus_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listTagIndexStatus", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listTagIndexStatus failed: unknown result");
    }

    public ExecResp createEdgeIndex(CreateEdgeIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createEdgeIndex", null);
      this.setContextStack(ctx);
      send_createEdgeIndex(req);
      return recv_createEdgeIndex();
    }

    public void send_createEdgeIndex(CreateEdgeIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createEdgeIndex", null);
      oprot_.writeMessageBegin(new TMessage("createEdgeIndex", TMessageType.CALL, seqid_));
      createEdgeIndex_args args = new createEdgeIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createEdgeIndex", args);
      return;
    }

    public ExecResp recv_createEdgeIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createEdgeIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createEdgeIndex_result result = new createEdgeIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createEdgeIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createEdgeIndex failed: unknown result");
    }

    public ExecResp dropEdgeIndex(DropEdgeIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropEdgeIndex", null);
      this.setContextStack(ctx);
      send_dropEdgeIndex(req);
      return recv_dropEdgeIndex();
    }

    public void send_dropEdgeIndex(DropEdgeIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropEdgeIndex", null);
      oprot_.writeMessageBegin(new TMessage("dropEdgeIndex", TMessageType.CALL, seqid_));
      dropEdgeIndex_args args = new dropEdgeIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropEdgeIndex", args);
      return;
    }

    public ExecResp recv_dropEdgeIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropEdgeIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropEdgeIndex_result result = new dropEdgeIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropEdgeIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropEdgeIndex failed: unknown result");
    }

    public GetEdgeIndexResp getEdgeIndex(GetEdgeIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getEdgeIndex", null);
      this.setContextStack(ctx);
      send_getEdgeIndex(req);
      return recv_getEdgeIndex();
    }

    public void send_getEdgeIndex(GetEdgeIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getEdgeIndex", null);
      oprot_.writeMessageBegin(new TMessage("getEdgeIndex", TMessageType.CALL, seqid_));
      getEdgeIndex_args args = new getEdgeIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getEdgeIndex", args);
      return;
    }

    public GetEdgeIndexResp recv_getEdgeIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getEdgeIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getEdgeIndex_result result = new getEdgeIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getEdgeIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getEdgeIndex failed: unknown result");
    }

    public ListEdgeIndexesResp listEdgeIndexes(ListEdgeIndexesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listEdgeIndexes", null);
      this.setContextStack(ctx);
      send_listEdgeIndexes(req);
      return recv_listEdgeIndexes();
    }

    public void send_listEdgeIndexes(ListEdgeIndexesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listEdgeIndexes", null);
      oprot_.writeMessageBegin(new TMessage("listEdgeIndexes", TMessageType.CALL, seqid_));
      listEdgeIndexes_args args = new listEdgeIndexes_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listEdgeIndexes", args);
      return;
    }

    public ListEdgeIndexesResp recv_listEdgeIndexes() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listEdgeIndexes");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listEdgeIndexes_result result = new listEdgeIndexes_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listEdgeIndexes", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listEdgeIndexes failed: unknown result");
    }

    public ExecResp rebuildEdgeIndex(RebuildIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.rebuildEdgeIndex", null);
      this.setContextStack(ctx);
      send_rebuildEdgeIndex(req);
      return recv_rebuildEdgeIndex();
    }

    public void send_rebuildEdgeIndex(RebuildIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.rebuildEdgeIndex", null);
      oprot_.writeMessageBegin(new TMessage("rebuildEdgeIndex", TMessageType.CALL, seqid_));
      rebuildEdgeIndex_args args = new rebuildEdgeIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.rebuildEdgeIndex", args);
      return;
    }

    public ExecResp recv_rebuildEdgeIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.rebuildEdgeIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      rebuildEdgeIndex_result result = new rebuildEdgeIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.rebuildEdgeIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "rebuildEdgeIndex failed: unknown result");
    }

    public ListIndexStatusResp listEdgeIndexStatus(ListIndexStatusReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listEdgeIndexStatus", null);
      this.setContextStack(ctx);
      send_listEdgeIndexStatus(req);
      return recv_listEdgeIndexStatus();
    }

    public void send_listEdgeIndexStatus(ListIndexStatusReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listEdgeIndexStatus", null);
      oprot_.writeMessageBegin(new TMessage("listEdgeIndexStatus", TMessageType.CALL, seqid_));
      listEdgeIndexStatus_args args = new listEdgeIndexStatus_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listEdgeIndexStatus", args);
      return;
    }

    public ListIndexStatusResp recv_listEdgeIndexStatus() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listEdgeIndexStatus");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listEdgeIndexStatus_result result = new listEdgeIndexStatus_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listEdgeIndexStatus", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listEdgeIndexStatus failed: unknown result");
    }

    public ExecResp createUser(CreateUserReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createUser", null);
      this.setContextStack(ctx);
      send_createUser(req);
      return recv_createUser();
    }

    public void send_createUser(CreateUserReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createUser", null);
      oprot_.writeMessageBegin(new TMessage("createUser", TMessageType.CALL, seqid_));
      createUser_args args = new createUser_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createUser", args);
      return;
    }

    public ExecResp recv_createUser() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createUser");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createUser_result result = new createUser_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createUser", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createUser failed: unknown result");
    }

    public ExecResp dropUser(DropUserReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropUser", null);
      this.setContextStack(ctx);
      send_dropUser(req);
      return recv_dropUser();
    }

    public void send_dropUser(DropUserReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropUser", null);
      oprot_.writeMessageBegin(new TMessage("dropUser", TMessageType.CALL, seqid_));
      dropUser_args args = new dropUser_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropUser", args);
      return;
    }

    public ExecResp recv_dropUser() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropUser");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropUser_result result = new dropUser_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropUser", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropUser failed: unknown result");
    }

    public ExecResp alterUser(AlterUserReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.alterUser", null);
      this.setContextStack(ctx);
      send_alterUser(req);
      return recv_alterUser();
    }

    public void send_alterUser(AlterUserReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.alterUser", null);
      oprot_.writeMessageBegin(new TMessage("alterUser", TMessageType.CALL, seqid_));
      alterUser_args args = new alterUser_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.alterUser", args);
      return;
    }

    public ExecResp recv_alterUser() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.alterUser");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      alterUser_result result = new alterUser_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.alterUser", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "alterUser failed: unknown result");
    }

    public ExecResp grantRole(GrantRoleReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.grantRole", null);
      this.setContextStack(ctx);
      send_grantRole(req);
      return recv_grantRole();
    }

    public void send_grantRole(GrantRoleReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.grantRole", null);
      oprot_.writeMessageBegin(new TMessage("grantRole", TMessageType.CALL, seqid_));
      grantRole_args args = new grantRole_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.grantRole", args);
      return;
    }

    public ExecResp recv_grantRole() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.grantRole");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      grantRole_result result = new grantRole_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.grantRole", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "grantRole failed: unknown result");
    }

    public ExecResp revokeRole(RevokeRoleReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.revokeRole", null);
      this.setContextStack(ctx);
      send_revokeRole(req);
      return recv_revokeRole();
    }

    public void send_revokeRole(RevokeRoleReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.revokeRole", null);
      oprot_.writeMessageBegin(new TMessage("revokeRole", TMessageType.CALL, seqid_));
      revokeRole_args args = new revokeRole_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.revokeRole", args);
      return;
    }

    public ExecResp recv_revokeRole() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.revokeRole");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      revokeRole_result result = new revokeRole_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.revokeRole", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "revokeRole failed: unknown result");
    }

    public ListUsersResp listUsers(ListUsersReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listUsers", null);
      this.setContextStack(ctx);
      send_listUsers(req);
      return recv_listUsers();
    }

    public void send_listUsers(ListUsersReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listUsers", null);
      oprot_.writeMessageBegin(new TMessage("listUsers", TMessageType.CALL, seqid_));
      listUsers_args args = new listUsers_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listUsers", args);
      return;
    }

    public ListUsersResp recv_listUsers() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listUsers");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listUsers_result result = new listUsers_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listUsers", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listUsers failed: unknown result");
    }

    public ListRolesResp listRoles(ListRolesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listRoles", null);
      this.setContextStack(ctx);
      send_listRoles(req);
      return recv_listRoles();
    }

    public void send_listRoles(ListRolesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listRoles", null);
      oprot_.writeMessageBegin(new TMessage("listRoles", TMessageType.CALL, seqid_));
      listRoles_args args = new listRoles_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listRoles", args);
      return;
    }

    public ListRolesResp recv_listRoles() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listRoles");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listRoles_result result = new listRoles_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listRoles", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listRoles failed: unknown result");
    }

    public ListRolesResp getUserRoles(GetUserRolesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getUserRoles", null);
      this.setContextStack(ctx);
      send_getUserRoles(req);
      return recv_getUserRoles();
    }

    public void send_getUserRoles(GetUserRolesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getUserRoles", null);
      oprot_.writeMessageBegin(new TMessage("getUserRoles", TMessageType.CALL, seqid_));
      getUserRoles_args args = new getUserRoles_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getUserRoles", args);
      return;
    }

    public ListRolesResp recv_getUserRoles() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getUserRoles");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getUserRoles_result result = new getUserRoles_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getUserRoles", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getUserRoles failed: unknown result");
    }

    public ExecResp changePassword(ChangePasswordReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.changePassword", null);
      this.setContextStack(ctx);
      send_changePassword(req);
      return recv_changePassword();
    }

    public void send_changePassword(ChangePasswordReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.changePassword", null);
      oprot_.writeMessageBegin(new TMessage("changePassword", TMessageType.CALL, seqid_));
      changePassword_args args = new changePassword_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.changePassword", args);
      return;
    }

    public ExecResp recv_changePassword() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.changePassword");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      changePassword_result result = new changePassword_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.changePassword", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "changePassword failed: unknown result");
    }

    public HBResp heartBeat(HBReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.heartBeat", null);
      this.setContextStack(ctx);
      send_heartBeat(req);
      return recv_heartBeat();
    }

    public void send_heartBeat(HBReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.heartBeat", null);
      oprot_.writeMessageBegin(new TMessage("heartBeat", TMessageType.CALL, seqid_));
      heartBeat_args args = new heartBeat_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.heartBeat", args);
      return;
    }

    public HBResp recv_heartBeat() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.heartBeat");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      heartBeat_result result = new heartBeat_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.heartBeat", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "heartBeat failed: unknown result");
    }

    public BalanceResp balance(BalanceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.balance", null);
      this.setContextStack(ctx);
      send_balance(req);
      return recv_balance();
    }

    public void send_balance(BalanceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.balance", null);
      oprot_.writeMessageBegin(new TMessage("balance", TMessageType.CALL, seqid_));
      balance_args args = new balance_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.balance", args);
      return;
    }

    public BalanceResp recv_balance() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.balance");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      balance_result result = new balance_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.balance", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "balance failed: unknown result");
    }

    public ExecResp leaderBalance(LeaderBalanceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.leaderBalance", null);
      this.setContextStack(ctx);
      send_leaderBalance(req);
      return recv_leaderBalance();
    }

    public void send_leaderBalance(LeaderBalanceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.leaderBalance", null);
      oprot_.writeMessageBegin(new TMessage("leaderBalance", TMessageType.CALL, seqid_));
      leaderBalance_args args = new leaderBalance_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.leaderBalance", args);
      return;
    }

    public ExecResp recv_leaderBalance() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.leaderBalance");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      leaderBalance_result result = new leaderBalance_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.leaderBalance", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "leaderBalance failed: unknown result");
    }

    public ExecResp regConfig(RegConfigReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.regConfig", null);
      this.setContextStack(ctx);
      send_regConfig(req);
      return recv_regConfig();
    }

    public void send_regConfig(RegConfigReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.regConfig", null);
      oprot_.writeMessageBegin(new TMessage("regConfig", TMessageType.CALL, seqid_));
      regConfig_args args = new regConfig_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.regConfig", args);
      return;
    }

    public ExecResp recv_regConfig() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.regConfig");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      regConfig_result result = new regConfig_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.regConfig", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "regConfig failed: unknown result");
    }

    public GetConfigResp getConfig(GetConfigReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getConfig", null);
      this.setContextStack(ctx);
      send_getConfig(req);
      return recv_getConfig();
    }

    public void send_getConfig(GetConfigReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getConfig", null);
      oprot_.writeMessageBegin(new TMessage("getConfig", TMessageType.CALL, seqid_));
      getConfig_args args = new getConfig_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getConfig", args);
      return;
    }

    public GetConfigResp recv_getConfig() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getConfig");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getConfig_result result = new getConfig_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getConfig", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getConfig failed: unknown result");
    }

    public ExecResp setConfig(SetConfigReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.setConfig", null);
      this.setContextStack(ctx);
      send_setConfig(req);
      return recv_setConfig();
    }

    public void send_setConfig(SetConfigReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.setConfig", null);
      oprot_.writeMessageBegin(new TMessage("setConfig", TMessageType.CALL, seqid_));
      setConfig_args args = new setConfig_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.setConfig", args);
      return;
    }

    public ExecResp recv_setConfig() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.setConfig");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      setConfig_result result = new setConfig_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.setConfig", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "setConfig failed: unknown result");
    }

    public ListConfigsResp listConfigs(ListConfigsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listConfigs", null);
      this.setContextStack(ctx);
      send_listConfigs(req);
      return recv_listConfigs();
    }

    public void send_listConfigs(ListConfigsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listConfigs", null);
      oprot_.writeMessageBegin(new TMessage("listConfigs", TMessageType.CALL, seqid_));
      listConfigs_args args = new listConfigs_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listConfigs", args);
      return;
    }

    public ListConfigsResp recv_listConfigs() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listConfigs");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listConfigs_result result = new listConfigs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listConfigs", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listConfigs failed: unknown result");
    }

    public ExecResp createSnapshot(CreateSnapshotReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createSnapshot", null);
      this.setContextStack(ctx);
      send_createSnapshot(req);
      return recv_createSnapshot();
    }

    public void send_createSnapshot(CreateSnapshotReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createSnapshot", null);
      oprot_.writeMessageBegin(new TMessage("createSnapshot", TMessageType.CALL, seqid_));
      createSnapshot_args args = new createSnapshot_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createSnapshot", args);
      return;
    }

    public ExecResp recv_createSnapshot() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createSnapshot");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createSnapshot_result result = new createSnapshot_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createSnapshot", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createSnapshot failed: unknown result");
    }

    public ExecResp dropSnapshot(DropSnapshotReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropSnapshot", null);
      this.setContextStack(ctx);
      send_dropSnapshot(req);
      return recv_dropSnapshot();
    }

    public void send_dropSnapshot(DropSnapshotReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropSnapshot", null);
      oprot_.writeMessageBegin(new TMessage("dropSnapshot", TMessageType.CALL, seqid_));
      dropSnapshot_args args = new dropSnapshot_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropSnapshot", args);
      return;
    }

    public ExecResp recv_dropSnapshot() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropSnapshot");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropSnapshot_result result = new dropSnapshot_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropSnapshot", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropSnapshot failed: unknown result");
    }

    public ListSnapshotsResp listSnapshots(ListSnapshotsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listSnapshots", null);
      this.setContextStack(ctx);
      send_listSnapshots(req);
      return recv_listSnapshots();
    }

    public void send_listSnapshots(ListSnapshotsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listSnapshots", null);
      oprot_.writeMessageBegin(new TMessage("listSnapshots", TMessageType.CALL, seqid_));
      listSnapshots_args args = new listSnapshots_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listSnapshots", args);
      return;
    }

    public ListSnapshotsResp recv_listSnapshots() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listSnapshots");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listSnapshots_result result = new listSnapshots_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listSnapshots", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listSnapshots failed: unknown result");
    }

    public AdminJobResp runAdminJob(AdminJobReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.runAdminJob", null);
      this.setContextStack(ctx);
      send_runAdminJob(req);
      return recv_runAdminJob();
    }

    public void send_runAdminJob(AdminJobReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.runAdminJob", null);
      oprot_.writeMessageBegin(new TMessage("runAdminJob", TMessageType.CALL, seqid_));
      runAdminJob_args args = new runAdminJob_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.runAdminJob", args);
      return;
    }

    public AdminJobResp recv_runAdminJob() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.runAdminJob");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      runAdminJob_result result = new runAdminJob_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.runAdminJob", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "runAdminJob failed: unknown result");
    }

    public ExecResp addZone(AddZoneReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.addZone", null);
      this.setContextStack(ctx);
      send_addZone(req);
      return recv_addZone();
    }

    public void send_addZone(AddZoneReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.addZone", null);
      oprot_.writeMessageBegin(new TMessage("addZone", TMessageType.CALL, seqid_));
      addZone_args args = new addZone_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.addZone", args);
      return;
    }

    public ExecResp recv_addZone() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.addZone");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      addZone_result result = new addZone_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.addZone", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "addZone failed: unknown result");
    }

    public ExecResp dropZone(DropZoneReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropZone", null);
      this.setContextStack(ctx);
      send_dropZone(req);
      return recv_dropZone();
    }

    public void send_dropZone(DropZoneReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropZone", null);
      oprot_.writeMessageBegin(new TMessage("dropZone", TMessageType.CALL, seqid_));
      dropZone_args args = new dropZone_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropZone", args);
      return;
    }

    public ExecResp recv_dropZone() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropZone");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropZone_result result = new dropZone_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropZone", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropZone failed: unknown result");
    }

    public ExecResp addHostIntoZone(AddHostIntoZoneReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.addHostIntoZone", null);
      this.setContextStack(ctx);
      send_addHostIntoZone(req);
      return recv_addHostIntoZone();
    }

    public void send_addHostIntoZone(AddHostIntoZoneReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.addHostIntoZone", null);
      oprot_.writeMessageBegin(new TMessage("addHostIntoZone", TMessageType.CALL, seqid_));
      addHostIntoZone_args args = new addHostIntoZone_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.addHostIntoZone", args);
      return;
    }

    public ExecResp recv_addHostIntoZone() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.addHostIntoZone");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      addHostIntoZone_result result = new addHostIntoZone_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.addHostIntoZone", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "addHostIntoZone failed: unknown result");
    }

    public ExecResp dropHostFromZone(DropHostFromZoneReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropHostFromZone", null);
      this.setContextStack(ctx);
      send_dropHostFromZone(req);
      return recv_dropHostFromZone();
    }

    public void send_dropHostFromZone(DropHostFromZoneReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropHostFromZone", null);
      oprot_.writeMessageBegin(new TMessage("dropHostFromZone", TMessageType.CALL, seqid_));
      dropHostFromZone_args args = new dropHostFromZone_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropHostFromZone", args);
      return;
    }

    public ExecResp recv_dropHostFromZone() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropHostFromZone");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropHostFromZone_result result = new dropHostFromZone_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropHostFromZone", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropHostFromZone failed: unknown result");
    }

    public GetZoneResp getZone(GetZoneReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getZone", null);
      this.setContextStack(ctx);
      send_getZone(req);
      return recv_getZone();
    }

    public void send_getZone(GetZoneReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getZone", null);
      oprot_.writeMessageBegin(new TMessage("getZone", TMessageType.CALL, seqid_));
      getZone_args args = new getZone_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getZone", args);
      return;
    }

    public GetZoneResp recv_getZone() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getZone");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getZone_result result = new getZone_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getZone", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getZone failed: unknown result");
    }

    public ListZonesResp listZones(ListZonesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listZones", null);
      this.setContextStack(ctx);
      send_listZones(req);
      return recv_listZones();
    }

    public void send_listZones(ListZonesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listZones", null);
      oprot_.writeMessageBegin(new TMessage("listZones", TMessageType.CALL, seqid_));
      listZones_args args = new listZones_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listZones", args);
      return;
    }

    public ListZonesResp recv_listZones() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listZones");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listZones_result result = new listZones_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listZones", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listZones failed: unknown result");
    }

    public ExecResp addGroup(AddGroupReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.addGroup", null);
      this.setContextStack(ctx);
      send_addGroup(req);
      return recv_addGroup();
    }

    public void send_addGroup(AddGroupReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.addGroup", null);
      oprot_.writeMessageBegin(new TMessage("addGroup", TMessageType.CALL, seqid_));
      addGroup_args args = new addGroup_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.addGroup", args);
      return;
    }

    public ExecResp recv_addGroup() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.addGroup");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      addGroup_result result = new addGroup_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.addGroup", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "addGroup failed: unknown result");
    }

    public ExecResp dropGroup(DropGroupReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropGroup", null);
      this.setContextStack(ctx);
      send_dropGroup(req);
      return recv_dropGroup();
    }

    public void send_dropGroup(DropGroupReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropGroup", null);
      oprot_.writeMessageBegin(new TMessage("dropGroup", TMessageType.CALL, seqid_));
      dropGroup_args args = new dropGroup_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropGroup", args);
      return;
    }

    public ExecResp recv_dropGroup() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropGroup");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropGroup_result result = new dropGroup_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropGroup", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropGroup failed: unknown result");
    }

    public ExecResp addZoneIntoGroup(AddZoneIntoGroupReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.addZoneIntoGroup", null);
      this.setContextStack(ctx);
      send_addZoneIntoGroup(req);
      return recv_addZoneIntoGroup();
    }

    public void send_addZoneIntoGroup(AddZoneIntoGroupReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.addZoneIntoGroup", null);
      oprot_.writeMessageBegin(new TMessage("addZoneIntoGroup", TMessageType.CALL, seqid_));
      addZoneIntoGroup_args args = new addZoneIntoGroup_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.addZoneIntoGroup", args);
      return;
    }

    public ExecResp recv_addZoneIntoGroup() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.addZoneIntoGroup");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      addZoneIntoGroup_result result = new addZoneIntoGroup_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.addZoneIntoGroup", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "addZoneIntoGroup failed: unknown result");
    }

    public ExecResp dropZoneFromGroup(DropZoneFromGroupReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropZoneFromGroup", null);
      this.setContextStack(ctx);
      send_dropZoneFromGroup(req);
      return recv_dropZoneFromGroup();
    }

    public void send_dropZoneFromGroup(DropZoneFromGroupReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropZoneFromGroup", null);
      oprot_.writeMessageBegin(new TMessage("dropZoneFromGroup", TMessageType.CALL, seqid_));
      dropZoneFromGroup_args args = new dropZoneFromGroup_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropZoneFromGroup", args);
      return;
    }

    public ExecResp recv_dropZoneFromGroup() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropZoneFromGroup");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropZoneFromGroup_result result = new dropZoneFromGroup_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropZoneFromGroup", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropZoneFromGroup failed: unknown result");
    }

    public GetGroupResp getGroup(GetGroupReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getGroup", null);
      this.setContextStack(ctx);
      send_getGroup(req);
      return recv_getGroup();
    }

    public void send_getGroup(GetGroupReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getGroup", null);
      oprot_.writeMessageBegin(new TMessage("getGroup", TMessageType.CALL, seqid_));
      getGroup_args args = new getGroup_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getGroup", args);
      return;
    }

    public GetGroupResp recv_getGroup() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getGroup");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getGroup_result result = new getGroup_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getGroup", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getGroup failed: unknown result");
    }

    public ListGroupsResp listGroups(ListGroupsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listGroups", null);
      this.setContextStack(ctx);
      send_listGroups(req);
      return recv_listGroups();
    }

    public void send_listGroups(ListGroupsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listGroups", null);
      oprot_.writeMessageBegin(new TMessage("listGroups", TMessageType.CALL, seqid_));
      listGroups_args args = new listGroups_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listGroups", args);
      return;
    }

    public ListGroupsResp recv_listGroups() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listGroups");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listGroups_result result = new listGroups_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listGroups", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listGroups failed: unknown result");
    }

    public CreateBackupResp createBackup(CreateBackupReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createBackup", null);
      this.setContextStack(ctx);
      send_createBackup(req);
      return recv_createBackup();
    }

    public void send_createBackup(CreateBackupReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createBackup", null);
      oprot_.writeMessageBegin(new TMessage("createBackup", TMessageType.CALL, seqid_));
      createBackup_args args = new createBackup_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createBackup", args);
      return;
    }

    public CreateBackupResp recv_createBackup() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createBackup");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createBackup_result result = new createBackup_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createBackup", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createBackup failed: unknown result");
    }

    public ExecResp restoreMeta(RestoreMetaReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.restoreMeta", null);
      this.setContextStack(ctx);
      send_restoreMeta(req);
      return recv_restoreMeta();
    }

    public void send_restoreMeta(RestoreMetaReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.restoreMeta", null);
      oprot_.writeMessageBegin(new TMessage("restoreMeta", TMessageType.CALL, seqid_));
      restoreMeta_args args = new restoreMeta_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.restoreMeta", args);
      return;
    }

    public ExecResp recv_restoreMeta() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.restoreMeta");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      restoreMeta_result result = new restoreMeta_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.restoreMeta", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "restoreMeta failed: unknown result");
    }

    public ExecResp addListener(AddListenerReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.addListener", null);
      this.setContextStack(ctx);
      send_addListener(req);
      return recv_addListener();
    }

    public void send_addListener(AddListenerReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.addListener", null);
      oprot_.writeMessageBegin(new TMessage("addListener", TMessageType.CALL, seqid_));
      addListener_args args = new addListener_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.addListener", args);
      return;
    }

    public ExecResp recv_addListener() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.addListener");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      addListener_result result = new addListener_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.addListener", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "addListener failed: unknown result");
    }

    public ExecResp removeListener(RemoveListenerReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.removeListener", null);
      this.setContextStack(ctx);
      send_removeListener(req);
      return recv_removeListener();
    }

    public void send_removeListener(RemoveListenerReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.removeListener", null);
      oprot_.writeMessageBegin(new TMessage("removeListener", TMessageType.CALL, seqid_));
      removeListener_args args = new removeListener_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.removeListener", args);
      return;
    }

    public ExecResp recv_removeListener() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.removeListener");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      removeListener_result result = new removeListener_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.removeListener", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "removeListener failed: unknown result");
    }

    public ListListenerResp listListener(ListListenerReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listListener", null);
      this.setContextStack(ctx);
      send_listListener(req);
      return recv_listListener();
    }

    public void send_listListener(ListListenerReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listListener", null);
      oprot_.writeMessageBegin(new TMessage("listListener", TMessageType.CALL, seqid_));
      listListener_args args = new listListener_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listListener", args);
      return;
    }

    public ListListenerResp recv_listListener() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listListener");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listListener_result result = new listListener_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listListener", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listListener failed: unknown result");
    }

    public GetStatisResp getStatis(GetStatisReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getStatis", null);
      this.setContextStack(ctx);
      send_getStatis(req);
      return recv_getStatis();
    }

    public void send_getStatis(GetStatisReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getStatis", null);
      oprot_.writeMessageBegin(new TMessage("getStatis", TMessageType.CALL, seqid_));
      getStatis_args args = new getStatis_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getStatis", args);
      return;
    }

    public GetStatisResp recv_getStatis() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getStatis");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getStatis_result result = new getStatis_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getStatis", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getStatis failed: unknown result");
    }

    public ExecResp signInFTService(SignInFTServiceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.signInFTService", null);
      this.setContextStack(ctx);
      send_signInFTService(req);
      return recv_signInFTService();
    }

    public void send_signInFTService(SignInFTServiceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.signInFTService", null);
      oprot_.writeMessageBegin(new TMessage("signInFTService", TMessageType.CALL, seqid_));
      signInFTService_args args = new signInFTService_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.signInFTService", args);
      return;
    }

    public ExecResp recv_signInFTService() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.signInFTService");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      signInFTService_result result = new signInFTService_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.signInFTService", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "signInFTService failed: unknown result");
    }

    public ExecResp signOutFTService(SignOutFTServiceReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.signOutFTService", null);
      this.setContextStack(ctx);
      send_signOutFTService(req);
      return recv_signOutFTService();
    }

    public void send_signOutFTService(SignOutFTServiceReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.signOutFTService", null);
      oprot_.writeMessageBegin(new TMessage("signOutFTService", TMessageType.CALL, seqid_));
      signOutFTService_args args = new signOutFTService_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.signOutFTService", args);
      return;
    }

    public ExecResp recv_signOutFTService() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.signOutFTService");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      signOutFTService_result result = new signOutFTService_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.signOutFTService", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "signOutFTService failed: unknown result");
    }

    public ListFTClientsResp listFTClients(ListFTClientsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listFTClients", null);
      this.setContextStack(ctx);
      send_listFTClients(req);
      return recv_listFTClients();
    }

    public void send_listFTClients(ListFTClientsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listFTClients", null);
      oprot_.writeMessageBegin(new TMessage("listFTClients", TMessageType.CALL, seqid_));
      listFTClients_args args = new listFTClients_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listFTClients", args);
      return;
    }

    public ListFTClientsResp recv_listFTClients() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listFTClients");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listFTClients_result result = new listFTClients_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listFTClients", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listFTClients failed: unknown result");
    }

    public ExecResp createFTIndex(CreateFTIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createFTIndex", null);
      this.setContextStack(ctx);
      send_createFTIndex(req);
      return recv_createFTIndex();
    }

    public void send_createFTIndex(CreateFTIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createFTIndex", null);
      oprot_.writeMessageBegin(new TMessage("createFTIndex", TMessageType.CALL, seqid_));
      createFTIndex_args args = new createFTIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createFTIndex", args);
      return;
    }

    public ExecResp recv_createFTIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createFTIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createFTIndex_result result = new createFTIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createFTIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createFTIndex failed: unknown result");
    }

    public ExecResp dropFTIndex(DropFTIndexReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.dropFTIndex", null);
      this.setContextStack(ctx);
      send_dropFTIndex(req);
      return recv_dropFTIndex();
    }

    public void send_dropFTIndex(DropFTIndexReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.dropFTIndex", null);
      oprot_.writeMessageBegin(new TMessage("dropFTIndex", TMessageType.CALL, seqid_));
      dropFTIndex_args args = new dropFTIndex_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.dropFTIndex", args);
      return;
    }

    public ExecResp recv_dropFTIndex() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.dropFTIndex");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropFTIndex_result result = new dropFTIndex_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.dropFTIndex", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dropFTIndex failed: unknown result");
    }

    public ListFTIndexesResp listFTIndexes(ListFTIndexesReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listFTIndexes", null);
      this.setContextStack(ctx);
      send_listFTIndexes(req);
      return recv_listFTIndexes();
    }

    public void send_listFTIndexes(ListFTIndexesReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listFTIndexes", null);
      oprot_.writeMessageBegin(new TMessage("listFTIndexes", TMessageType.CALL, seqid_));
      listFTIndexes_args args = new listFTIndexes_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listFTIndexes", args);
      return;
    }

    public ListFTIndexesResp recv_listFTIndexes() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listFTIndexes");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listFTIndexes_result result = new listFTIndexes_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listFTIndexes", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listFTIndexes failed: unknown result");
    }

    public CreateSessionResp createSession(CreateSessionReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.createSession", null);
      this.setContextStack(ctx);
      send_createSession(req);
      return recv_createSession();
    }

    public void send_createSession(CreateSessionReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.createSession", null);
      oprot_.writeMessageBegin(new TMessage("createSession", TMessageType.CALL, seqid_));
      createSession_args args = new createSession_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.createSession", args);
      return;
    }

    public CreateSessionResp recv_createSession() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.createSession");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createSession_result result = new createSession_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.createSession", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createSession failed: unknown result");
    }

    public UpdateSessionsResp updateSessions(UpdateSessionsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.updateSessions", null);
      this.setContextStack(ctx);
      send_updateSessions(req);
      return recv_updateSessions();
    }

    public void send_updateSessions(UpdateSessionsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.updateSessions", null);
      oprot_.writeMessageBegin(new TMessage("updateSessions", TMessageType.CALL, seqid_));
      updateSessions_args args = new updateSessions_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.updateSessions", args);
      return;
    }

    public UpdateSessionsResp recv_updateSessions() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.updateSessions");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      updateSessions_result result = new updateSessions_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.updateSessions", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "updateSessions failed: unknown result");
    }

    public ListSessionsResp listSessions(ListSessionsReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listSessions", null);
      this.setContextStack(ctx);
      send_listSessions(req);
      return recv_listSessions();
    }

    public void send_listSessions(ListSessionsReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listSessions", null);
      oprot_.writeMessageBegin(new TMessage("listSessions", TMessageType.CALL, seqid_));
      listSessions_args args = new listSessions_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listSessions", args);
      return;
    }

    public ListSessionsResp recv_listSessions() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listSessions");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listSessions_result result = new listSessions_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listSessions", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listSessions failed: unknown result");
    }

    public GetSessionResp getSession(GetSessionReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getSession", null);
      this.setContextStack(ctx);
      send_getSession(req);
      return recv_getSession();
    }

    public void send_getSession(GetSessionReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getSession", null);
      oprot_.writeMessageBegin(new TMessage("getSession", TMessageType.CALL, seqid_));
      getSession_args args = new getSession_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getSession", args);
      return;
    }

    public GetSessionResp recv_getSession() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getSession");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getSession_result result = new getSession_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getSession", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getSession failed: unknown result");
    }

    public ExecResp removeSession(RemoveSessionReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.removeSession", null);
      this.setContextStack(ctx);
      send_removeSession(req);
      return recv_removeSession();
    }

    public void send_removeSession(RemoveSessionReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.removeSession", null);
      oprot_.writeMessageBegin(new TMessage("removeSession", TMessageType.CALL, seqid_));
      removeSession_args args = new removeSession_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.removeSession", args);
      return;
    }

    public ExecResp recv_removeSession() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.removeSession");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      removeSession_result result = new removeSession_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.removeSession", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "removeSession failed: unknown result");
    }

    public ExecResp killQuery(KillQueryReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.killQuery", null);
      this.setContextStack(ctx);
      send_killQuery(req);
      return recv_killQuery();
    }

    public void send_killQuery(KillQueryReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.killQuery", null);
      oprot_.writeMessageBegin(new TMessage("killQuery", TMessageType.CALL, seqid_));
      killQuery_args args = new killQuery_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.killQuery", args);
      return;
    }

    public ExecResp recv_killQuery() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.killQuery");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      killQuery_result result = new killQuery_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.killQuery", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "killQuery failed: unknown result");
    }

    public ExecResp reportTaskFinish(ReportTaskReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.reportTaskFinish", null);
      this.setContextStack(ctx);
      send_reportTaskFinish(req);
      return recv_reportTaskFinish();
    }

    public void send_reportTaskFinish(ReportTaskReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.reportTaskFinish", null);
      oprot_.writeMessageBegin(new TMessage("reportTaskFinish", TMessageType.CALL, seqid_));
      reportTaskFinish_args args = new reportTaskFinish_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.reportTaskFinish", args);
      return;
    }

    public ExecResp recv_reportTaskFinish() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.reportTaskFinish");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      reportTaskFinish_result result = new reportTaskFinish_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.reportTaskFinish", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "reportTaskFinish failed: unknown result");
    }

    public ListClusterInfoResp listCluster(ListClusterInfoReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.listCluster", null);
      this.setContextStack(ctx);
      send_listCluster(req);
      return recv_listCluster();
    }

    public void send_listCluster(ListClusterInfoReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.listCluster", null);
      oprot_.writeMessageBegin(new TMessage("listCluster", TMessageType.CALL, seqid_));
      listCluster_args args = new listCluster_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.listCluster", args);
      return;
    }

    public ListClusterInfoResp recv_listCluster() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.listCluster");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listCluster_result result = new listCluster_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.listCluster", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listCluster failed: unknown result");
    }

    public GetMetaDirInfoResp getMetaDirInfo(GetMetaDirInfoReq req) throws TException
    {
      ContextStack ctx = getContextStack("MetaService.getMetaDirInfo", null);
      this.setContextStack(ctx);
      send_getMetaDirInfo(req);
      return recv_getMetaDirInfo();
    }

    public void send_getMetaDirInfo(GetMetaDirInfoReq req) throws TException
    {
      ContextStack ctx = this.getContextStack();
      super.preWrite(ctx, "MetaService.getMetaDirInfo", null);
      oprot_.writeMessageBegin(new TMessage("getMetaDirInfo", TMessageType.CALL, seqid_));
      getMetaDirInfo_args args = new getMetaDirInfo_args();
      args.req = req;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
      super.postWrite(ctx, "MetaService.getMetaDirInfo", args);
      return;
    }

    public GetMetaDirInfoResp recv_getMetaDirInfo() throws TException
    {
      ContextStack ctx = super.getContextStack();
      long bytes;
      TMessageType mtype;
      super.preRead(ctx, "MetaService.getMetaDirInfo");
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getMetaDirInfo_result result = new getMetaDirInfo_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      super.postRead(ctx, "MetaService.getMetaDirInfo", result);

      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getMetaDirInfo failed: unknown result");
    }

  }
  public static class AsyncClient extends TAsyncClient implements AsyncIface {
    public static class Factory implements TAsyncClientFactory<AsyncClient> {
      private TAsyncClientManager clientManager;
      private TProtocolFactory protocolFactory;
      public Factory(TAsyncClientManager clientManager, TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(TProtocolFactory protocolFactory, TAsyncClientManager clientManager, TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void createSpace(CreateSpaceReq req, AsyncMethodCallback resultHandler424) throws TException {
      checkReady();
      createSpace_call method_call = new createSpace_call(req, resultHandler424, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createSpace_call extends TAsyncMethodCall {
      private CreateSpaceReq req;
      public createSpace_call(CreateSpaceReq req, AsyncMethodCallback resultHandler425, TAsyncClient client421, TProtocolFactory protocolFactory422, TNonblockingTransport transport423) throws TException {
        super(client421, protocolFactory422, transport423, resultHandler425, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createSpace", TMessageType.CALL, 0));
        createSpace_args args = new createSpace_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createSpace();
      }
    }

    public void dropSpace(DropSpaceReq req, AsyncMethodCallback resultHandler429) throws TException {
      checkReady();
      dropSpace_call method_call = new dropSpace_call(req, resultHandler429, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropSpace_call extends TAsyncMethodCall {
      private DropSpaceReq req;
      public dropSpace_call(DropSpaceReq req, AsyncMethodCallback resultHandler430, TAsyncClient client426, TProtocolFactory protocolFactory427, TNonblockingTransport transport428) throws TException {
        super(client426, protocolFactory427, transport428, resultHandler430, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropSpace", TMessageType.CALL, 0));
        dropSpace_args args = new dropSpace_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropSpace();
      }
    }

    public void getSpace(GetSpaceReq req, AsyncMethodCallback resultHandler434) throws TException {
      checkReady();
      getSpace_call method_call = new getSpace_call(req, resultHandler434, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getSpace_call extends TAsyncMethodCall {
      private GetSpaceReq req;
      public getSpace_call(GetSpaceReq req, AsyncMethodCallback resultHandler435, TAsyncClient client431, TProtocolFactory protocolFactory432, TNonblockingTransport transport433) throws TException {
        super(client431, protocolFactory432, transport433, resultHandler435, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getSpace", TMessageType.CALL, 0));
        getSpace_args args = new getSpace_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetSpaceResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getSpace();
      }
    }

    public void listSpaces(ListSpacesReq req, AsyncMethodCallback resultHandler439) throws TException {
      checkReady();
      listSpaces_call method_call = new listSpaces_call(req, resultHandler439, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listSpaces_call extends TAsyncMethodCall {
      private ListSpacesReq req;
      public listSpaces_call(ListSpacesReq req, AsyncMethodCallback resultHandler440, TAsyncClient client436, TProtocolFactory protocolFactory437, TNonblockingTransport transport438) throws TException {
        super(client436, protocolFactory437, transport438, resultHandler440, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listSpaces", TMessageType.CALL, 0));
        listSpaces_args args = new listSpaces_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListSpacesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listSpaces();
      }
    }

    public void createTag(CreateTagReq req, AsyncMethodCallback resultHandler444) throws TException {
      checkReady();
      createTag_call method_call = new createTag_call(req, resultHandler444, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createTag_call extends TAsyncMethodCall {
      private CreateTagReq req;
      public createTag_call(CreateTagReq req, AsyncMethodCallback resultHandler445, TAsyncClient client441, TProtocolFactory protocolFactory442, TNonblockingTransport transport443) throws TException {
        super(client441, protocolFactory442, transport443, resultHandler445, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createTag", TMessageType.CALL, 0));
        createTag_args args = new createTag_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createTag();
      }
    }

    public void alterTag(AlterTagReq req, AsyncMethodCallback resultHandler449) throws TException {
      checkReady();
      alterTag_call method_call = new alterTag_call(req, resultHandler449, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class alterTag_call extends TAsyncMethodCall {
      private AlterTagReq req;
      public alterTag_call(AlterTagReq req, AsyncMethodCallback resultHandler450, TAsyncClient client446, TProtocolFactory protocolFactory447, TNonblockingTransport transport448) throws TException {
        super(client446, protocolFactory447, transport448, resultHandler450, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("alterTag", TMessageType.CALL, 0));
        alterTag_args args = new alterTag_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_alterTag();
      }
    }

    public void dropTag(DropTagReq req, AsyncMethodCallback resultHandler454) throws TException {
      checkReady();
      dropTag_call method_call = new dropTag_call(req, resultHandler454, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropTag_call extends TAsyncMethodCall {
      private DropTagReq req;
      public dropTag_call(DropTagReq req, AsyncMethodCallback resultHandler455, TAsyncClient client451, TProtocolFactory protocolFactory452, TNonblockingTransport transport453) throws TException {
        super(client451, protocolFactory452, transport453, resultHandler455, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropTag", TMessageType.CALL, 0));
        dropTag_args args = new dropTag_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropTag();
      }
    }

    public void getTag(GetTagReq req, AsyncMethodCallback resultHandler459) throws TException {
      checkReady();
      getTag_call method_call = new getTag_call(req, resultHandler459, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getTag_call extends TAsyncMethodCall {
      private GetTagReq req;
      public getTag_call(GetTagReq req, AsyncMethodCallback resultHandler460, TAsyncClient client456, TProtocolFactory protocolFactory457, TNonblockingTransport transport458) throws TException {
        super(client456, protocolFactory457, transport458, resultHandler460, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTag", TMessageType.CALL, 0));
        getTag_args args = new getTag_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetTagResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTag();
      }
    }

    public void listTags(ListTagsReq req, AsyncMethodCallback resultHandler464) throws TException {
      checkReady();
      listTags_call method_call = new listTags_call(req, resultHandler464, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listTags_call extends TAsyncMethodCall {
      private ListTagsReq req;
      public listTags_call(ListTagsReq req, AsyncMethodCallback resultHandler465, TAsyncClient client461, TProtocolFactory protocolFactory462, TNonblockingTransport transport463) throws TException {
        super(client461, protocolFactory462, transport463, resultHandler465, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listTags", TMessageType.CALL, 0));
        listTags_args args = new listTags_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListTagsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listTags();
      }
    }

    public void createEdge(CreateEdgeReq req, AsyncMethodCallback resultHandler469) throws TException {
      checkReady();
      createEdge_call method_call = new createEdge_call(req, resultHandler469, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createEdge_call extends TAsyncMethodCall {
      private CreateEdgeReq req;
      public createEdge_call(CreateEdgeReq req, AsyncMethodCallback resultHandler470, TAsyncClient client466, TProtocolFactory protocolFactory467, TNonblockingTransport transport468) throws TException {
        super(client466, protocolFactory467, transport468, resultHandler470, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createEdge", TMessageType.CALL, 0));
        createEdge_args args = new createEdge_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createEdge();
      }
    }

    public void alterEdge(AlterEdgeReq req, AsyncMethodCallback resultHandler474) throws TException {
      checkReady();
      alterEdge_call method_call = new alterEdge_call(req, resultHandler474, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class alterEdge_call extends TAsyncMethodCall {
      private AlterEdgeReq req;
      public alterEdge_call(AlterEdgeReq req, AsyncMethodCallback resultHandler475, TAsyncClient client471, TProtocolFactory protocolFactory472, TNonblockingTransport transport473) throws TException {
        super(client471, protocolFactory472, transport473, resultHandler475, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("alterEdge", TMessageType.CALL, 0));
        alterEdge_args args = new alterEdge_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_alterEdge();
      }
    }

    public void dropEdge(DropEdgeReq req, AsyncMethodCallback resultHandler479) throws TException {
      checkReady();
      dropEdge_call method_call = new dropEdge_call(req, resultHandler479, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropEdge_call extends TAsyncMethodCall {
      private DropEdgeReq req;
      public dropEdge_call(DropEdgeReq req, AsyncMethodCallback resultHandler480, TAsyncClient client476, TProtocolFactory protocolFactory477, TNonblockingTransport transport478) throws TException {
        super(client476, protocolFactory477, transport478, resultHandler480, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropEdge", TMessageType.CALL, 0));
        dropEdge_args args = new dropEdge_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropEdge();
      }
    }

    public void getEdge(GetEdgeReq req, AsyncMethodCallback resultHandler484) throws TException {
      checkReady();
      getEdge_call method_call = new getEdge_call(req, resultHandler484, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getEdge_call extends TAsyncMethodCall {
      private GetEdgeReq req;
      public getEdge_call(GetEdgeReq req, AsyncMethodCallback resultHandler485, TAsyncClient client481, TProtocolFactory protocolFactory482, TNonblockingTransport transport483) throws TException {
        super(client481, protocolFactory482, transport483, resultHandler485, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getEdge", TMessageType.CALL, 0));
        getEdge_args args = new getEdge_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetEdgeResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getEdge();
      }
    }

    public void listEdges(ListEdgesReq req, AsyncMethodCallback resultHandler489) throws TException {
      checkReady();
      listEdges_call method_call = new listEdges_call(req, resultHandler489, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listEdges_call extends TAsyncMethodCall {
      private ListEdgesReq req;
      public listEdges_call(ListEdgesReq req, AsyncMethodCallback resultHandler490, TAsyncClient client486, TProtocolFactory protocolFactory487, TNonblockingTransport transport488) throws TException {
        super(client486, protocolFactory487, transport488, resultHandler490, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listEdges", TMessageType.CALL, 0));
        listEdges_args args = new listEdges_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListEdgesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listEdges();
      }
    }

    public void listHosts(ListHostsReq req, AsyncMethodCallback resultHandler494) throws TException {
      checkReady();
      listHosts_call method_call = new listHosts_call(req, resultHandler494, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listHosts_call extends TAsyncMethodCall {
      private ListHostsReq req;
      public listHosts_call(ListHostsReq req, AsyncMethodCallback resultHandler495, TAsyncClient client491, TProtocolFactory protocolFactory492, TNonblockingTransport transport493) throws TException {
        super(client491, protocolFactory492, transport493, resultHandler495, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listHosts", TMessageType.CALL, 0));
        listHosts_args args = new listHosts_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListHostsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listHosts();
      }
    }

    public void getPartsAlloc(GetPartsAllocReq req, AsyncMethodCallback resultHandler499) throws TException {
      checkReady();
      getPartsAlloc_call method_call = new getPartsAlloc_call(req, resultHandler499, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getPartsAlloc_call extends TAsyncMethodCall {
      private GetPartsAllocReq req;
      public getPartsAlloc_call(GetPartsAllocReq req, AsyncMethodCallback resultHandler500, TAsyncClient client496, TProtocolFactory protocolFactory497, TNonblockingTransport transport498) throws TException {
        super(client496, protocolFactory497, transport498, resultHandler500, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getPartsAlloc", TMessageType.CALL, 0));
        getPartsAlloc_args args = new getPartsAlloc_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetPartsAllocResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getPartsAlloc();
      }
    }

    public void listParts(ListPartsReq req, AsyncMethodCallback resultHandler504) throws TException {
      checkReady();
      listParts_call method_call = new listParts_call(req, resultHandler504, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listParts_call extends TAsyncMethodCall {
      private ListPartsReq req;
      public listParts_call(ListPartsReq req, AsyncMethodCallback resultHandler505, TAsyncClient client501, TProtocolFactory protocolFactory502, TNonblockingTransport transport503) throws TException {
        super(client501, protocolFactory502, transport503, resultHandler505, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listParts", TMessageType.CALL, 0));
        listParts_args args = new listParts_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListPartsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listParts();
      }
    }

    public void multiPut(MultiPutReq req, AsyncMethodCallback resultHandler509) throws TException {
      checkReady();
      multiPut_call method_call = new multiPut_call(req, resultHandler509, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class multiPut_call extends TAsyncMethodCall {
      private MultiPutReq req;
      public multiPut_call(MultiPutReq req, AsyncMethodCallback resultHandler510, TAsyncClient client506, TProtocolFactory protocolFactory507, TNonblockingTransport transport508) throws TException {
        super(client506, protocolFactory507, transport508, resultHandler510, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("multiPut", TMessageType.CALL, 0));
        multiPut_args args = new multiPut_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_multiPut();
      }
    }

    public void get(GetReq req, AsyncMethodCallback resultHandler514) throws TException {
      checkReady();
      get_call method_call = new get_call(req, resultHandler514, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class get_call extends TAsyncMethodCall {
      private GetReq req;
      public get_call(GetReq req, AsyncMethodCallback resultHandler515, TAsyncClient client511, TProtocolFactory protocolFactory512, TNonblockingTransport transport513) throws TException {
        super(client511, protocolFactory512, transport513, resultHandler515, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get", TMessageType.CALL, 0));
        get_args args = new get_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get();
      }
    }

    public void multiGet(MultiGetReq req, AsyncMethodCallback resultHandler519) throws TException {
      checkReady();
      multiGet_call method_call = new multiGet_call(req, resultHandler519, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class multiGet_call extends TAsyncMethodCall {
      private MultiGetReq req;
      public multiGet_call(MultiGetReq req, AsyncMethodCallback resultHandler520, TAsyncClient client516, TProtocolFactory protocolFactory517, TNonblockingTransport transport518) throws TException {
        super(client516, protocolFactory517, transport518, resultHandler520, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("multiGet", TMessageType.CALL, 0));
        multiGet_args args = new multiGet_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public MultiGetResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_multiGet();
      }
    }

    public void remove(RemoveReq req, AsyncMethodCallback resultHandler524) throws TException {
      checkReady();
      remove_call method_call = new remove_call(req, resultHandler524, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class remove_call extends TAsyncMethodCall {
      private RemoveReq req;
      public remove_call(RemoveReq req, AsyncMethodCallback resultHandler525, TAsyncClient client521, TProtocolFactory protocolFactory522, TNonblockingTransport transport523) throws TException {
        super(client521, protocolFactory522, transport523, resultHandler525, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("remove", TMessageType.CALL, 0));
        remove_args args = new remove_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_remove();
      }
    }

    public void removeRange(RemoveRangeReq req, AsyncMethodCallback resultHandler529) throws TException {
      checkReady();
      removeRange_call method_call = new removeRange_call(req, resultHandler529, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class removeRange_call extends TAsyncMethodCall {
      private RemoveRangeReq req;
      public removeRange_call(RemoveRangeReq req, AsyncMethodCallback resultHandler530, TAsyncClient client526, TProtocolFactory protocolFactory527, TNonblockingTransport transport528) throws TException {
        super(client526, protocolFactory527, transport528, resultHandler530, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("removeRange", TMessageType.CALL, 0));
        removeRange_args args = new removeRange_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_removeRange();
      }
    }

    public void scan(ScanReq req, AsyncMethodCallback resultHandler534) throws TException {
      checkReady();
      scan_call method_call = new scan_call(req, resultHandler534, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class scan_call extends TAsyncMethodCall {
      private ScanReq req;
      public scan_call(ScanReq req, AsyncMethodCallback resultHandler535, TAsyncClient client531, TProtocolFactory protocolFactory532, TNonblockingTransport transport533) throws TException {
        super(client531, protocolFactory532, transport533, resultHandler535, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("scan", TMessageType.CALL, 0));
        scan_args args = new scan_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ScanResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_scan();
      }
    }

    public void createTagIndex(CreateTagIndexReq req, AsyncMethodCallback resultHandler539) throws TException {
      checkReady();
      createTagIndex_call method_call = new createTagIndex_call(req, resultHandler539, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createTagIndex_call extends TAsyncMethodCall {
      private CreateTagIndexReq req;
      public createTagIndex_call(CreateTagIndexReq req, AsyncMethodCallback resultHandler540, TAsyncClient client536, TProtocolFactory protocolFactory537, TNonblockingTransport transport538) throws TException {
        super(client536, protocolFactory537, transport538, resultHandler540, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createTagIndex", TMessageType.CALL, 0));
        createTagIndex_args args = new createTagIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createTagIndex();
      }
    }

    public void dropTagIndex(DropTagIndexReq req, AsyncMethodCallback resultHandler544) throws TException {
      checkReady();
      dropTagIndex_call method_call = new dropTagIndex_call(req, resultHandler544, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropTagIndex_call extends TAsyncMethodCall {
      private DropTagIndexReq req;
      public dropTagIndex_call(DropTagIndexReq req, AsyncMethodCallback resultHandler545, TAsyncClient client541, TProtocolFactory protocolFactory542, TNonblockingTransport transport543) throws TException {
        super(client541, protocolFactory542, transport543, resultHandler545, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropTagIndex", TMessageType.CALL, 0));
        dropTagIndex_args args = new dropTagIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropTagIndex();
      }
    }

    public void getTagIndex(GetTagIndexReq req, AsyncMethodCallback resultHandler549) throws TException {
      checkReady();
      getTagIndex_call method_call = new getTagIndex_call(req, resultHandler549, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getTagIndex_call extends TAsyncMethodCall {
      private GetTagIndexReq req;
      public getTagIndex_call(GetTagIndexReq req, AsyncMethodCallback resultHandler550, TAsyncClient client546, TProtocolFactory protocolFactory547, TNonblockingTransport transport548) throws TException {
        super(client546, protocolFactory547, transport548, resultHandler550, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTagIndex", TMessageType.CALL, 0));
        getTagIndex_args args = new getTagIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetTagIndexResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTagIndex();
      }
    }

    public void listTagIndexes(ListTagIndexesReq req, AsyncMethodCallback resultHandler554) throws TException {
      checkReady();
      listTagIndexes_call method_call = new listTagIndexes_call(req, resultHandler554, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listTagIndexes_call extends TAsyncMethodCall {
      private ListTagIndexesReq req;
      public listTagIndexes_call(ListTagIndexesReq req, AsyncMethodCallback resultHandler555, TAsyncClient client551, TProtocolFactory protocolFactory552, TNonblockingTransport transport553) throws TException {
        super(client551, protocolFactory552, transport553, resultHandler555, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listTagIndexes", TMessageType.CALL, 0));
        listTagIndexes_args args = new listTagIndexes_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListTagIndexesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listTagIndexes();
      }
    }

    public void rebuildTagIndex(RebuildIndexReq req, AsyncMethodCallback resultHandler559) throws TException {
      checkReady();
      rebuildTagIndex_call method_call = new rebuildTagIndex_call(req, resultHandler559, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class rebuildTagIndex_call extends TAsyncMethodCall {
      private RebuildIndexReq req;
      public rebuildTagIndex_call(RebuildIndexReq req, AsyncMethodCallback resultHandler560, TAsyncClient client556, TProtocolFactory protocolFactory557, TNonblockingTransport transport558) throws TException {
        super(client556, protocolFactory557, transport558, resultHandler560, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("rebuildTagIndex", TMessageType.CALL, 0));
        rebuildTagIndex_args args = new rebuildTagIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_rebuildTagIndex();
      }
    }

    public void listTagIndexStatus(ListIndexStatusReq req, AsyncMethodCallback resultHandler564) throws TException {
      checkReady();
      listTagIndexStatus_call method_call = new listTagIndexStatus_call(req, resultHandler564, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listTagIndexStatus_call extends TAsyncMethodCall {
      private ListIndexStatusReq req;
      public listTagIndexStatus_call(ListIndexStatusReq req, AsyncMethodCallback resultHandler565, TAsyncClient client561, TProtocolFactory protocolFactory562, TNonblockingTransport transport563) throws TException {
        super(client561, protocolFactory562, transport563, resultHandler565, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listTagIndexStatus", TMessageType.CALL, 0));
        listTagIndexStatus_args args = new listTagIndexStatus_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListIndexStatusResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listTagIndexStatus();
      }
    }

    public void createEdgeIndex(CreateEdgeIndexReq req, AsyncMethodCallback resultHandler569) throws TException {
      checkReady();
      createEdgeIndex_call method_call = new createEdgeIndex_call(req, resultHandler569, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createEdgeIndex_call extends TAsyncMethodCall {
      private CreateEdgeIndexReq req;
      public createEdgeIndex_call(CreateEdgeIndexReq req, AsyncMethodCallback resultHandler570, TAsyncClient client566, TProtocolFactory protocolFactory567, TNonblockingTransport transport568) throws TException {
        super(client566, protocolFactory567, transport568, resultHandler570, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createEdgeIndex", TMessageType.CALL, 0));
        createEdgeIndex_args args = new createEdgeIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createEdgeIndex();
      }
    }

    public void dropEdgeIndex(DropEdgeIndexReq req, AsyncMethodCallback resultHandler574) throws TException {
      checkReady();
      dropEdgeIndex_call method_call = new dropEdgeIndex_call(req, resultHandler574, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropEdgeIndex_call extends TAsyncMethodCall {
      private DropEdgeIndexReq req;
      public dropEdgeIndex_call(DropEdgeIndexReq req, AsyncMethodCallback resultHandler575, TAsyncClient client571, TProtocolFactory protocolFactory572, TNonblockingTransport transport573) throws TException {
        super(client571, protocolFactory572, transport573, resultHandler575, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropEdgeIndex", TMessageType.CALL, 0));
        dropEdgeIndex_args args = new dropEdgeIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropEdgeIndex();
      }
    }

    public void getEdgeIndex(GetEdgeIndexReq req, AsyncMethodCallback resultHandler579) throws TException {
      checkReady();
      getEdgeIndex_call method_call = new getEdgeIndex_call(req, resultHandler579, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getEdgeIndex_call extends TAsyncMethodCall {
      private GetEdgeIndexReq req;
      public getEdgeIndex_call(GetEdgeIndexReq req, AsyncMethodCallback resultHandler580, TAsyncClient client576, TProtocolFactory protocolFactory577, TNonblockingTransport transport578) throws TException {
        super(client576, protocolFactory577, transport578, resultHandler580, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getEdgeIndex", TMessageType.CALL, 0));
        getEdgeIndex_args args = new getEdgeIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetEdgeIndexResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getEdgeIndex();
      }
    }

    public void listEdgeIndexes(ListEdgeIndexesReq req, AsyncMethodCallback resultHandler584) throws TException {
      checkReady();
      listEdgeIndexes_call method_call = new listEdgeIndexes_call(req, resultHandler584, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listEdgeIndexes_call extends TAsyncMethodCall {
      private ListEdgeIndexesReq req;
      public listEdgeIndexes_call(ListEdgeIndexesReq req, AsyncMethodCallback resultHandler585, TAsyncClient client581, TProtocolFactory protocolFactory582, TNonblockingTransport transport583) throws TException {
        super(client581, protocolFactory582, transport583, resultHandler585, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listEdgeIndexes", TMessageType.CALL, 0));
        listEdgeIndexes_args args = new listEdgeIndexes_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListEdgeIndexesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listEdgeIndexes();
      }
    }

    public void rebuildEdgeIndex(RebuildIndexReq req, AsyncMethodCallback resultHandler589) throws TException {
      checkReady();
      rebuildEdgeIndex_call method_call = new rebuildEdgeIndex_call(req, resultHandler589, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class rebuildEdgeIndex_call extends TAsyncMethodCall {
      private RebuildIndexReq req;
      public rebuildEdgeIndex_call(RebuildIndexReq req, AsyncMethodCallback resultHandler590, TAsyncClient client586, TProtocolFactory protocolFactory587, TNonblockingTransport transport588) throws TException {
        super(client586, protocolFactory587, transport588, resultHandler590, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("rebuildEdgeIndex", TMessageType.CALL, 0));
        rebuildEdgeIndex_args args = new rebuildEdgeIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_rebuildEdgeIndex();
      }
    }

    public void listEdgeIndexStatus(ListIndexStatusReq req, AsyncMethodCallback resultHandler594) throws TException {
      checkReady();
      listEdgeIndexStatus_call method_call = new listEdgeIndexStatus_call(req, resultHandler594, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listEdgeIndexStatus_call extends TAsyncMethodCall {
      private ListIndexStatusReq req;
      public listEdgeIndexStatus_call(ListIndexStatusReq req, AsyncMethodCallback resultHandler595, TAsyncClient client591, TProtocolFactory protocolFactory592, TNonblockingTransport transport593) throws TException {
        super(client591, protocolFactory592, transport593, resultHandler595, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listEdgeIndexStatus", TMessageType.CALL, 0));
        listEdgeIndexStatus_args args = new listEdgeIndexStatus_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListIndexStatusResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listEdgeIndexStatus();
      }
    }

    public void createUser(CreateUserReq req, AsyncMethodCallback resultHandler599) throws TException {
      checkReady();
      createUser_call method_call = new createUser_call(req, resultHandler599, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createUser_call extends TAsyncMethodCall {
      private CreateUserReq req;
      public createUser_call(CreateUserReq req, AsyncMethodCallback resultHandler600, TAsyncClient client596, TProtocolFactory protocolFactory597, TNonblockingTransport transport598) throws TException {
        super(client596, protocolFactory597, transport598, resultHandler600, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createUser", TMessageType.CALL, 0));
        createUser_args args = new createUser_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createUser();
      }
    }

    public void dropUser(DropUserReq req, AsyncMethodCallback resultHandler604) throws TException {
      checkReady();
      dropUser_call method_call = new dropUser_call(req, resultHandler604, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropUser_call extends TAsyncMethodCall {
      private DropUserReq req;
      public dropUser_call(DropUserReq req, AsyncMethodCallback resultHandler605, TAsyncClient client601, TProtocolFactory protocolFactory602, TNonblockingTransport transport603) throws TException {
        super(client601, protocolFactory602, transport603, resultHandler605, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropUser", TMessageType.CALL, 0));
        dropUser_args args = new dropUser_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropUser();
      }
    }

    public void alterUser(AlterUserReq req, AsyncMethodCallback resultHandler609) throws TException {
      checkReady();
      alterUser_call method_call = new alterUser_call(req, resultHandler609, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class alterUser_call extends TAsyncMethodCall {
      private AlterUserReq req;
      public alterUser_call(AlterUserReq req, AsyncMethodCallback resultHandler610, TAsyncClient client606, TProtocolFactory protocolFactory607, TNonblockingTransport transport608) throws TException {
        super(client606, protocolFactory607, transport608, resultHandler610, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("alterUser", TMessageType.CALL, 0));
        alterUser_args args = new alterUser_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_alterUser();
      }
    }

    public void grantRole(GrantRoleReq req, AsyncMethodCallback resultHandler614) throws TException {
      checkReady();
      grantRole_call method_call = new grantRole_call(req, resultHandler614, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class grantRole_call extends TAsyncMethodCall {
      private GrantRoleReq req;
      public grantRole_call(GrantRoleReq req, AsyncMethodCallback resultHandler615, TAsyncClient client611, TProtocolFactory protocolFactory612, TNonblockingTransport transport613) throws TException {
        super(client611, protocolFactory612, transport613, resultHandler615, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("grantRole", TMessageType.CALL, 0));
        grantRole_args args = new grantRole_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_grantRole();
      }
    }

    public void revokeRole(RevokeRoleReq req, AsyncMethodCallback resultHandler619) throws TException {
      checkReady();
      revokeRole_call method_call = new revokeRole_call(req, resultHandler619, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class revokeRole_call extends TAsyncMethodCall {
      private RevokeRoleReq req;
      public revokeRole_call(RevokeRoleReq req, AsyncMethodCallback resultHandler620, TAsyncClient client616, TProtocolFactory protocolFactory617, TNonblockingTransport transport618) throws TException {
        super(client616, protocolFactory617, transport618, resultHandler620, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("revokeRole", TMessageType.CALL, 0));
        revokeRole_args args = new revokeRole_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_revokeRole();
      }
    }

    public void listUsers(ListUsersReq req, AsyncMethodCallback resultHandler624) throws TException {
      checkReady();
      listUsers_call method_call = new listUsers_call(req, resultHandler624, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listUsers_call extends TAsyncMethodCall {
      private ListUsersReq req;
      public listUsers_call(ListUsersReq req, AsyncMethodCallback resultHandler625, TAsyncClient client621, TProtocolFactory protocolFactory622, TNonblockingTransport transport623) throws TException {
        super(client621, protocolFactory622, transport623, resultHandler625, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listUsers", TMessageType.CALL, 0));
        listUsers_args args = new listUsers_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListUsersResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listUsers();
      }
    }

    public void listRoles(ListRolesReq req, AsyncMethodCallback resultHandler629) throws TException {
      checkReady();
      listRoles_call method_call = new listRoles_call(req, resultHandler629, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listRoles_call extends TAsyncMethodCall {
      private ListRolesReq req;
      public listRoles_call(ListRolesReq req, AsyncMethodCallback resultHandler630, TAsyncClient client626, TProtocolFactory protocolFactory627, TNonblockingTransport transport628) throws TException {
        super(client626, protocolFactory627, transport628, resultHandler630, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listRoles", TMessageType.CALL, 0));
        listRoles_args args = new listRoles_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListRolesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listRoles();
      }
    }

    public void getUserRoles(GetUserRolesReq req, AsyncMethodCallback resultHandler634) throws TException {
      checkReady();
      getUserRoles_call method_call = new getUserRoles_call(req, resultHandler634, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getUserRoles_call extends TAsyncMethodCall {
      private GetUserRolesReq req;
      public getUserRoles_call(GetUserRolesReq req, AsyncMethodCallback resultHandler635, TAsyncClient client631, TProtocolFactory protocolFactory632, TNonblockingTransport transport633) throws TException {
        super(client631, protocolFactory632, transport633, resultHandler635, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getUserRoles", TMessageType.CALL, 0));
        getUserRoles_args args = new getUserRoles_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListRolesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getUserRoles();
      }
    }

    public void changePassword(ChangePasswordReq req, AsyncMethodCallback resultHandler639) throws TException {
      checkReady();
      changePassword_call method_call = new changePassword_call(req, resultHandler639, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class changePassword_call extends TAsyncMethodCall {
      private ChangePasswordReq req;
      public changePassword_call(ChangePasswordReq req, AsyncMethodCallback resultHandler640, TAsyncClient client636, TProtocolFactory protocolFactory637, TNonblockingTransport transport638) throws TException {
        super(client636, protocolFactory637, transport638, resultHandler640, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("changePassword", TMessageType.CALL, 0));
        changePassword_args args = new changePassword_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_changePassword();
      }
    }

    public void heartBeat(HBReq req, AsyncMethodCallback resultHandler644) throws TException {
      checkReady();
      heartBeat_call method_call = new heartBeat_call(req, resultHandler644, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class heartBeat_call extends TAsyncMethodCall {
      private HBReq req;
      public heartBeat_call(HBReq req, AsyncMethodCallback resultHandler645, TAsyncClient client641, TProtocolFactory protocolFactory642, TNonblockingTransport transport643) throws TException {
        super(client641, protocolFactory642, transport643, resultHandler645, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("heartBeat", TMessageType.CALL, 0));
        heartBeat_args args = new heartBeat_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public HBResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_heartBeat();
      }
    }

    public void balance(BalanceReq req, AsyncMethodCallback resultHandler649) throws TException {
      checkReady();
      balance_call method_call = new balance_call(req, resultHandler649, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class balance_call extends TAsyncMethodCall {
      private BalanceReq req;
      public balance_call(BalanceReq req, AsyncMethodCallback resultHandler650, TAsyncClient client646, TProtocolFactory protocolFactory647, TNonblockingTransport transport648) throws TException {
        super(client646, protocolFactory647, transport648, resultHandler650, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("balance", TMessageType.CALL, 0));
        balance_args args = new balance_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public BalanceResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_balance();
      }
    }

    public void leaderBalance(LeaderBalanceReq req, AsyncMethodCallback resultHandler654) throws TException {
      checkReady();
      leaderBalance_call method_call = new leaderBalance_call(req, resultHandler654, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class leaderBalance_call extends TAsyncMethodCall {
      private LeaderBalanceReq req;
      public leaderBalance_call(LeaderBalanceReq req, AsyncMethodCallback resultHandler655, TAsyncClient client651, TProtocolFactory protocolFactory652, TNonblockingTransport transport653) throws TException {
        super(client651, protocolFactory652, transport653, resultHandler655, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("leaderBalance", TMessageType.CALL, 0));
        leaderBalance_args args = new leaderBalance_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_leaderBalance();
      }
    }

    public void regConfig(RegConfigReq req, AsyncMethodCallback resultHandler659) throws TException {
      checkReady();
      regConfig_call method_call = new regConfig_call(req, resultHandler659, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class regConfig_call extends TAsyncMethodCall {
      private RegConfigReq req;
      public regConfig_call(RegConfigReq req, AsyncMethodCallback resultHandler660, TAsyncClient client656, TProtocolFactory protocolFactory657, TNonblockingTransport transport658) throws TException {
        super(client656, protocolFactory657, transport658, resultHandler660, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("regConfig", TMessageType.CALL, 0));
        regConfig_args args = new regConfig_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_regConfig();
      }
    }

    public void getConfig(GetConfigReq req, AsyncMethodCallback resultHandler664) throws TException {
      checkReady();
      getConfig_call method_call = new getConfig_call(req, resultHandler664, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getConfig_call extends TAsyncMethodCall {
      private GetConfigReq req;
      public getConfig_call(GetConfigReq req, AsyncMethodCallback resultHandler665, TAsyncClient client661, TProtocolFactory protocolFactory662, TNonblockingTransport transport663) throws TException {
        super(client661, protocolFactory662, transport663, resultHandler665, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getConfig", TMessageType.CALL, 0));
        getConfig_args args = new getConfig_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetConfigResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getConfig();
      }
    }

    public void setConfig(SetConfigReq req, AsyncMethodCallback resultHandler669) throws TException {
      checkReady();
      setConfig_call method_call = new setConfig_call(req, resultHandler669, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class setConfig_call extends TAsyncMethodCall {
      private SetConfigReq req;
      public setConfig_call(SetConfigReq req, AsyncMethodCallback resultHandler670, TAsyncClient client666, TProtocolFactory protocolFactory667, TNonblockingTransport transport668) throws TException {
        super(client666, protocolFactory667, transport668, resultHandler670, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("setConfig", TMessageType.CALL, 0));
        setConfig_args args = new setConfig_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_setConfig();
      }
    }

    public void listConfigs(ListConfigsReq req, AsyncMethodCallback resultHandler674) throws TException {
      checkReady();
      listConfigs_call method_call = new listConfigs_call(req, resultHandler674, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listConfigs_call extends TAsyncMethodCall {
      private ListConfigsReq req;
      public listConfigs_call(ListConfigsReq req, AsyncMethodCallback resultHandler675, TAsyncClient client671, TProtocolFactory protocolFactory672, TNonblockingTransport transport673) throws TException {
        super(client671, protocolFactory672, transport673, resultHandler675, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listConfigs", TMessageType.CALL, 0));
        listConfigs_args args = new listConfigs_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListConfigsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listConfigs();
      }
    }

    public void createSnapshot(CreateSnapshotReq req, AsyncMethodCallback resultHandler679) throws TException {
      checkReady();
      createSnapshot_call method_call = new createSnapshot_call(req, resultHandler679, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createSnapshot_call extends TAsyncMethodCall {
      private CreateSnapshotReq req;
      public createSnapshot_call(CreateSnapshotReq req, AsyncMethodCallback resultHandler680, TAsyncClient client676, TProtocolFactory protocolFactory677, TNonblockingTransport transport678) throws TException {
        super(client676, protocolFactory677, transport678, resultHandler680, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createSnapshot", TMessageType.CALL, 0));
        createSnapshot_args args = new createSnapshot_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createSnapshot();
      }
    }

    public void dropSnapshot(DropSnapshotReq req, AsyncMethodCallback resultHandler684) throws TException {
      checkReady();
      dropSnapshot_call method_call = new dropSnapshot_call(req, resultHandler684, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropSnapshot_call extends TAsyncMethodCall {
      private DropSnapshotReq req;
      public dropSnapshot_call(DropSnapshotReq req, AsyncMethodCallback resultHandler685, TAsyncClient client681, TProtocolFactory protocolFactory682, TNonblockingTransport transport683) throws TException {
        super(client681, protocolFactory682, transport683, resultHandler685, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropSnapshot", TMessageType.CALL, 0));
        dropSnapshot_args args = new dropSnapshot_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropSnapshot();
      }
    }

    public void listSnapshots(ListSnapshotsReq req, AsyncMethodCallback resultHandler689) throws TException {
      checkReady();
      listSnapshots_call method_call = new listSnapshots_call(req, resultHandler689, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listSnapshots_call extends TAsyncMethodCall {
      private ListSnapshotsReq req;
      public listSnapshots_call(ListSnapshotsReq req, AsyncMethodCallback resultHandler690, TAsyncClient client686, TProtocolFactory protocolFactory687, TNonblockingTransport transport688) throws TException {
        super(client686, protocolFactory687, transport688, resultHandler690, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listSnapshots", TMessageType.CALL, 0));
        listSnapshots_args args = new listSnapshots_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListSnapshotsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listSnapshots();
      }
    }

    public void runAdminJob(AdminJobReq req, AsyncMethodCallback resultHandler694) throws TException {
      checkReady();
      runAdminJob_call method_call = new runAdminJob_call(req, resultHandler694, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class runAdminJob_call extends TAsyncMethodCall {
      private AdminJobReq req;
      public runAdminJob_call(AdminJobReq req, AsyncMethodCallback resultHandler695, TAsyncClient client691, TProtocolFactory protocolFactory692, TNonblockingTransport transport693) throws TException {
        super(client691, protocolFactory692, transport693, resultHandler695, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("runAdminJob", TMessageType.CALL, 0));
        runAdminJob_args args = new runAdminJob_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public AdminJobResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_runAdminJob();
      }
    }

    public void addZone(AddZoneReq req, AsyncMethodCallback resultHandler699) throws TException {
      checkReady();
      addZone_call method_call = new addZone_call(req, resultHandler699, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class addZone_call extends TAsyncMethodCall {
      private AddZoneReq req;
      public addZone_call(AddZoneReq req, AsyncMethodCallback resultHandler700, TAsyncClient client696, TProtocolFactory protocolFactory697, TNonblockingTransport transport698) throws TException {
        super(client696, protocolFactory697, transport698, resultHandler700, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("addZone", TMessageType.CALL, 0));
        addZone_args args = new addZone_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_addZone();
      }
    }

    public void dropZone(DropZoneReq req, AsyncMethodCallback resultHandler704) throws TException {
      checkReady();
      dropZone_call method_call = new dropZone_call(req, resultHandler704, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropZone_call extends TAsyncMethodCall {
      private DropZoneReq req;
      public dropZone_call(DropZoneReq req, AsyncMethodCallback resultHandler705, TAsyncClient client701, TProtocolFactory protocolFactory702, TNonblockingTransport transport703) throws TException {
        super(client701, protocolFactory702, transport703, resultHandler705, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropZone", TMessageType.CALL, 0));
        dropZone_args args = new dropZone_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropZone();
      }
    }

    public void addHostIntoZone(AddHostIntoZoneReq req, AsyncMethodCallback resultHandler709) throws TException {
      checkReady();
      addHostIntoZone_call method_call = new addHostIntoZone_call(req, resultHandler709, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class addHostIntoZone_call extends TAsyncMethodCall {
      private AddHostIntoZoneReq req;
      public addHostIntoZone_call(AddHostIntoZoneReq req, AsyncMethodCallback resultHandler710, TAsyncClient client706, TProtocolFactory protocolFactory707, TNonblockingTransport transport708) throws TException {
        super(client706, protocolFactory707, transport708, resultHandler710, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("addHostIntoZone", TMessageType.CALL, 0));
        addHostIntoZone_args args = new addHostIntoZone_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_addHostIntoZone();
      }
    }

    public void dropHostFromZone(DropHostFromZoneReq req, AsyncMethodCallback resultHandler714) throws TException {
      checkReady();
      dropHostFromZone_call method_call = new dropHostFromZone_call(req, resultHandler714, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropHostFromZone_call extends TAsyncMethodCall {
      private DropHostFromZoneReq req;
      public dropHostFromZone_call(DropHostFromZoneReq req, AsyncMethodCallback resultHandler715, TAsyncClient client711, TProtocolFactory protocolFactory712, TNonblockingTransport transport713) throws TException {
        super(client711, protocolFactory712, transport713, resultHandler715, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropHostFromZone", TMessageType.CALL, 0));
        dropHostFromZone_args args = new dropHostFromZone_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropHostFromZone();
      }
    }

    public void getZone(GetZoneReq req, AsyncMethodCallback resultHandler719) throws TException {
      checkReady();
      getZone_call method_call = new getZone_call(req, resultHandler719, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getZone_call extends TAsyncMethodCall {
      private GetZoneReq req;
      public getZone_call(GetZoneReq req, AsyncMethodCallback resultHandler720, TAsyncClient client716, TProtocolFactory protocolFactory717, TNonblockingTransport transport718) throws TException {
        super(client716, protocolFactory717, transport718, resultHandler720, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getZone", TMessageType.CALL, 0));
        getZone_args args = new getZone_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetZoneResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getZone();
      }
    }

    public void listZones(ListZonesReq req, AsyncMethodCallback resultHandler724) throws TException {
      checkReady();
      listZones_call method_call = new listZones_call(req, resultHandler724, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listZones_call extends TAsyncMethodCall {
      private ListZonesReq req;
      public listZones_call(ListZonesReq req, AsyncMethodCallback resultHandler725, TAsyncClient client721, TProtocolFactory protocolFactory722, TNonblockingTransport transport723) throws TException {
        super(client721, protocolFactory722, transport723, resultHandler725, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listZones", TMessageType.CALL, 0));
        listZones_args args = new listZones_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListZonesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listZones();
      }
    }

    public void addGroup(AddGroupReq req, AsyncMethodCallback resultHandler729) throws TException {
      checkReady();
      addGroup_call method_call = new addGroup_call(req, resultHandler729, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class addGroup_call extends TAsyncMethodCall {
      private AddGroupReq req;
      public addGroup_call(AddGroupReq req, AsyncMethodCallback resultHandler730, TAsyncClient client726, TProtocolFactory protocolFactory727, TNonblockingTransport transport728) throws TException {
        super(client726, protocolFactory727, transport728, resultHandler730, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("addGroup", TMessageType.CALL, 0));
        addGroup_args args = new addGroup_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_addGroup();
      }
    }

    public void dropGroup(DropGroupReq req, AsyncMethodCallback resultHandler734) throws TException {
      checkReady();
      dropGroup_call method_call = new dropGroup_call(req, resultHandler734, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropGroup_call extends TAsyncMethodCall {
      private DropGroupReq req;
      public dropGroup_call(DropGroupReq req, AsyncMethodCallback resultHandler735, TAsyncClient client731, TProtocolFactory protocolFactory732, TNonblockingTransport transport733) throws TException {
        super(client731, protocolFactory732, transport733, resultHandler735, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropGroup", TMessageType.CALL, 0));
        dropGroup_args args = new dropGroup_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropGroup();
      }
    }

    public void addZoneIntoGroup(AddZoneIntoGroupReq req, AsyncMethodCallback resultHandler739) throws TException {
      checkReady();
      addZoneIntoGroup_call method_call = new addZoneIntoGroup_call(req, resultHandler739, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class addZoneIntoGroup_call extends TAsyncMethodCall {
      private AddZoneIntoGroupReq req;
      public addZoneIntoGroup_call(AddZoneIntoGroupReq req, AsyncMethodCallback resultHandler740, TAsyncClient client736, TProtocolFactory protocolFactory737, TNonblockingTransport transport738) throws TException {
        super(client736, protocolFactory737, transport738, resultHandler740, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("addZoneIntoGroup", TMessageType.CALL, 0));
        addZoneIntoGroup_args args = new addZoneIntoGroup_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_addZoneIntoGroup();
      }
    }

    public void dropZoneFromGroup(DropZoneFromGroupReq req, AsyncMethodCallback resultHandler744) throws TException {
      checkReady();
      dropZoneFromGroup_call method_call = new dropZoneFromGroup_call(req, resultHandler744, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropZoneFromGroup_call extends TAsyncMethodCall {
      private DropZoneFromGroupReq req;
      public dropZoneFromGroup_call(DropZoneFromGroupReq req, AsyncMethodCallback resultHandler745, TAsyncClient client741, TProtocolFactory protocolFactory742, TNonblockingTransport transport743) throws TException {
        super(client741, protocolFactory742, transport743, resultHandler745, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropZoneFromGroup", TMessageType.CALL, 0));
        dropZoneFromGroup_args args = new dropZoneFromGroup_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropZoneFromGroup();
      }
    }

    public void getGroup(GetGroupReq req, AsyncMethodCallback resultHandler749) throws TException {
      checkReady();
      getGroup_call method_call = new getGroup_call(req, resultHandler749, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getGroup_call extends TAsyncMethodCall {
      private GetGroupReq req;
      public getGroup_call(GetGroupReq req, AsyncMethodCallback resultHandler750, TAsyncClient client746, TProtocolFactory protocolFactory747, TNonblockingTransport transport748) throws TException {
        super(client746, protocolFactory747, transport748, resultHandler750, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getGroup", TMessageType.CALL, 0));
        getGroup_args args = new getGroup_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetGroupResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getGroup();
      }
    }

    public void listGroups(ListGroupsReq req, AsyncMethodCallback resultHandler754) throws TException {
      checkReady();
      listGroups_call method_call = new listGroups_call(req, resultHandler754, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listGroups_call extends TAsyncMethodCall {
      private ListGroupsReq req;
      public listGroups_call(ListGroupsReq req, AsyncMethodCallback resultHandler755, TAsyncClient client751, TProtocolFactory protocolFactory752, TNonblockingTransport transport753) throws TException {
        super(client751, protocolFactory752, transport753, resultHandler755, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listGroups", TMessageType.CALL, 0));
        listGroups_args args = new listGroups_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListGroupsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listGroups();
      }
    }

    public void createBackup(CreateBackupReq req, AsyncMethodCallback resultHandler759) throws TException {
      checkReady();
      createBackup_call method_call = new createBackup_call(req, resultHandler759, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createBackup_call extends TAsyncMethodCall {
      private CreateBackupReq req;
      public createBackup_call(CreateBackupReq req, AsyncMethodCallback resultHandler760, TAsyncClient client756, TProtocolFactory protocolFactory757, TNonblockingTransport transport758) throws TException {
        super(client756, protocolFactory757, transport758, resultHandler760, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createBackup", TMessageType.CALL, 0));
        createBackup_args args = new createBackup_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public CreateBackupResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createBackup();
      }
    }

    public void restoreMeta(RestoreMetaReq req, AsyncMethodCallback resultHandler764) throws TException {
      checkReady();
      restoreMeta_call method_call = new restoreMeta_call(req, resultHandler764, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class restoreMeta_call extends TAsyncMethodCall {
      private RestoreMetaReq req;
      public restoreMeta_call(RestoreMetaReq req, AsyncMethodCallback resultHandler765, TAsyncClient client761, TProtocolFactory protocolFactory762, TNonblockingTransport transport763) throws TException {
        super(client761, protocolFactory762, transport763, resultHandler765, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("restoreMeta", TMessageType.CALL, 0));
        restoreMeta_args args = new restoreMeta_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_restoreMeta();
      }
    }

    public void addListener(AddListenerReq req, AsyncMethodCallback resultHandler769) throws TException {
      checkReady();
      addListener_call method_call = new addListener_call(req, resultHandler769, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class addListener_call extends TAsyncMethodCall {
      private AddListenerReq req;
      public addListener_call(AddListenerReq req, AsyncMethodCallback resultHandler770, TAsyncClient client766, TProtocolFactory protocolFactory767, TNonblockingTransport transport768) throws TException {
        super(client766, protocolFactory767, transport768, resultHandler770, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("addListener", TMessageType.CALL, 0));
        addListener_args args = new addListener_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_addListener();
      }
    }

    public void removeListener(RemoveListenerReq req, AsyncMethodCallback resultHandler774) throws TException {
      checkReady();
      removeListener_call method_call = new removeListener_call(req, resultHandler774, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class removeListener_call extends TAsyncMethodCall {
      private RemoveListenerReq req;
      public removeListener_call(RemoveListenerReq req, AsyncMethodCallback resultHandler775, TAsyncClient client771, TProtocolFactory protocolFactory772, TNonblockingTransport transport773) throws TException {
        super(client771, protocolFactory772, transport773, resultHandler775, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("removeListener", TMessageType.CALL, 0));
        removeListener_args args = new removeListener_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_removeListener();
      }
    }

    public void listListener(ListListenerReq req, AsyncMethodCallback resultHandler779) throws TException {
      checkReady();
      listListener_call method_call = new listListener_call(req, resultHandler779, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listListener_call extends TAsyncMethodCall {
      private ListListenerReq req;
      public listListener_call(ListListenerReq req, AsyncMethodCallback resultHandler780, TAsyncClient client776, TProtocolFactory protocolFactory777, TNonblockingTransport transport778) throws TException {
        super(client776, protocolFactory777, transport778, resultHandler780, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listListener", TMessageType.CALL, 0));
        listListener_args args = new listListener_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListListenerResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listListener();
      }
    }

    public void getStatis(GetStatisReq req, AsyncMethodCallback resultHandler784) throws TException {
      checkReady();
      getStatis_call method_call = new getStatis_call(req, resultHandler784, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getStatis_call extends TAsyncMethodCall {
      private GetStatisReq req;
      public getStatis_call(GetStatisReq req, AsyncMethodCallback resultHandler785, TAsyncClient client781, TProtocolFactory protocolFactory782, TNonblockingTransport transport783) throws TException {
        super(client781, protocolFactory782, transport783, resultHandler785, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getStatis", TMessageType.CALL, 0));
        getStatis_args args = new getStatis_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetStatisResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getStatis();
      }
    }

    public void signInFTService(SignInFTServiceReq req, AsyncMethodCallback resultHandler789) throws TException {
      checkReady();
      signInFTService_call method_call = new signInFTService_call(req, resultHandler789, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class signInFTService_call extends TAsyncMethodCall {
      private SignInFTServiceReq req;
      public signInFTService_call(SignInFTServiceReq req, AsyncMethodCallback resultHandler790, TAsyncClient client786, TProtocolFactory protocolFactory787, TNonblockingTransport transport788) throws TException {
        super(client786, protocolFactory787, transport788, resultHandler790, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("signInFTService", TMessageType.CALL, 0));
        signInFTService_args args = new signInFTService_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_signInFTService();
      }
    }

    public void signOutFTService(SignOutFTServiceReq req, AsyncMethodCallback resultHandler794) throws TException {
      checkReady();
      signOutFTService_call method_call = new signOutFTService_call(req, resultHandler794, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class signOutFTService_call extends TAsyncMethodCall {
      private SignOutFTServiceReq req;
      public signOutFTService_call(SignOutFTServiceReq req, AsyncMethodCallback resultHandler795, TAsyncClient client791, TProtocolFactory protocolFactory792, TNonblockingTransport transport793) throws TException {
        super(client791, protocolFactory792, transport793, resultHandler795, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("signOutFTService", TMessageType.CALL, 0));
        signOutFTService_args args = new signOutFTService_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_signOutFTService();
      }
    }

    public void listFTClients(ListFTClientsReq req, AsyncMethodCallback resultHandler799) throws TException {
      checkReady();
      listFTClients_call method_call = new listFTClients_call(req, resultHandler799, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listFTClients_call extends TAsyncMethodCall {
      private ListFTClientsReq req;
      public listFTClients_call(ListFTClientsReq req, AsyncMethodCallback resultHandler800, TAsyncClient client796, TProtocolFactory protocolFactory797, TNonblockingTransport transport798) throws TException {
        super(client796, protocolFactory797, transport798, resultHandler800, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listFTClients", TMessageType.CALL, 0));
        listFTClients_args args = new listFTClients_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListFTClientsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listFTClients();
      }
    }

    public void createFTIndex(CreateFTIndexReq req, AsyncMethodCallback resultHandler804) throws TException {
      checkReady();
      createFTIndex_call method_call = new createFTIndex_call(req, resultHandler804, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createFTIndex_call extends TAsyncMethodCall {
      private CreateFTIndexReq req;
      public createFTIndex_call(CreateFTIndexReq req, AsyncMethodCallback resultHandler805, TAsyncClient client801, TProtocolFactory protocolFactory802, TNonblockingTransport transport803) throws TException {
        super(client801, protocolFactory802, transport803, resultHandler805, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createFTIndex", TMessageType.CALL, 0));
        createFTIndex_args args = new createFTIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createFTIndex();
      }
    }

    public void dropFTIndex(DropFTIndexReq req, AsyncMethodCallback resultHandler809) throws TException {
      checkReady();
      dropFTIndex_call method_call = new dropFTIndex_call(req, resultHandler809, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class dropFTIndex_call extends TAsyncMethodCall {
      private DropFTIndexReq req;
      public dropFTIndex_call(DropFTIndexReq req, AsyncMethodCallback resultHandler810, TAsyncClient client806, TProtocolFactory protocolFactory807, TNonblockingTransport transport808) throws TException {
        super(client806, protocolFactory807, transport808, resultHandler810, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("dropFTIndex", TMessageType.CALL, 0));
        dropFTIndex_args args = new dropFTIndex_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_dropFTIndex();
      }
    }

    public void listFTIndexes(ListFTIndexesReq req, AsyncMethodCallback resultHandler814) throws TException {
      checkReady();
      listFTIndexes_call method_call = new listFTIndexes_call(req, resultHandler814, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listFTIndexes_call extends TAsyncMethodCall {
      private ListFTIndexesReq req;
      public listFTIndexes_call(ListFTIndexesReq req, AsyncMethodCallback resultHandler815, TAsyncClient client811, TProtocolFactory protocolFactory812, TNonblockingTransport transport813) throws TException {
        super(client811, protocolFactory812, transport813, resultHandler815, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listFTIndexes", TMessageType.CALL, 0));
        listFTIndexes_args args = new listFTIndexes_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListFTIndexesResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listFTIndexes();
      }
    }

    public void createSession(CreateSessionReq req, AsyncMethodCallback resultHandler819) throws TException {
      checkReady();
      createSession_call method_call = new createSession_call(req, resultHandler819, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createSession_call extends TAsyncMethodCall {
      private CreateSessionReq req;
      public createSession_call(CreateSessionReq req, AsyncMethodCallback resultHandler820, TAsyncClient client816, TProtocolFactory protocolFactory817, TNonblockingTransport transport818) throws TException {
        super(client816, protocolFactory817, transport818, resultHandler820, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createSession", TMessageType.CALL, 0));
        createSession_args args = new createSession_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public CreateSessionResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createSession();
      }
    }

    public void updateSessions(UpdateSessionsReq req, AsyncMethodCallback resultHandler824) throws TException {
      checkReady();
      updateSessions_call method_call = new updateSessions_call(req, resultHandler824, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class updateSessions_call extends TAsyncMethodCall {
      private UpdateSessionsReq req;
      public updateSessions_call(UpdateSessionsReq req, AsyncMethodCallback resultHandler825, TAsyncClient client821, TProtocolFactory protocolFactory822, TNonblockingTransport transport823) throws TException {
        super(client821, protocolFactory822, transport823, resultHandler825, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("updateSessions", TMessageType.CALL, 0));
        updateSessions_args args = new updateSessions_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public UpdateSessionsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_updateSessions();
      }
    }

    public void listSessions(ListSessionsReq req, AsyncMethodCallback resultHandler829) throws TException {
      checkReady();
      listSessions_call method_call = new listSessions_call(req, resultHandler829, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listSessions_call extends TAsyncMethodCall {
      private ListSessionsReq req;
      public listSessions_call(ListSessionsReq req, AsyncMethodCallback resultHandler830, TAsyncClient client826, TProtocolFactory protocolFactory827, TNonblockingTransport transport828) throws TException {
        super(client826, protocolFactory827, transport828, resultHandler830, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listSessions", TMessageType.CALL, 0));
        listSessions_args args = new listSessions_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListSessionsResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listSessions();
      }
    }

    public void getSession(GetSessionReq req, AsyncMethodCallback resultHandler834) throws TException {
      checkReady();
      getSession_call method_call = new getSession_call(req, resultHandler834, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getSession_call extends TAsyncMethodCall {
      private GetSessionReq req;
      public getSession_call(GetSessionReq req, AsyncMethodCallback resultHandler835, TAsyncClient client831, TProtocolFactory protocolFactory832, TNonblockingTransport transport833) throws TException {
        super(client831, protocolFactory832, transport833, resultHandler835, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getSession", TMessageType.CALL, 0));
        getSession_args args = new getSession_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetSessionResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getSession();
      }
    }

    public void removeSession(RemoveSessionReq req, AsyncMethodCallback resultHandler839) throws TException {
      checkReady();
      removeSession_call method_call = new removeSession_call(req, resultHandler839, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class removeSession_call extends TAsyncMethodCall {
      private RemoveSessionReq req;
      public removeSession_call(RemoveSessionReq req, AsyncMethodCallback resultHandler840, TAsyncClient client836, TProtocolFactory protocolFactory837, TNonblockingTransport transport838) throws TException {
        super(client836, protocolFactory837, transport838, resultHandler840, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("removeSession", TMessageType.CALL, 0));
        removeSession_args args = new removeSession_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_removeSession();
      }
    }

    public void killQuery(KillQueryReq req, AsyncMethodCallback resultHandler844) throws TException {
      checkReady();
      killQuery_call method_call = new killQuery_call(req, resultHandler844, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class killQuery_call extends TAsyncMethodCall {
      private KillQueryReq req;
      public killQuery_call(KillQueryReq req, AsyncMethodCallback resultHandler845, TAsyncClient client841, TProtocolFactory protocolFactory842, TNonblockingTransport transport843) throws TException {
        super(client841, protocolFactory842, transport843, resultHandler845, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("killQuery", TMessageType.CALL, 0));
        killQuery_args args = new killQuery_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_killQuery();
      }
    }

    public void reportTaskFinish(ReportTaskReq req, AsyncMethodCallback resultHandler849) throws TException {
      checkReady();
      reportTaskFinish_call method_call = new reportTaskFinish_call(req, resultHandler849, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class reportTaskFinish_call extends TAsyncMethodCall {
      private ReportTaskReq req;
      public reportTaskFinish_call(ReportTaskReq req, AsyncMethodCallback resultHandler850, TAsyncClient client846, TProtocolFactory protocolFactory847, TNonblockingTransport transport848) throws TException {
        super(client846, protocolFactory847, transport848, resultHandler850, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("reportTaskFinish", TMessageType.CALL, 0));
        reportTaskFinish_args args = new reportTaskFinish_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ExecResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_reportTaskFinish();
      }
    }

    public void listCluster(ListClusterInfoReq req, AsyncMethodCallback resultHandler854) throws TException {
      checkReady();
      listCluster_call method_call = new listCluster_call(req, resultHandler854, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class listCluster_call extends TAsyncMethodCall {
      private ListClusterInfoReq req;
      public listCluster_call(ListClusterInfoReq req, AsyncMethodCallback resultHandler855, TAsyncClient client851, TProtocolFactory protocolFactory852, TNonblockingTransport transport853) throws TException {
        super(client851, protocolFactory852, transport853, resultHandler855, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("listCluster", TMessageType.CALL, 0));
        listCluster_args args = new listCluster_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ListClusterInfoResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_listCluster();
      }
    }

    public void getMetaDirInfo(GetMetaDirInfoReq req, AsyncMethodCallback resultHandler859) throws TException {
      checkReady();
      getMetaDirInfo_call method_call = new getMetaDirInfo_call(req, resultHandler859, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class getMetaDirInfo_call extends TAsyncMethodCall {
      private GetMetaDirInfoReq req;
      public getMetaDirInfo_call(GetMetaDirInfoReq req, AsyncMethodCallback resultHandler860, TAsyncClient client856, TProtocolFactory protocolFactory857, TNonblockingTransport transport858) throws TException {
        super(client856, protocolFactory857, transport858, resultHandler860, false);
        this.req = req;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getMetaDirInfo", TMessageType.CALL, 0));
        getMetaDirInfo_args args = new getMetaDirInfo_args();
        args.setReq(req);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public GetMetaDirInfoResp getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = super.client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getMetaDirInfo();
      }
    }

  }

  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      event_handler_ = new TProcessorEventHandler(); // Empty handler
      processMap_.put("createSpace", new createSpace());
      processMap_.put("dropSpace", new dropSpace());
      processMap_.put("getSpace", new getSpace());
      processMap_.put("listSpaces", new listSpaces());
      processMap_.put("createTag", new createTag());
      processMap_.put("alterTag", new alterTag());
      processMap_.put("dropTag", new dropTag());
      processMap_.put("getTag", new getTag());
      processMap_.put("listTags", new listTags());
      processMap_.put("createEdge", new createEdge());
      processMap_.put("alterEdge", new alterEdge());
      processMap_.put("dropEdge", new dropEdge());
      processMap_.put("getEdge", new getEdge());
      processMap_.put("listEdges", new listEdges());
      processMap_.put("listHosts", new listHosts());
      processMap_.put("getPartsAlloc", new getPartsAlloc());
      processMap_.put("listParts", new listParts());
      processMap_.put("multiPut", new multiPut());
      processMap_.put("get", new get());
      processMap_.put("multiGet", new multiGet());
      processMap_.put("remove", new remove());
      processMap_.put("removeRange", new removeRange());
      processMap_.put("scan", new scan());
      processMap_.put("createTagIndex", new createTagIndex());
      processMap_.put("dropTagIndex", new dropTagIndex());
      processMap_.put("getTagIndex", new getTagIndex());
      processMap_.put("listTagIndexes", new listTagIndexes());
      processMap_.put("rebuildTagIndex", new rebuildTagIndex());
      processMap_.put("listTagIndexStatus", new listTagIndexStatus());
      processMap_.put("createEdgeIndex", new createEdgeIndex());
      processMap_.put("dropEdgeIndex", new dropEdgeIndex());
      processMap_.put("getEdgeIndex", new getEdgeIndex());
      processMap_.put("listEdgeIndexes", new listEdgeIndexes());
      processMap_.put("rebuildEdgeIndex", new rebuildEdgeIndex());
      processMap_.put("listEdgeIndexStatus", new listEdgeIndexStatus());
      processMap_.put("createUser", new createUser());
      processMap_.put("dropUser", new dropUser());
      processMap_.put("alterUser", new alterUser());
      processMap_.put("grantRole", new grantRole());
      processMap_.put("revokeRole", new revokeRole());
      processMap_.put("listUsers", new listUsers());
      processMap_.put("listRoles", new listRoles());
      processMap_.put("getUserRoles", new getUserRoles());
      processMap_.put("changePassword", new changePassword());
      processMap_.put("heartBeat", new heartBeat());
      processMap_.put("balance", new balance());
      processMap_.put("leaderBalance", new leaderBalance());
      processMap_.put("regConfig", new regConfig());
      processMap_.put("getConfig", new getConfig());
      processMap_.put("setConfig", new setConfig());
      processMap_.put("listConfigs", new listConfigs());
      processMap_.put("createSnapshot", new createSnapshot());
      processMap_.put("dropSnapshot", new dropSnapshot());
      processMap_.put("listSnapshots", new listSnapshots());
      processMap_.put("runAdminJob", new runAdminJob());
      processMap_.put("addZone", new addZone());
      processMap_.put("dropZone", new dropZone());
      processMap_.put("addHostIntoZone", new addHostIntoZone());
      processMap_.put("dropHostFromZone", new dropHostFromZone());
      processMap_.put("getZone", new getZone());
      processMap_.put("listZones", new listZones());
      processMap_.put("addGroup", new addGroup());
      processMap_.put("dropGroup", new dropGroup());
      processMap_.put("addZoneIntoGroup", new addZoneIntoGroup());
      processMap_.put("dropZoneFromGroup", new dropZoneFromGroup());
      processMap_.put("getGroup", new getGroup());
      processMap_.put("listGroups", new listGroups());
      processMap_.put("createBackup", new createBackup());
      processMap_.put("restoreMeta", new restoreMeta());
      processMap_.put("addListener", new addListener());
      processMap_.put("removeListener", new removeListener());
      processMap_.put("listListener", new listListener());
      processMap_.put("getStatis", new getStatis());
      processMap_.put("signInFTService", new signInFTService());
      processMap_.put("signOutFTService", new signOutFTService());
      processMap_.put("listFTClients", new listFTClients());
      processMap_.put("createFTIndex", new createFTIndex());
      processMap_.put("dropFTIndex", new dropFTIndex());
      processMap_.put("listFTIndexes", new listFTIndexes());
      processMap_.put("createSession", new createSession());
      processMap_.put("updateSessions", new updateSessions());
      processMap_.put("listSessions", new listSessions());
      processMap_.put("getSession", new getSession());
      processMap_.put("removeSession", new removeSession());
      processMap_.put("killQuery", new killQuery());
      processMap_.put("reportTaskFinish", new reportTaskFinish());
      processMap_.put("listCluster", new listCluster());
      processMap_.put("getMetaDirInfo", new getMetaDirInfo());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException;
    }

    public void setEventHandler(TProcessorEventHandler handler) {
      this.event_handler_ = handler;
    }

    private Iface iface_;
    protected TProcessorEventHandler event_handler_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot, server_ctx);
      return true;
    }

    private class createSpace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createSpace", server_ctx);
        createSpace_args args = new createSpace_args();
        event_handler_.preRead(handler_ctx, "MetaService.createSpace");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createSpace", args);
        createSpace_result result = new createSpace_result();
        result.success = iface_.createSpace(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createSpace", result);
        oprot.writeMessageBegin(new TMessage("createSpace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createSpace", result);
      }

    }

    private class dropSpace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropSpace", server_ctx);
        dropSpace_args args = new dropSpace_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropSpace");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropSpace", args);
        dropSpace_result result = new dropSpace_result();
        result.success = iface_.dropSpace(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropSpace", result);
        oprot.writeMessageBegin(new TMessage("dropSpace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropSpace", result);
      }

    }

    private class getSpace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getSpace", server_ctx);
        getSpace_args args = new getSpace_args();
        event_handler_.preRead(handler_ctx, "MetaService.getSpace");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getSpace", args);
        getSpace_result result = new getSpace_result();
        result.success = iface_.getSpace(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getSpace", result);
        oprot.writeMessageBegin(new TMessage("getSpace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getSpace", result);
      }

    }

    private class listSpaces implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listSpaces", server_ctx);
        listSpaces_args args = new listSpaces_args();
        event_handler_.preRead(handler_ctx, "MetaService.listSpaces");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listSpaces", args);
        listSpaces_result result = new listSpaces_result();
        result.success = iface_.listSpaces(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listSpaces", result);
        oprot.writeMessageBegin(new TMessage("listSpaces", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listSpaces", result);
      }

    }

    private class createTag implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createTag", server_ctx);
        createTag_args args = new createTag_args();
        event_handler_.preRead(handler_ctx, "MetaService.createTag");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createTag", args);
        createTag_result result = new createTag_result();
        result.success = iface_.createTag(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createTag", result);
        oprot.writeMessageBegin(new TMessage("createTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createTag", result);
      }

    }

    private class alterTag implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.alterTag", server_ctx);
        alterTag_args args = new alterTag_args();
        event_handler_.preRead(handler_ctx, "MetaService.alterTag");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.alterTag", args);
        alterTag_result result = new alterTag_result();
        result.success = iface_.alterTag(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.alterTag", result);
        oprot.writeMessageBegin(new TMessage("alterTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.alterTag", result);
      }

    }

    private class dropTag implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropTag", server_ctx);
        dropTag_args args = new dropTag_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropTag");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropTag", args);
        dropTag_result result = new dropTag_result();
        result.success = iface_.dropTag(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropTag", result);
        oprot.writeMessageBegin(new TMessage("dropTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropTag", result);
      }

    }

    private class getTag implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getTag", server_ctx);
        getTag_args args = new getTag_args();
        event_handler_.preRead(handler_ctx, "MetaService.getTag");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getTag", args);
        getTag_result result = new getTag_result();
        result.success = iface_.getTag(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getTag", result);
        oprot.writeMessageBegin(new TMessage("getTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getTag", result);
      }

    }

    private class listTags implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listTags", server_ctx);
        listTags_args args = new listTags_args();
        event_handler_.preRead(handler_ctx, "MetaService.listTags");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listTags", args);
        listTags_result result = new listTags_result();
        result.success = iface_.listTags(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listTags", result);
        oprot.writeMessageBegin(new TMessage("listTags", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listTags", result);
      }

    }

    private class createEdge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createEdge", server_ctx);
        createEdge_args args = new createEdge_args();
        event_handler_.preRead(handler_ctx, "MetaService.createEdge");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createEdge", args);
        createEdge_result result = new createEdge_result();
        result.success = iface_.createEdge(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createEdge", result);
        oprot.writeMessageBegin(new TMessage("createEdge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createEdge", result);
      }

    }

    private class alterEdge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.alterEdge", server_ctx);
        alterEdge_args args = new alterEdge_args();
        event_handler_.preRead(handler_ctx, "MetaService.alterEdge");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.alterEdge", args);
        alterEdge_result result = new alterEdge_result();
        result.success = iface_.alterEdge(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.alterEdge", result);
        oprot.writeMessageBegin(new TMessage("alterEdge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.alterEdge", result);
      }

    }

    private class dropEdge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropEdge", server_ctx);
        dropEdge_args args = new dropEdge_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropEdge");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropEdge", args);
        dropEdge_result result = new dropEdge_result();
        result.success = iface_.dropEdge(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropEdge", result);
        oprot.writeMessageBegin(new TMessage("dropEdge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropEdge", result);
      }

    }

    private class getEdge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getEdge", server_ctx);
        getEdge_args args = new getEdge_args();
        event_handler_.preRead(handler_ctx, "MetaService.getEdge");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getEdge", args);
        getEdge_result result = new getEdge_result();
        result.success = iface_.getEdge(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getEdge", result);
        oprot.writeMessageBegin(new TMessage("getEdge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getEdge", result);
      }

    }

    private class listEdges implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listEdges", server_ctx);
        listEdges_args args = new listEdges_args();
        event_handler_.preRead(handler_ctx, "MetaService.listEdges");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listEdges", args);
        listEdges_result result = new listEdges_result();
        result.success = iface_.listEdges(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listEdges", result);
        oprot.writeMessageBegin(new TMessage("listEdges", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listEdges", result);
      }

    }

    private class listHosts implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listHosts", server_ctx);
        listHosts_args args = new listHosts_args();
        event_handler_.preRead(handler_ctx, "MetaService.listHosts");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listHosts", args);
        listHosts_result result = new listHosts_result();
        result.success = iface_.listHosts(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listHosts", result);
        oprot.writeMessageBegin(new TMessage("listHosts", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listHosts", result);
      }

    }

    private class getPartsAlloc implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getPartsAlloc", server_ctx);
        getPartsAlloc_args args = new getPartsAlloc_args();
        event_handler_.preRead(handler_ctx, "MetaService.getPartsAlloc");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getPartsAlloc", args);
        getPartsAlloc_result result = new getPartsAlloc_result();
        result.success = iface_.getPartsAlloc(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getPartsAlloc", result);
        oprot.writeMessageBegin(new TMessage("getPartsAlloc", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getPartsAlloc", result);
      }

    }

    private class listParts implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listParts", server_ctx);
        listParts_args args = new listParts_args();
        event_handler_.preRead(handler_ctx, "MetaService.listParts");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listParts", args);
        listParts_result result = new listParts_result();
        result.success = iface_.listParts(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listParts", result);
        oprot.writeMessageBegin(new TMessage("listParts", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listParts", result);
      }

    }

    private class multiPut implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.multiPut", server_ctx);
        multiPut_args args = new multiPut_args();
        event_handler_.preRead(handler_ctx, "MetaService.multiPut");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.multiPut", args);
        multiPut_result result = new multiPut_result();
        result.success = iface_.multiPut(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.multiPut", result);
        oprot.writeMessageBegin(new TMessage("multiPut", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.multiPut", result);
      }

    }

    private class get implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.get", server_ctx);
        get_args args = new get_args();
        event_handler_.preRead(handler_ctx, "MetaService.get");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.get", args);
        get_result result = new get_result();
        result.success = iface_.get(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.get", result);
        oprot.writeMessageBegin(new TMessage("get", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.get", result);
      }

    }

    private class multiGet implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.multiGet", server_ctx);
        multiGet_args args = new multiGet_args();
        event_handler_.preRead(handler_ctx, "MetaService.multiGet");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.multiGet", args);
        multiGet_result result = new multiGet_result();
        result.success = iface_.multiGet(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.multiGet", result);
        oprot.writeMessageBegin(new TMessage("multiGet", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.multiGet", result);
      }

    }

    private class remove implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.remove", server_ctx);
        remove_args args = new remove_args();
        event_handler_.preRead(handler_ctx, "MetaService.remove");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.remove", args);
        remove_result result = new remove_result();
        result.success = iface_.remove(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.remove", result);
        oprot.writeMessageBegin(new TMessage("remove", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.remove", result);
      }

    }

    private class removeRange implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.removeRange", server_ctx);
        removeRange_args args = new removeRange_args();
        event_handler_.preRead(handler_ctx, "MetaService.removeRange");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.removeRange", args);
        removeRange_result result = new removeRange_result();
        result.success = iface_.removeRange(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.removeRange", result);
        oprot.writeMessageBegin(new TMessage("removeRange", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.removeRange", result);
      }

    }

    private class scan implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.scan", server_ctx);
        scan_args args = new scan_args();
        event_handler_.preRead(handler_ctx, "MetaService.scan");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.scan", args);
        scan_result result = new scan_result();
        result.success = iface_.scan(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.scan", result);
        oprot.writeMessageBegin(new TMessage("scan", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.scan", result);
      }

    }

    private class createTagIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createTagIndex", server_ctx);
        createTagIndex_args args = new createTagIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.createTagIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createTagIndex", args);
        createTagIndex_result result = new createTagIndex_result();
        result.success = iface_.createTagIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createTagIndex", result);
        oprot.writeMessageBegin(new TMessage("createTagIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createTagIndex", result);
      }

    }

    private class dropTagIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropTagIndex", server_ctx);
        dropTagIndex_args args = new dropTagIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropTagIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropTagIndex", args);
        dropTagIndex_result result = new dropTagIndex_result();
        result.success = iface_.dropTagIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropTagIndex", result);
        oprot.writeMessageBegin(new TMessage("dropTagIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropTagIndex", result);
      }

    }

    private class getTagIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getTagIndex", server_ctx);
        getTagIndex_args args = new getTagIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.getTagIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getTagIndex", args);
        getTagIndex_result result = new getTagIndex_result();
        result.success = iface_.getTagIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getTagIndex", result);
        oprot.writeMessageBegin(new TMessage("getTagIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getTagIndex", result);
      }

    }

    private class listTagIndexes implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listTagIndexes", server_ctx);
        listTagIndexes_args args = new listTagIndexes_args();
        event_handler_.preRead(handler_ctx, "MetaService.listTagIndexes");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listTagIndexes", args);
        listTagIndexes_result result = new listTagIndexes_result();
        result.success = iface_.listTagIndexes(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listTagIndexes", result);
        oprot.writeMessageBegin(new TMessage("listTagIndexes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listTagIndexes", result);
      }

    }

    private class rebuildTagIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.rebuildTagIndex", server_ctx);
        rebuildTagIndex_args args = new rebuildTagIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.rebuildTagIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.rebuildTagIndex", args);
        rebuildTagIndex_result result = new rebuildTagIndex_result();
        result.success = iface_.rebuildTagIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.rebuildTagIndex", result);
        oprot.writeMessageBegin(new TMessage("rebuildTagIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.rebuildTagIndex", result);
      }

    }

    private class listTagIndexStatus implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listTagIndexStatus", server_ctx);
        listTagIndexStatus_args args = new listTagIndexStatus_args();
        event_handler_.preRead(handler_ctx, "MetaService.listTagIndexStatus");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listTagIndexStatus", args);
        listTagIndexStatus_result result = new listTagIndexStatus_result();
        result.success = iface_.listTagIndexStatus(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listTagIndexStatus", result);
        oprot.writeMessageBegin(new TMessage("listTagIndexStatus", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listTagIndexStatus", result);
      }

    }

    private class createEdgeIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createEdgeIndex", server_ctx);
        createEdgeIndex_args args = new createEdgeIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.createEdgeIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createEdgeIndex", args);
        createEdgeIndex_result result = new createEdgeIndex_result();
        result.success = iface_.createEdgeIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createEdgeIndex", result);
        oprot.writeMessageBegin(new TMessage("createEdgeIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createEdgeIndex", result);
      }

    }

    private class dropEdgeIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropEdgeIndex", server_ctx);
        dropEdgeIndex_args args = new dropEdgeIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropEdgeIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropEdgeIndex", args);
        dropEdgeIndex_result result = new dropEdgeIndex_result();
        result.success = iface_.dropEdgeIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropEdgeIndex", result);
        oprot.writeMessageBegin(new TMessage("dropEdgeIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropEdgeIndex", result);
      }

    }

    private class getEdgeIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getEdgeIndex", server_ctx);
        getEdgeIndex_args args = new getEdgeIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.getEdgeIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getEdgeIndex", args);
        getEdgeIndex_result result = new getEdgeIndex_result();
        result.success = iface_.getEdgeIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getEdgeIndex", result);
        oprot.writeMessageBegin(new TMessage("getEdgeIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getEdgeIndex", result);
      }

    }

    private class listEdgeIndexes implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listEdgeIndexes", server_ctx);
        listEdgeIndexes_args args = new listEdgeIndexes_args();
        event_handler_.preRead(handler_ctx, "MetaService.listEdgeIndexes");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listEdgeIndexes", args);
        listEdgeIndexes_result result = new listEdgeIndexes_result();
        result.success = iface_.listEdgeIndexes(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listEdgeIndexes", result);
        oprot.writeMessageBegin(new TMessage("listEdgeIndexes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listEdgeIndexes", result);
      }

    }

    private class rebuildEdgeIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.rebuildEdgeIndex", server_ctx);
        rebuildEdgeIndex_args args = new rebuildEdgeIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.rebuildEdgeIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.rebuildEdgeIndex", args);
        rebuildEdgeIndex_result result = new rebuildEdgeIndex_result();
        result.success = iface_.rebuildEdgeIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.rebuildEdgeIndex", result);
        oprot.writeMessageBegin(new TMessage("rebuildEdgeIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.rebuildEdgeIndex", result);
      }

    }

    private class listEdgeIndexStatus implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listEdgeIndexStatus", server_ctx);
        listEdgeIndexStatus_args args = new listEdgeIndexStatus_args();
        event_handler_.preRead(handler_ctx, "MetaService.listEdgeIndexStatus");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listEdgeIndexStatus", args);
        listEdgeIndexStatus_result result = new listEdgeIndexStatus_result();
        result.success = iface_.listEdgeIndexStatus(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listEdgeIndexStatus", result);
        oprot.writeMessageBegin(new TMessage("listEdgeIndexStatus", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listEdgeIndexStatus", result);
      }

    }

    private class createUser implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createUser", server_ctx);
        createUser_args args = new createUser_args();
        event_handler_.preRead(handler_ctx, "MetaService.createUser");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createUser", args);
        createUser_result result = new createUser_result();
        result.success = iface_.createUser(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createUser", result);
        oprot.writeMessageBegin(new TMessage("createUser", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createUser", result);
      }

    }

    private class dropUser implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropUser", server_ctx);
        dropUser_args args = new dropUser_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropUser");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropUser", args);
        dropUser_result result = new dropUser_result();
        result.success = iface_.dropUser(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropUser", result);
        oprot.writeMessageBegin(new TMessage("dropUser", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropUser", result);
      }

    }

    private class alterUser implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.alterUser", server_ctx);
        alterUser_args args = new alterUser_args();
        event_handler_.preRead(handler_ctx, "MetaService.alterUser");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.alterUser", args);
        alterUser_result result = new alterUser_result();
        result.success = iface_.alterUser(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.alterUser", result);
        oprot.writeMessageBegin(new TMessage("alterUser", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.alterUser", result);
      }

    }

    private class grantRole implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.grantRole", server_ctx);
        grantRole_args args = new grantRole_args();
        event_handler_.preRead(handler_ctx, "MetaService.grantRole");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.grantRole", args);
        grantRole_result result = new grantRole_result();
        result.success = iface_.grantRole(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.grantRole", result);
        oprot.writeMessageBegin(new TMessage("grantRole", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.grantRole", result);
      }

    }

    private class revokeRole implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.revokeRole", server_ctx);
        revokeRole_args args = new revokeRole_args();
        event_handler_.preRead(handler_ctx, "MetaService.revokeRole");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.revokeRole", args);
        revokeRole_result result = new revokeRole_result();
        result.success = iface_.revokeRole(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.revokeRole", result);
        oprot.writeMessageBegin(new TMessage("revokeRole", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.revokeRole", result);
      }

    }

    private class listUsers implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listUsers", server_ctx);
        listUsers_args args = new listUsers_args();
        event_handler_.preRead(handler_ctx, "MetaService.listUsers");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listUsers", args);
        listUsers_result result = new listUsers_result();
        result.success = iface_.listUsers(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listUsers", result);
        oprot.writeMessageBegin(new TMessage("listUsers", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listUsers", result);
      }

    }

    private class listRoles implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listRoles", server_ctx);
        listRoles_args args = new listRoles_args();
        event_handler_.preRead(handler_ctx, "MetaService.listRoles");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listRoles", args);
        listRoles_result result = new listRoles_result();
        result.success = iface_.listRoles(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listRoles", result);
        oprot.writeMessageBegin(new TMessage("listRoles", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listRoles", result);
      }

    }

    private class getUserRoles implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getUserRoles", server_ctx);
        getUserRoles_args args = new getUserRoles_args();
        event_handler_.preRead(handler_ctx, "MetaService.getUserRoles");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getUserRoles", args);
        getUserRoles_result result = new getUserRoles_result();
        result.success = iface_.getUserRoles(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getUserRoles", result);
        oprot.writeMessageBegin(new TMessage("getUserRoles", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getUserRoles", result);
      }

    }

    private class changePassword implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.changePassword", server_ctx);
        changePassword_args args = new changePassword_args();
        event_handler_.preRead(handler_ctx, "MetaService.changePassword");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.changePassword", args);
        changePassword_result result = new changePassword_result();
        result.success = iface_.changePassword(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.changePassword", result);
        oprot.writeMessageBegin(new TMessage("changePassword", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.changePassword", result);
      }

    }

    private class heartBeat implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.heartBeat", server_ctx);
        heartBeat_args args = new heartBeat_args();
        event_handler_.preRead(handler_ctx, "MetaService.heartBeat");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.heartBeat", args);
        heartBeat_result result = new heartBeat_result();
        result.success = iface_.heartBeat(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.heartBeat", result);
        oprot.writeMessageBegin(new TMessage("heartBeat", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.heartBeat", result);
      }

    }

    private class balance implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.balance", server_ctx);
        balance_args args = new balance_args();
        event_handler_.preRead(handler_ctx, "MetaService.balance");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.balance", args);
        balance_result result = new balance_result();
        result.success = iface_.balance(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.balance", result);
        oprot.writeMessageBegin(new TMessage("balance", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.balance", result);
      }

    }

    private class leaderBalance implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.leaderBalance", server_ctx);
        leaderBalance_args args = new leaderBalance_args();
        event_handler_.preRead(handler_ctx, "MetaService.leaderBalance");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.leaderBalance", args);
        leaderBalance_result result = new leaderBalance_result();
        result.success = iface_.leaderBalance(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.leaderBalance", result);
        oprot.writeMessageBegin(new TMessage("leaderBalance", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.leaderBalance", result);
      }

    }

    private class regConfig implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.regConfig", server_ctx);
        regConfig_args args = new regConfig_args();
        event_handler_.preRead(handler_ctx, "MetaService.regConfig");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.regConfig", args);
        regConfig_result result = new regConfig_result();
        result.success = iface_.regConfig(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.regConfig", result);
        oprot.writeMessageBegin(new TMessage("regConfig", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.regConfig", result);
      }

    }

    private class getConfig implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getConfig", server_ctx);
        getConfig_args args = new getConfig_args();
        event_handler_.preRead(handler_ctx, "MetaService.getConfig");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getConfig", args);
        getConfig_result result = new getConfig_result();
        result.success = iface_.getConfig(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getConfig", result);
        oprot.writeMessageBegin(new TMessage("getConfig", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getConfig", result);
      }

    }

    private class setConfig implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.setConfig", server_ctx);
        setConfig_args args = new setConfig_args();
        event_handler_.preRead(handler_ctx, "MetaService.setConfig");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.setConfig", args);
        setConfig_result result = new setConfig_result();
        result.success = iface_.setConfig(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.setConfig", result);
        oprot.writeMessageBegin(new TMessage("setConfig", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.setConfig", result);
      }

    }

    private class listConfigs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listConfigs", server_ctx);
        listConfigs_args args = new listConfigs_args();
        event_handler_.preRead(handler_ctx, "MetaService.listConfigs");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listConfigs", args);
        listConfigs_result result = new listConfigs_result();
        result.success = iface_.listConfigs(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listConfigs", result);
        oprot.writeMessageBegin(new TMessage("listConfigs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listConfigs", result);
      }

    }

    private class createSnapshot implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createSnapshot", server_ctx);
        createSnapshot_args args = new createSnapshot_args();
        event_handler_.preRead(handler_ctx, "MetaService.createSnapshot");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createSnapshot", args);
        createSnapshot_result result = new createSnapshot_result();
        result.success = iface_.createSnapshot(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createSnapshot", result);
        oprot.writeMessageBegin(new TMessage("createSnapshot", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createSnapshot", result);
      }

    }

    private class dropSnapshot implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropSnapshot", server_ctx);
        dropSnapshot_args args = new dropSnapshot_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropSnapshot");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropSnapshot", args);
        dropSnapshot_result result = new dropSnapshot_result();
        result.success = iface_.dropSnapshot(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropSnapshot", result);
        oprot.writeMessageBegin(new TMessage("dropSnapshot", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropSnapshot", result);
      }

    }

    private class listSnapshots implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listSnapshots", server_ctx);
        listSnapshots_args args = new listSnapshots_args();
        event_handler_.preRead(handler_ctx, "MetaService.listSnapshots");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listSnapshots", args);
        listSnapshots_result result = new listSnapshots_result();
        result.success = iface_.listSnapshots(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listSnapshots", result);
        oprot.writeMessageBegin(new TMessage("listSnapshots", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listSnapshots", result);
      }

    }

    private class runAdminJob implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.runAdminJob", server_ctx);
        runAdminJob_args args = new runAdminJob_args();
        event_handler_.preRead(handler_ctx, "MetaService.runAdminJob");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.runAdminJob", args);
        runAdminJob_result result = new runAdminJob_result();
        result.success = iface_.runAdminJob(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.runAdminJob", result);
        oprot.writeMessageBegin(new TMessage("runAdminJob", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.runAdminJob", result);
      }

    }

    private class addZone implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.addZone", server_ctx);
        addZone_args args = new addZone_args();
        event_handler_.preRead(handler_ctx, "MetaService.addZone");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.addZone", args);
        addZone_result result = new addZone_result();
        result.success = iface_.addZone(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.addZone", result);
        oprot.writeMessageBegin(new TMessage("addZone", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.addZone", result);
      }

    }

    private class dropZone implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropZone", server_ctx);
        dropZone_args args = new dropZone_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropZone");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropZone", args);
        dropZone_result result = new dropZone_result();
        result.success = iface_.dropZone(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropZone", result);
        oprot.writeMessageBegin(new TMessage("dropZone", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropZone", result);
      }

    }

    private class addHostIntoZone implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.addHostIntoZone", server_ctx);
        addHostIntoZone_args args = new addHostIntoZone_args();
        event_handler_.preRead(handler_ctx, "MetaService.addHostIntoZone");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.addHostIntoZone", args);
        addHostIntoZone_result result = new addHostIntoZone_result();
        result.success = iface_.addHostIntoZone(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.addHostIntoZone", result);
        oprot.writeMessageBegin(new TMessage("addHostIntoZone", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.addHostIntoZone", result);
      }

    }

    private class dropHostFromZone implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropHostFromZone", server_ctx);
        dropHostFromZone_args args = new dropHostFromZone_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropHostFromZone");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropHostFromZone", args);
        dropHostFromZone_result result = new dropHostFromZone_result();
        result.success = iface_.dropHostFromZone(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropHostFromZone", result);
        oprot.writeMessageBegin(new TMessage("dropHostFromZone", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropHostFromZone", result);
      }

    }

    private class getZone implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getZone", server_ctx);
        getZone_args args = new getZone_args();
        event_handler_.preRead(handler_ctx, "MetaService.getZone");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getZone", args);
        getZone_result result = new getZone_result();
        result.success = iface_.getZone(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getZone", result);
        oprot.writeMessageBegin(new TMessage("getZone", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getZone", result);
      }

    }

    private class listZones implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listZones", server_ctx);
        listZones_args args = new listZones_args();
        event_handler_.preRead(handler_ctx, "MetaService.listZones");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listZones", args);
        listZones_result result = new listZones_result();
        result.success = iface_.listZones(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listZones", result);
        oprot.writeMessageBegin(new TMessage("listZones", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listZones", result);
      }

    }

    private class addGroup implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.addGroup", server_ctx);
        addGroup_args args = new addGroup_args();
        event_handler_.preRead(handler_ctx, "MetaService.addGroup");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.addGroup", args);
        addGroup_result result = new addGroup_result();
        result.success = iface_.addGroup(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.addGroup", result);
        oprot.writeMessageBegin(new TMessage("addGroup", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.addGroup", result);
      }

    }

    private class dropGroup implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropGroup", server_ctx);
        dropGroup_args args = new dropGroup_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropGroup");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropGroup", args);
        dropGroup_result result = new dropGroup_result();
        result.success = iface_.dropGroup(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropGroup", result);
        oprot.writeMessageBegin(new TMessage("dropGroup", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropGroup", result);
      }

    }

    private class addZoneIntoGroup implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.addZoneIntoGroup", server_ctx);
        addZoneIntoGroup_args args = new addZoneIntoGroup_args();
        event_handler_.preRead(handler_ctx, "MetaService.addZoneIntoGroup");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.addZoneIntoGroup", args);
        addZoneIntoGroup_result result = new addZoneIntoGroup_result();
        result.success = iface_.addZoneIntoGroup(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.addZoneIntoGroup", result);
        oprot.writeMessageBegin(new TMessage("addZoneIntoGroup", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.addZoneIntoGroup", result);
      }

    }

    private class dropZoneFromGroup implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropZoneFromGroup", server_ctx);
        dropZoneFromGroup_args args = new dropZoneFromGroup_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropZoneFromGroup");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropZoneFromGroup", args);
        dropZoneFromGroup_result result = new dropZoneFromGroup_result();
        result.success = iface_.dropZoneFromGroup(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropZoneFromGroup", result);
        oprot.writeMessageBegin(new TMessage("dropZoneFromGroup", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropZoneFromGroup", result);
      }

    }

    private class getGroup implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getGroup", server_ctx);
        getGroup_args args = new getGroup_args();
        event_handler_.preRead(handler_ctx, "MetaService.getGroup");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getGroup", args);
        getGroup_result result = new getGroup_result();
        result.success = iface_.getGroup(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getGroup", result);
        oprot.writeMessageBegin(new TMessage("getGroup", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getGroup", result);
      }

    }

    private class listGroups implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listGroups", server_ctx);
        listGroups_args args = new listGroups_args();
        event_handler_.preRead(handler_ctx, "MetaService.listGroups");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listGroups", args);
        listGroups_result result = new listGroups_result();
        result.success = iface_.listGroups(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listGroups", result);
        oprot.writeMessageBegin(new TMessage("listGroups", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listGroups", result);
      }

    }

    private class createBackup implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createBackup", server_ctx);
        createBackup_args args = new createBackup_args();
        event_handler_.preRead(handler_ctx, "MetaService.createBackup");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createBackup", args);
        createBackup_result result = new createBackup_result();
        result.success = iface_.createBackup(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createBackup", result);
        oprot.writeMessageBegin(new TMessage("createBackup", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createBackup", result);
      }

    }

    private class restoreMeta implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.restoreMeta", server_ctx);
        restoreMeta_args args = new restoreMeta_args();
        event_handler_.preRead(handler_ctx, "MetaService.restoreMeta");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.restoreMeta", args);
        restoreMeta_result result = new restoreMeta_result();
        result.success = iface_.restoreMeta(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.restoreMeta", result);
        oprot.writeMessageBegin(new TMessage("restoreMeta", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.restoreMeta", result);
      }

    }

    private class addListener implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.addListener", server_ctx);
        addListener_args args = new addListener_args();
        event_handler_.preRead(handler_ctx, "MetaService.addListener");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.addListener", args);
        addListener_result result = new addListener_result();
        result.success = iface_.addListener(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.addListener", result);
        oprot.writeMessageBegin(new TMessage("addListener", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.addListener", result);
      }

    }

    private class removeListener implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.removeListener", server_ctx);
        removeListener_args args = new removeListener_args();
        event_handler_.preRead(handler_ctx, "MetaService.removeListener");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.removeListener", args);
        removeListener_result result = new removeListener_result();
        result.success = iface_.removeListener(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.removeListener", result);
        oprot.writeMessageBegin(new TMessage("removeListener", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.removeListener", result);
      }

    }

    private class listListener implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listListener", server_ctx);
        listListener_args args = new listListener_args();
        event_handler_.preRead(handler_ctx, "MetaService.listListener");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listListener", args);
        listListener_result result = new listListener_result();
        result.success = iface_.listListener(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listListener", result);
        oprot.writeMessageBegin(new TMessage("listListener", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listListener", result);
      }

    }

    private class getStatis implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getStatis", server_ctx);
        getStatis_args args = new getStatis_args();
        event_handler_.preRead(handler_ctx, "MetaService.getStatis");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getStatis", args);
        getStatis_result result = new getStatis_result();
        result.success = iface_.getStatis(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getStatis", result);
        oprot.writeMessageBegin(new TMessage("getStatis", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getStatis", result);
      }

    }

    private class signInFTService implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.signInFTService", server_ctx);
        signInFTService_args args = new signInFTService_args();
        event_handler_.preRead(handler_ctx, "MetaService.signInFTService");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.signInFTService", args);
        signInFTService_result result = new signInFTService_result();
        result.success = iface_.signInFTService(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.signInFTService", result);
        oprot.writeMessageBegin(new TMessage("signInFTService", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.signInFTService", result);
      }

    }

    private class signOutFTService implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.signOutFTService", server_ctx);
        signOutFTService_args args = new signOutFTService_args();
        event_handler_.preRead(handler_ctx, "MetaService.signOutFTService");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.signOutFTService", args);
        signOutFTService_result result = new signOutFTService_result();
        result.success = iface_.signOutFTService(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.signOutFTService", result);
        oprot.writeMessageBegin(new TMessage("signOutFTService", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.signOutFTService", result);
      }

    }

    private class listFTClients implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listFTClients", server_ctx);
        listFTClients_args args = new listFTClients_args();
        event_handler_.preRead(handler_ctx, "MetaService.listFTClients");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listFTClients", args);
        listFTClients_result result = new listFTClients_result();
        result.success = iface_.listFTClients(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listFTClients", result);
        oprot.writeMessageBegin(new TMessage("listFTClients", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listFTClients", result);
      }

    }

    private class createFTIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createFTIndex", server_ctx);
        createFTIndex_args args = new createFTIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.createFTIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createFTIndex", args);
        createFTIndex_result result = new createFTIndex_result();
        result.success = iface_.createFTIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createFTIndex", result);
        oprot.writeMessageBegin(new TMessage("createFTIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createFTIndex", result);
      }

    }

    private class dropFTIndex implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.dropFTIndex", server_ctx);
        dropFTIndex_args args = new dropFTIndex_args();
        event_handler_.preRead(handler_ctx, "MetaService.dropFTIndex");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.dropFTIndex", args);
        dropFTIndex_result result = new dropFTIndex_result();
        result.success = iface_.dropFTIndex(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.dropFTIndex", result);
        oprot.writeMessageBegin(new TMessage("dropFTIndex", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.dropFTIndex", result);
      }

    }

    private class listFTIndexes implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listFTIndexes", server_ctx);
        listFTIndexes_args args = new listFTIndexes_args();
        event_handler_.preRead(handler_ctx, "MetaService.listFTIndexes");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listFTIndexes", args);
        listFTIndexes_result result = new listFTIndexes_result();
        result.success = iface_.listFTIndexes(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listFTIndexes", result);
        oprot.writeMessageBegin(new TMessage("listFTIndexes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listFTIndexes", result);
      }

    }

    private class createSession implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.createSession", server_ctx);
        createSession_args args = new createSession_args();
        event_handler_.preRead(handler_ctx, "MetaService.createSession");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.createSession", args);
        createSession_result result = new createSession_result();
        result.success = iface_.createSession(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.createSession", result);
        oprot.writeMessageBegin(new TMessage("createSession", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.createSession", result);
      }

    }

    private class updateSessions implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.updateSessions", server_ctx);
        updateSessions_args args = new updateSessions_args();
        event_handler_.preRead(handler_ctx, "MetaService.updateSessions");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.updateSessions", args);
        updateSessions_result result = new updateSessions_result();
        result.success = iface_.updateSessions(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.updateSessions", result);
        oprot.writeMessageBegin(new TMessage("updateSessions", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.updateSessions", result);
      }

    }

    private class listSessions implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listSessions", server_ctx);
        listSessions_args args = new listSessions_args();
        event_handler_.preRead(handler_ctx, "MetaService.listSessions");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listSessions", args);
        listSessions_result result = new listSessions_result();
        result.success = iface_.listSessions(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listSessions", result);
        oprot.writeMessageBegin(new TMessage("listSessions", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listSessions", result);
      }

    }

    private class getSession implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getSession", server_ctx);
        getSession_args args = new getSession_args();
        event_handler_.preRead(handler_ctx, "MetaService.getSession");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getSession", args);
        getSession_result result = new getSession_result();
        result.success = iface_.getSession(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getSession", result);
        oprot.writeMessageBegin(new TMessage("getSession", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getSession", result);
      }

    }

    private class removeSession implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.removeSession", server_ctx);
        removeSession_args args = new removeSession_args();
        event_handler_.preRead(handler_ctx, "MetaService.removeSession");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.removeSession", args);
        removeSession_result result = new removeSession_result();
        result.success = iface_.removeSession(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.removeSession", result);
        oprot.writeMessageBegin(new TMessage("removeSession", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.removeSession", result);
      }

    }

    private class killQuery implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.killQuery", server_ctx);
        killQuery_args args = new killQuery_args();
        event_handler_.preRead(handler_ctx, "MetaService.killQuery");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.killQuery", args);
        killQuery_result result = new killQuery_result();
        result.success = iface_.killQuery(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.killQuery", result);
        oprot.writeMessageBegin(new TMessage("killQuery", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.killQuery", result);
      }

    }

    private class reportTaskFinish implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.reportTaskFinish", server_ctx);
        reportTaskFinish_args args = new reportTaskFinish_args();
        event_handler_.preRead(handler_ctx, "MetaService.reportTaskFinish");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.reportTaskFinish", args);
        reportTaskFinish_result result = new reportTaskFinish_result();
        result.success = iface_.reportTaskFinish(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.reportTaskFinish", result);
        oprot.writeMessageBegin(new TMessage("reportTaskFinish", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.reportTaskFinish", result);
      }

    }

    private class listCluster implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.listCluster", server_ctx);
        listCluster_args args = new listCluster_args();
        event_handler_.preRead(handler_ctx, "MetaService.listCluster");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.listCluster", args);
        listCluster_result result = new listCluster_result();
        result.success = iface_.listCluster(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.listCluster", result);
        oprot.writeMessageBegin(new TMessage("listCluster", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.listCluster", result);
      }

    }

    private class getMetaDirInfo implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot, TConnectionContext server_ctx) throws TException
      {
        Object handler_ctx = event_handler_.getContext("MetaService.getMetaDirInfo", server_ctx);
        getMetaDirInfo_args args = new getMetaDirInfo_args();
        event_handler_.preRead(handler_ctx, "MetaService.getMetaDirInfo");
        args.read(iprot);
        iprot.readMessageEnd();
        event_handler_.postRead(handler_ctx, "MetaService.getMetaDirInfo", args);
        getMetaDirInfo_result result = new getMetaDirInfo_result();
        result.success = iface_.getMetaDirInfo(args.req);
        event_handler_.preWrite(handler_ctx, "MetaService.getMetaDirInfo", result);
        oprot.writeMessageBegin(new TMessage("getMetaDirInfo", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        event_handler_.postWrite(handler_ctx, "MetaService.getMetaDirInfo", result);
      }

    }

  }

  public static class createSpace_args implements TBase, java.io.Serializable, Cloneable, Comparable<createSpace_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSpace_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateSpaceReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateSpaceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSpace_args.class, metaDataMap);
    }

    public createSpace_args() {
    }

    public createSpace_args(
        CreateSpaceReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSpace_args(createSpace_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createSpace_args deepCopy() {
      return new createSpace_args(this);
    }

    public CreateSpaceReq getReq() {
      return this.req;
    }

    public createSpace_args setReq(CreateSpaceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateSpaceReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createSpace_args))
        return false;
      createSpace_args that = (createSpace_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createSpace_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateSpaceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSpace_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createSpace_result implements TBase, java.io.Serializable, Cloneable, Comparable<createSpace_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSpace_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSpace_result.class, metaDataMap);
    }

    public createSpace_result() {
    }

    public createSpace_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSpace_result(createSpace_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createSpace_result deepCopy() {
      return new createSpace_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public createSpace_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createSpace_result))
        return false;
      createSpace_result that = (createSpace_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createSpace_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSpace_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropSpace_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropSpace_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropSpace_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropSpaceReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropSpaceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropSpace_args.class, metaDataMap);
    }

    public dropSpace_args() {
    }

    public dropSpace_args(
        DropSpaceReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropSpace_args(dropSpace_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropSpace_args deepCopy() {
      return new dropSpace_args(this);
    }

    public DropSpaceReq getReq() {
      return this.req;
    }

    public dropSpace_args setReq(DropSpaceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropSpaceReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropSpace_args))
        return false;
      dropSpace_args that = (dropSpace_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropSpace_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropSpaceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropSpace_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropSpace_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropSpace_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropSpace_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropSpace_result.class, metaDataMap);
    }

    public dropSpace_result() {
    }

    public dropSpace_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropSpace_result(dropSpace_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropSpace_result deepCopy() {
      return new dropSpace_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropSpace_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropSpace_result))
        return false;
      dropSpace_result that = (dropSpace_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropSpace_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropSpace_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getSpace_args implements TBase, java.io.Serializable, Cloneable, Comparable<getSpace_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getSpace_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetSpaceReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetSpaceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getSpace_args.class, metaDataMap);
    }

    public getSpace_args() {
    }

    public getSpace_args(
        GetSpaceReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getSpace_args(getSpace_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getSpace_args deepCopy() {
      return new getSpace_args(this);
    }

    public GetSpaceReq getReq() {
      return this.req;
    }

    public getSpace_args setReq(GetSpaceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetSpaceReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getSpace_args))
        return false;
      getSpace_args that = (getSpace_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getSpace_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetSpaceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getSpace_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getSpace_result implements TBase, java.io.Serializable, Cloneable, Comparable<getSpace_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getSpace_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetSpaceResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetSpaceResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getSpace_result.class, metaDataMap);
    }

    public getSpace_result() {
    }

    public getSpace_result(
        GetSpaceResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getSpace_result(getSpace_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getSpace_result deepCopy() {
      return new getSpace_result(this);
    }

    public GetSpaceResp getSuccess() {
      return this.success;
    }

    public getSpace_result setSuccess(GetSpaceResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetSpaceResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getSpace_result))
        return false;
      getSpace_result that = (getSpace_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getSpace_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetSpaceResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getSpace_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listSpaces_args implements TBase, java.io.Serializable, Cloneable, Comparable<listSpaces_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSpaces_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListSpacesReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSpacesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSpaces_args.class, metaDataMap);
    }

    public listSpaces_args() {
    }

    public listSpaces_args(
        ListSpacesReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSpaces_args(listSpaces_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listSpaces_args deepCopy() {
      return new listSpaces_args(this);
    }

    public ListSpacesReq getReq() {
      return this.req;
    }

    public listSpaces_args setReq(ListSpacesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListSpacesReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listSpaces_args))
        return false;
      listSpaces_args that = (listSpaces_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listSpaces_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListSpacesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSpaces_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listSpaces_result implements TBase, java.io.Serializable, Cloneable, Comparable<listSpaces_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSpaces_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListSpacesResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSpacesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSpaces_result.class, metaDataMap);
    }

    public listSpaces_result() {
    }

    public listSpaces_result(
        ListSpacesResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSpaces_result(listSpaces_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listSpaces_result deepCopy() {
      return new listSpaces_result(this);
    }

    public ListSpacesResp getSuccess() {
      return this.success;
    }

    public listSpaces_result setSuccess(ListSpacesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListSpacesResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listSpaces_result))
        return false;
      listSpaces_result that = (listSpaces_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listSpaces_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListSpacesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSpaces_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createTag_args implements TBase, java.io.Serializable, Cloneable, Comparable<createTag_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createTag_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateTagReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateTagReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createTag_args.class, metaDataMap);
    }

    public createTag_args() {
    }

    public createTag_args(
        CreateTagReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTag_args(createTag_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createTag_args deepCopy() {
      return new createTag_args(this);
    }

    public CreateTagReq getReq() {
      return this.req;
    }

    public createTag_args setReq(CreateTagReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateTagReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createTag_args))
        return false;
      createTag_args that = (createTag_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createTag_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateTagReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createTag_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createTag_result implements TBase, java.io.Serializable, Cloneable, Comparable<createTag_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createTag_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createTag_result.class, metaDataMap);
    }

    public createTag_result() {
    }

    public createTag_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTag_result(createTag_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createTag_result deepCopy() {
      return new createTag_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public createTag_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createTag_result))
        return false;
      createTag_result that = (createTag_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createTag_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createTag_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alterTag_args implements TBase, java.io.Serializable, Cloneable, Comparable<alterTag_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterTag_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AlterTagReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AlterTagReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterTag_args.class, metaDataMap);
    }

    public alterTag_args() {
    }

    public alterTag_args(
        AlterTagReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterTag_args(alterTag_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public alterTag_args deepCopy() {
      return new alterTag_args(this);
    }

    public AlterTagReq getReq() {
      return this.req;
    }

    public alterTag_args setReq(AlterTagReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AlterTagReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof alterTag_args))
        return false;
      alterTag_args that = (alterTag_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(alterTag_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AlterTagReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterTag_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alterTag_result implements TBase, java.io.Serializable, Cloneable, Comparable<alterTag_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterTag_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterTag_result.class, metaDataMap);
    }

    public alterTag_result() {
    }

    public alterTag_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterTag_result(alterTag_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public alterTag_result deepCopy() {
      return new alterTag_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public alterTag_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof alterTag_result))
        return false;
      alterTag_result that = (alterTag_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(alterTag_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterTag_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropTag_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropTag_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTag_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropTagReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropTagReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropTag_args.class, metaDataMap);
    }

    public dropTag_args() {
    }

    public dropTag_args(
        DropTagReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTag_args(dropTag_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropTag_args deepCopy() {
      return new dropTag_args(this);
    }

    public DropTagReq getReq() {
      return this.req;
    }

    public dropTag_args setReq(DropTagReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropTagReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropTag_args))
        return false;
      dropTag_args that = (dropTag_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropTag_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropTagReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropTag_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropTag_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropTag_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTag_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropTag_result.class, metaDataMap);
    }

    public dropTag_result() {
    }

    public dropTag_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTag_result(dropTag_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropTag_result deepCopy() {
      return new dropTag_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropTag_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropTag_result))
        return false;
      dropTag_result that = (dropTag_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropTag_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropTag_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTag_args implements TBase, java.io.Serializable, Cloneable, Comparable<getTag_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getTag_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetTagReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetTagReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getTag_args.class, metaDataMap);
    }

    public getTag_args() {
    }

    public getTag_args(
        GetTagReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTag_args(getTag_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getTag_args deepCopy() {
      return new getTag_args(this);
    }

    public GetTagReq getReq() {
      return this.req;
    }

    public getTag_args setReq(GetTagReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetTagReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getTag_args))
        return false;
      getTag_args that = (getTag_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getTag_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetTagReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getTag_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTag_result implements TBase, java.io.Serializable, Cloneable, Comparable<getTag_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getTag_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetTagResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetTagResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getTag_result.class, metaDataMap);
    }

    public getTag_result() {
    }

    public getTag_result(
        GetTagResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTag_result(getTag_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getTag_result deepCopy() {
      return new getTag_result(this);
    }

    public GetTagResp getSuccess() {
      return this.success;
    }

    public getTag_result setSuccess(GetTagResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetTagResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getTag_result))
        return false;
      getTag_result that = (getTag_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getTag_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetTagResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getTag_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listTags_args implements TBase, java.io.Serializable, Cloneable, Comparable<listTags_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTags_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListTagsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListTagsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTags_args.class, metaDataMap);
    }

    public listTags_args() {
    }

    public listTags_args(
        ListTagsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTags_args(listTags_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listTags_args deepCopy() {
      return new listTags_args(this);
    }

    public ListTagsReq getReq() {
      return this.req;
    }

    public listTags_args setReq(ListTagsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListTagsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listTags_args))
        return false;
      listTags_args that = (listTags_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listTags_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListTagsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTags_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listTags_result implements TBase, java.io.Serializable, Cloneable, Comparable<listTags_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTags_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListTagsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListTagsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTags_result.class, metaDataMap);
    }

    public listTags_result() {
    }

    public listTags_result(
        ListTagsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTags_result(listTags_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listTags_result deepCopy() {
      return new listTags_result(this);
    }

    public ListTagsResp getSuccess() {
      return this.success;
    }

    public listTags_result setSuccess(ListTagsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListTagsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listTags_result))
        return false;
      listTags_result that = (listTags_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listTags_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListTagsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTags_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createEdge_args implements TBase, java.io.Serializable, Cloneable, Comparable<createEdge_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createEdge_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateEdgeReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateEdgeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createEdge_args.class, metaDataMap);
    }

    public createEdge_args() {
    }

    public createEdge_args(
        CreateEdgeReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createEdge_args(createEdge_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createEdge_args deepCopy() {
      return new createEdge_args(this);
    }

    public CreateEdgeReq getReq() {
      return this.req;
    }

    public createEdge_args setReq(CreateEdgeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateEdgeReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createEdge_args))
        return false;
      createEdge_args that = (createEdge_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createEdge_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateEdgeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createEdge_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createEdge_result implements TBase, java.io.Serializable, Cloneable, Comparable<createEdge_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createEdge_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createEdge_result.class, metaDataMap);
    }

    public createEdge_result() {
    }

    public createEdge_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createEdge_result(createEdge_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createEdge_result deepCopy() {
      return new createEdge_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public createEdge_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createEdge_result))
        return false;
      createEdge_result that = (createEdge_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createEdge_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createEdge_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alterEdge_args implements TBase, java.io.Serializable, Cloneable, Comparable<alterEdge_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterEdge_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AlterEdgeReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AlterEdgeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterEdge_args.class, metaDataMap);
    }

    public alterEdge_args() {
    }

    public alterEdge_args(
        AlterEdgeReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterEdge_args(alterEdge_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public alterEdge_args deepCopy() {
      return new alterEdge_args(this);
    }

    public AlterEdgeReq getReq() {
      return this.req;
    }

    public alterEdge_args setReq(AlterEdgeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AlterEdgeReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof alterEdge_args))
        return false;
      alterEdge_args that = (alterEdge_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(alterEdge_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AlterEdgeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterEdge_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alterEdge_result implements TBase, java.io.Serializable, Cloneable, Comparable<alterEdge_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterEdge_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterEdge_result.class, metaDataMap);
    }

    public alterEdge_result() {
    }

    public alterEdge_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterEdge_result(alterEdge_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public alterEdge_result deepCopy() {
      return new alterEdge_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public alterEdge_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof alterEdge_result))
        return false;
      alterEdge_result that = (alterEdge_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(alterEdge_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterEdge_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropEdge_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropEdge_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropEdge_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropEdgeReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropEdgeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropEdge_args.class, metaDataMap);
    }

    public dropEdge_args() {
    }

    public dropEdge_args(
        DropEdgeReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropEdge_args(dropEdge_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropEdge_args deepCopy() {
      return new dropEdge_args(this);
    }

    public DropEdgeReq getReq() {
      return this.req;
    }

    public dropEdge_args setReq(DropEdgeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropEdgeReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropEdge_args))
        return false;
      dropEdge_args that = (dropEdge_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropEdge_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropEdgeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropEdge_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropEdge_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropEdge_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropEdge_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropEdge_result.class, metaDataMap);
    }

    public dropEdge_result() {
    }

    public dropEdge_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropEdge_result(dropEdge_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropEdge_result deepCopy() {
      return new dropEdge_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropEdge_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropEdge_result))
        return false;
      dropEdge_result that = (dropEdge_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropEdge_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropEdge_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getEdge_args implements TBase, java.io.Serializable, Cloneable, Comparable<getEdge_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getEdge_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetEdgeReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetEdgeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getEdge_args.class, metaDataMap);
    }

    public getEdge_args() {
    }

    public getEdge_args(
        GetEdgeReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEdge_args(getEdge_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getEdge_args deepCopy() {
      return new getEdge_args(this);
    }

    public GetEdgeReq getReq() {
      return this.req;
    }

    public getEdge_args setReq(GetEdgeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetEdgeReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getEdge_args))
        return false;
      getEdge_args that = (getEdge_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getEdge_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetEdgeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getEdge_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getEdge_result implements TBase, java.io.Serializable, Cloneable, Comparable<getEdge_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getEdge_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetEdgeResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetEdgeResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getEdge_result.class, metaDataMap);
    }

    public getEdge_result() {
    }

    public getEdge_result(
        GetEdgeResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEdge_result(getEdge_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getEdge_result deepCopy() {
      return new getEdge_result(this);
    }

    public GetEdgeResp getSuccess() {
      return this.success;
    }

    public getEdge_result setSuccess(GetEdgeResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetEdgeResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getEdge_result))
        return false;
      getEdge_result that = (getEdge_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getEdge_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetEdgeResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getEdge_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listEdges_args implements TBase, java.io.Serializable, Cloneable, Comparable<listEdges_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdges_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListEdgesReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListEdgesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdges_args.class, metaDataMap);
    }

    public listEdges_args() {
    }

    public listEdges_args(
        ListEdgesReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdges_args(listEdges_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listEdges_args deepCopy() {
      return new listEdges_args(this);
    }

    public ListEdgesReq getReq() {
      return this.req;
    }

    public listEdges_args setReq(ListEdgesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListEdgesReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listEdges_args))
        return false;
      listEdges_args that = (listEdges_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listEdges_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListEdgesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdges_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listEdges_result implements TBase, java.io.Serializable, Cloneable, Comparable<listEdges_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdges_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListEdgesResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListEdgesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdges_result.class, metaDataMap);
    }

    public listEdges_result() {
    }

    public listEdges_result(
        ListEdgesResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdges_result(listEdges_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listEdges_result deepCopy() {
      return new listEdges_result(this);
    }

    public ListEdgesResp getSuccess() {
      return this.success;
    }

    public listEdges_result setSuccess(ListEdgesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListEdgesResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listEdges_result))
        return false;
      listEdges_result that = (listEdges_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listEdges_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListEdgesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdges_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listHosts_args implements TBase, java.io.Serializable, Cloneable, Comparable<listHosts_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listHosts_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListHostsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListHostsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listHosts_args.class, metaDataMap);
    }

    public listHosts_args() {
    }

    public listHosts_args(
        ListHostsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listHosts_args(listHosts_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listHosts_args deepCopy() {
      return new listHosts_args(this);
    }

    public ListHostsReq getReq() {
      return this.req;
    }

    public listHosts_args setReq(ListHostsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListHostsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listHosts_args))
        return false;
      listHosts_args that = (listHosts_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listHosts_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListHostsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listHosts_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listHosts_result implements TBase, java.io.Serializable, Cloneable, Comparable<listHosts_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listHosts_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListHostsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListHostsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listHosts_result.class, metaDataMap);
    }

    public listHosts_result() {
    }

    public listHosts_result(
        ListHostsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listHosts_result(listHosts_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listHosts_result deepCopy() {
      return new listHosts_result(this);
    }

    public ListHostsResp getSuccess() {
      return this.success;
    }

    public listHosts_result setSuccess(ListHostsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListHostsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listHosts_result))
        return false;
      listHosts_result that = (listHosts_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listHosts_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListHostsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listHosts_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getPartsAlloc_args implements TBase, java.io.Serializable, Cloneable, Comparable<getPartsAlloc_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getPartsAlloc_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetPartsAllocReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetPartsAllocReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getPartsAlloc_args.class, metaDataMap);
    }

    public getPartsAlloc_args() {
    }

    public getPartsAlloc_args(
        GetPartsAllocReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPartsAlloc_args(getPartsAlloc_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getPartsAlloc_args deepCopy() {
      return new getPartsAlloc_args(this);
    }

    public GetPartsAllocReq getReq() {
      return this.req;
    }

    public getPartsAlloc_args setReq(GetPartsAllocReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetPartsAllocReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getPartsAlloc_args))
        return false;
      getPartsAlloc_args that = (getPartsAlloc_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getPartsAlloc_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetPartsAllocReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getPartsAlloc_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getPartsAlloc_result implements TBase, java.io.Serializable, Cloneable, Comparable<getPartsAlloc_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getPartsAlloc_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetPartsAllocResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetPartsAllocResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getPartsAlloc_result.class, metaDataMap);
    }

    public getPartsAlloc_result() {
    }

    public getPartsAlloc_result(
        GetPartsAllocResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPartsAlloc_result(getPartsAlloc_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getPartsAlloc_result deepCopy() {
      return new getPartsAlloc_result(this);
    }

    public GetPartsAllocResp getSuccess() {
      return this.success;
    }

    public getPartsAlloc_result setSuccess(GetPartsAllocResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetPartsAllocResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getPartsAlloc_result))
        return false;
      getPartsAlloc_result that = (getPartsAlloc_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getPartsAlloc_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetPartsAllocResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getPartsAlloc_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listParts_args implements TBase, java.io.Serializable, Cloneable, Comparable<listParts_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listParts_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListPartsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListPartsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listParts_args.class, metaDataMap);
    }

    public listParts_args() {
    }

    public listParts_args(
        ListPartsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listParts_args(listParts_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listParts_args deepCopy() {
      return new listParts_args(this);
    }

    public ListPartsReq getReq() {
      return this.req;
    }

    public listParts_args setReq(ListPartsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListPartsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listParts_args))
        return false;
      listParts_args that = (listParts_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listParts_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListPartsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listParts_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listParts_result implements TBase, java.io.Serializable, Cloneable, Comparable<listParts_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listParts_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListPartsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListPartsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listParts_result.class, metaDataMap);
    }

    public listParts_result() {
    }

    public listParts_result(
        ListPartsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listParts_result(listParts_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listParts_result deepCopy() {
      return new listParts_result(this);
    }

    public ListPartsResp getSuccess() {
      return this.success;
    }

    public listParts_result setSuccess(ListPartsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListPartsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listParts_result))
        return false;
      listParts_result that = (listParts_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listParts_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListPartsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listParts_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class multiPut_args implements TBase, java.io.Serializable, Cloneable, Comparable<multiPut_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("multiPut_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public MultiPutReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, MultiPutReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(multiPut_args.class, metaDataMap);
    }

    public multiPut_args() {
    }

    public multiPut_args(
        MultiPutReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiPut_args(multiPut_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public multiPut_args deepCopy() {
      return new multiPut_args(this);
    }

    public MultiPutReq getReq() {
      return this.req;
    }

    public multiPut_args setReq(MultiPutReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((MultiPutReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof multiPut_args))
        return false;
      multiPut_args that = (multiPut_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(multiPut_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new MultiPutReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("multiPut_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class multiPut_result implements TBase, java.io.Serializable, Cloneable, Comparable<multiPut_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("multiPut_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(multiPut_result.class, metaDataMap);
    }

    public multiPut_result() {
    }

    public multiPut_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiPut_result(multiPut_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public multiPut_result deepCopy() {
      return new multiPut_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public multiPut_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof multiPut_result))
        return false;
      multiPut_result that = (multiPut_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(multiPut_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("multiPut_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(get_args.class, metaDataMap);
    }

    public get_args() {
    }

    public get_args(
        GetReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_args(get_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public get_args deepCopy() {
      return new get_args(this);
    }

    public GetReq getReq() {
      return this.req;
    }

    public get_args setReq(GetReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof get_args))
        return false;
      get_args that = (get_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(get_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("get_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(get_result.class, metaDataMap);
    }

    public get_result() {
    }

    public get_result(
        GetResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_result(get_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public get_result deepCopy() {
      return new get_result(this);
    }

    public GetResp getSuccess() {
      return this.success;
    }

    public get_result setSuccess(GetResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof get_result))
        return false;
      get_result that = (get_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(get_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("get_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class multiGet_args implements TBase, java.io.Serializable, Cloneable, Comparable<multiGet_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("multiGet_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public MultiGetReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, MultiGetReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(multiGet_args.class, metaDataMap);
    }

    public multiGet_args() {
    }

    public multiGet_args(
        MultiGetReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiGet_args(multiGet_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public multiGet_args deepCopy() {
      return new multiGet_args(this);
    }

    public MultiGetReq getReq() {
      return this.req;
    }

    public multiGet_args setReq(MultiGetReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((MultiGetReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof multiGet_args))
        return false;
      multiGet_args that = (multiGet_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(multiGet_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new MultiGetReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("multiGet_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class multiGet_result implements TBase, java.io.Serializable, Cloneable, Comparable<multiGet_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("multiGet_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public MultiGetResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, MultiGetResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(multiGet_result.class, metaDataMap);
    }

    public multiGet_result() {
    }

    public multiGet_result(
        MultiGetResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiGet_result(multiGet_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public multiGet_result deepCopy() {
      return new multiGet_result(this);
    }

    public MultiGetResp getSuccess() {
      return this.success;
    }

    public multiGet_result setSuccess(MultiGetResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((MultiGetResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof multiGet_result))
        return false;
      multiGet_result that = (multiGet_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(multiGet_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new MultiGetResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("multiGet_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class remove_args implements TBase, java.io.Serializable, Cloneable, Comparable<remove_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RemoveReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RemoveReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(remove_args.class, metaDataMap);
    }

    public remove_args() {
    }

    public remove_args(
        RemoveReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_args(remove_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public remove_args deepCopy() {
      return new remove_args(this);
    }

    public RemoveReq getReq() {
      return this.req;
    }

    public remove_args setReq(RemoveReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((RemoveReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof remove_args))
        return false;
      remove_args that = (remove_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(remove_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new RemoveReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("remove_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class remove_result implements TBase, java.io.Serializable, Cloneable, Comparable<remove_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(remove_result.class, metaDataMap);
    }

    public remove_result() {
    }

    public remove_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_result(remove_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public remove_result deepCopy() {
      return new remove_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public remove_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof remove_result))
        return false;
      remove_result that = (remove_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(remove_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("remove_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class removeRange_args implements TBase, java.io.Serializable, Cloneable, Comparable<removeRange_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeRange_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RemoveRangeReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RemoveRangeReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(removeRange_args.class, metaDataMap);
    }

    public removeRange_args() {
    }

    public removeRange_args(
        RemoveRangeReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeRange_args(removeRange_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public removeRange_args deepCopy() {
      return new removeRange_args(this);
    }

    public RemoveRangeReq getReq() {
      return this.req;
    }

    public removeRange_args setReq(RemoveRangeReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((RemoveRangeReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof removeRange_args))
        return false;
      removeRange_args that = (removeRange_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(removeRange_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new RemoveRangeReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("removeRange_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class removeRange_result implements TBase, java.io.Serializable, Cloneable, Comparable<removeRange_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeRange_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(removeRange_result.class, metaDataMap);
    }

    public removeRange_result() {
    }

    public removeRange_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeRange_result(removeRange_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public removeRange_result deepCopy() {
      return new removeRange_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public removeRange_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof removeRange_result))
        return false;
      removeRange_result that = (removeRange_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(removeRange_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("removeRange_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scan_args implements TBase, java.io.Serializable, Cloneable, Comparable<scan_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("scan_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ScanReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ScanReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(scan_args.class, metaDataMap);
    }

    public scan_args() {
    }

    public scan_args(
        ScanReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scan_args(scan_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public scan_args deepCopy() {
      return new scan_args(this);
    }

    public ScanReq getReq() {
      return this.req;
    }

    public scan_args setReq(ScanReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ScanReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof scan_args))
        return false;
      scan_args that = (scan_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(scan_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ScanReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("scan_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class scan_result implements TBase, java.io.Serializable, Cloneable, Comparable<scan_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("scan_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ScanResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ScanResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(scan_result.class, metaDataMap);
    }

    public scan_result() {
    }

    public scan_result(
        ScanResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scan_result(scan_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public scan_result deepCopy() {
      return new scan_result(this);
    }

    public ScanResp getSuccess() {
      return this.success;
    }

    public scan_result setSuccess(ScanResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ScanResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof scan_result))
        return false;
      scan_result that = (scan_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(scan_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ScanResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("scan_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createTagIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<createTagIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createTagIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateTagIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateTagIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createTagIndex_args.class, metaDataMap);
    }

    public createTagIndex_args() {
    }

    public createTagIndex_args(
        CreateTagIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTagIndex_args(createTagIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createTagIndex_args deepCopy() {
      return new createTagIndex_args(this);
    }

    public CreateTagIndexReq getReq() {
      return this.req;
    }

    public createTagIndex_args setReq(CreateTagIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateTagIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createTagIndex_args))
        return false;
      createTagIndex_args that = (createTagIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createTagIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateTagIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createTagIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createTagIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<createTagIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createTagIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createTagIndex_result.class, metaDataMap);
    }

    public createTagIndex_result() {
    }

    public createTagIndex_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTagIndex_result(createTagIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createTagIndex_result deepCopy() {
      return new createTagIndex_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public createTagIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createTagIndex_result))
        return false;
      createTagIndex_result that = (createTagIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createTagIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createTagIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropTagIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropTagIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTagIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropTagIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropTagIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropTagIndex_args.class, metaDataMap);
    }

    public dropTagIndex_args() {
    }

    public dropTagIndex_args(
        DropTagIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTagIndex_args(dropTagIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropTagIndex_args deepCopy() {
      return new dropTagIndex_args(this);
    }

    public DropTagIndexReq getReq() {
      return this.req;
    }

    public dropTagIndex_args setReq(DropTagIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropTagIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropTagIndex_args))
        return false;
      dropTagIndex_args that = (dropTagIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropTagIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropTagIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropTagIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropTagIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropTagIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTagIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropTagIndex_result.class, metaDataMap);
    }

    public dropTagIndex_result() {
    }

    public dropTagIndex_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTagIndex_result(dropTagIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropTagIndex_result deepCopy() {
      return new dropTagIndex_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropTagIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropTagIndex_result))
        return false;
      dropTagIndex_result that = (dropTagIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropTagIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropTagIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTagIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<getTagIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getTagIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetTagIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetTagIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getTagIndex_args.class, metaDataMap);
    }

    public getTagIndex_args() {
    }

    public getTagIndex_args(
        GetTagIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTagIndex_args(getTagIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getTagIndex_args deepCopy() {
      return new getTagIndex_args(this);
    }

    public GetTagIndexReq getReq() {
      return this.req;
    }

    public getTagIndex_args setReq(GetTagIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetTagIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getTagIndex_args))
        return false;
      getTagIndex_args that = (getTagIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getTagIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetTagIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getTagIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTagIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<getTagIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getTagIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetTagIndexResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetTagIndexResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getTagIndex_result.class, metaDataMap);
    }

    public getTagIndex_result() {
    }

    public getTagIndex_result(
        GetTagIndexResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTagIndex_result(getTagIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getTagIndex_result deepCopy() {
      return new getTagIndex_result(this);
    }

    public GetTagIndexResp getSuccess() {
      return this.success;
    }

    public getTagIndex_result setSuccess(GetTagIndexResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetTagIndexResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getTagIndex_result))
        return false;
      getTagIndex_result that = (getTagIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getTagIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetTagIndexResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getTagIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listTagIndexes_args implements TBase, java.io.Serializable, Cloneable, Comparable<listTagIndexes_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTagIndexes_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListTagIndexesReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListTagIndexesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTagIndexes_args.class, metaDataMap);
    }

    public listTagIndexes_args() {
    }

    public listTagIndexes_args(
        ListTagIndexesReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTagIndexes_args(listTagIndexes_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listTagIndexes_args deepCopy() {
      return new listTagIndexes_args(this);
    }

    public ListTagIndexesReq getReq() {
      return this.req;
    }

    public listTagIndexes_args setReq(ListTagIndexesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListTagIndexesReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listTagIndexes_args))
        return false;
      listTagIndexes_args that = (listTagIndexes_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listTagIndexes_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListTagIndexesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTagIndexes_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listTagIndexes_result implements TBase, java.io.Serializable, Cloneable, Comparable<listTagIndexes_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTagIndexes_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListTagIndexesResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListTagIndexesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTagIndexes_result.class, metaDataMap);
    }

    public listTagIndexes_result() {
    }

    public listTagIndexes_result(
        ListTagIndexesResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTagIndexes_result(listTagIndexes_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listTagIndexes_result deepCopy() {
      return new listTagIndexes_result(this);
    }

    public ListTagIndexesResp getSuccess() {
      return this.success;
    }

    public listTagIndexes_result setSuccess(ListTagIndexesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListTagIndexesResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listTagIndexes_result))
        return false;
      listTagIndexes_result that = (listTagIndexes_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listTagIndexes_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListTagIndexesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTagIndexes_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class rebuildTagIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<rebuildTagIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("rebuildTagIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RebuildIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RebuildIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(rebuildTagIndex_args.class, metaDataMap);
    }

    public rebuildTagIndex_args() {
    }

    public rebuildTagIndex_args(
        RebuildIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rebuildTagIndex_args(rebuildTagIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public rebuildTagIndex_args deepCopy() {
      return new rebuildTagIndex_args(this);
    }

    public RebuildIndexReq getReq() {
      return this.req;
    }

    public rebuildTagIndex_args setReq(RebuildIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((RebuildIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof rebuildTagIndex_args))
        return false;
      rebuildTagIndex_args that = (rebuildTagIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(rebuildTagIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new RebuildIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("rebuildTagIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class rebuildTagIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<rebuildTagIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("rebuildTagIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(rebuildTagIndex_result.class, metaDataMap);
    }

    public rebuildTagIndex_result() {
    }

    public rebuildTagIndex_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rebuildTagIndex_result(rebuildTagIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public rebuildTagIndex_result deepCopy() {
      return new rebuildTagIndex_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public rebuildTagIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof rebuildTagIndex_result))
        return false;
      rebuildTagIndex_result that = (rebuildTagIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(rebuildTagIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("rebuildTagIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listTagIndexStatus_args implements TBase, java.io.Serializable, Cloneable, Comparable<listTagIndexStatus_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTagIndexStatus_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListIndexStatusReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListIndexStatusReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTagIndexStatus_args.class, metaDataMap);
    }

    public listTagIndexStatus_args() {
    }

    public listTagIndexStatus_args(
        ListIndexStatusReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTagIndexStatus_args(listTagIndexStatus_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listTagIndexStatus_args deepCopy() {
      return new listTagIndexStatus_args(this);
    }

    public ListIndexStatusReq getReq() {
      return this.req;
    }

    public listTagIndexStatus_args setReq(ListIndexStatusReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListIndexStatusReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listTagIndexStatus_args))
        return false;
      listTagIndexStatus_args that = (listTagIndexStatus_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listTagIndexStatus_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListIndexStatusReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTagIndexStatus_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listTagIndexStatus_result implements TBase, java.io.Serializable, Cloneable, Comparable<listTagIndexStatus_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTagIndexStatus_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListIndexStatusResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListIndexStatusResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listTagIndexStatus_result.class, metaDataMap);
    }

    public listTagIndexStatus_result() {
    }

    public listTagIndexStatus_result(
        ListIndexStatusResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTagIndexStatus_result(listTagIndexStatus_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listTagIndexStatus_result deepCopy() {
      return new listTagIndexStatus_result(this);
    }

    public ListIndexStatusResp getSuccess() {
      return this.success;
    }

    public listTagIndexStatus_result setSuccess(ListIndexStatusResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListIndexStatusResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listTagIndexStatus_result))
        return false;
      listTagIndexStatus_result that = (listTagIndexStatus_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listTagIndexStatus_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListIndexStatusResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listTagIndexStatus_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createEdgeIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<createEdgeIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createEdgeIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateEdgeIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateEdgeIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createEdgeIndex_args.class, metaDataMap);
    }

    public createEdgeIndex_args() {
    }

    public createEdgeIndex_args(
        CreateEdgeIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createEdgeIndex_args(createEdgeIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createEdgeIndex_args deepCopy() {
      return new createEdgeIndex_args(this);
    }

    public CreateEdgeIndexReq getReq() {
      return this.req;
    }

    public createEdgeIndex_args setReq(CreateEdgeIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateEdgeIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createEdgeIndex_args))
        return false;
      createEdgeIndex_args that = (createEdgeIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createEdgeIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateEdgeIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createEdgeIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createEdgeIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<createEdgeIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createEdgeIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createEdgeIndex_result.class, metaDataMap);
    }

    public createEdgeIndex_result() {
    }

    public createEdgeIndex_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createEdgeIndex_result(createEdgeIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createEdgeIndex_result deepCopy() {
      return new createEdgeIndex_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public createEdgeIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createEdgeIndex_result))
        return false;
      createEdgeIndex_result that = (createEdgeIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createEdgeIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createEdgeIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropEdgeIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropEdgeIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropEdgeIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropEdgeIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropEdgeIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropEdgeIndex_args.class, metaDataMap);
    }

    public dropEdgeIndex_args() {
    }

    public dropEdgeIndex_args(
        DropEdgeIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropEdgeIndex_args(dropEdgeIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropEdgeIndex_args deepCopy() {
      return new dropEdgeIndex_args(this);
    }

    public DropEdgeIndexReq getReq() {
      return this.req;
    }

    public dropEdgeIndex_args setReq(DropEdgeIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropEdgeIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropEdgeIndex_args))
        return false;
      dropEdgeIndex_args that = (dropEdgeIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropEdgeIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropEdgeIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropEdgeIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropEdgeIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropEdgeIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropEdgeIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropEdgeIndex_result.class, metaDataMap);
    }

    public dropEdgeIndex_result() {
    }

    public dropEdgeIndex_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropEdgeIndex_result(dropEdgeIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropEdgeIndex_result deepCopy() {
      return new dropEdgeIndex_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropEdgeIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropEdgeIndex_result))
        return false;
      dropEdgeIndex_result that = (dropEdgeIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropEdgeIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropEdgeIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getEdgeIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<getEdgeIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getEdgeIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetEdgeIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetEdgeIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getEdgeIndex_args.class, metaDataMap);
    }

    public getEdgeIndex_args() {
    }

    public getEdgeIndex_args(
        GetEdgeIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEdgeIndex_args(getEdgeIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getEdgeIndex_args deepCopy() {
      return new getEdgeIndex_args(this);
    }

    public GetEdgeIndexReq getReq() {
      return this.req;
    }

    public getEdgeIndex_args setReq(GetEdgeIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetEdgeIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getEdgeIndex_args))
        return false;
      getEdgeIndex_args that = (getEdgeIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getEdgeIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetEdgeIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getEdgeIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getEdgeIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<getEdgeIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getEdgeIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetEdgeIndexResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetEdgeIndexResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getEdgeIndex_result.class, metaDataMap);
    }

    public getEdgeIndex_result() {
    }

    public getEdgeIndex_result(
        GetEdgeIndexResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEdgeIndex_result(getEdgeIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getEdgeIndex_result deepCopy() {
      return new getEdgeIndex_result(this);
    }

    public GetEdgeIndexResp getSuccess() {
      return this.success;
    }

    public getEdgeIndex_result setSuccess(GetEdgeIndexResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetEdgeIndexResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getEdgeIndex_result))
        return false;
      getEdgeIndex_result that = (getEdgeIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getEdgeIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetEdgeIndexResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getEdgeIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listEdgeIndexes_args implements TBase, java.io.Serializable, Cloneable, Comparable<listEdgeIndexes_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdgeIndexes_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListEdgeIndexesReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListEdgeIndexesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdgeIndexes_args.class, metaDataMap);
    }

    public listEdgeIndexes_args() {
    }

    public listEdgeIndexes_args(
        ListEdgeIndexesReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdgeIndexes_args(listEdgeIndexes_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listEdgeIndexes_args deepCopy() {
      return new listEdgeIndexes_args(this);
    }

    public ListEdgeIndexesReq getReq() {
      return this.req;
    }

    public listEdgeIndexes_args setReq(ListEdgeIndexesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListEdgeIndexesReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listEdgeIndexes_args))
        return false;
      listEdgeIndexes_args that = (listEdgeIndexes_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listEdgeIndexes_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListEdgeIndexesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdgeIndexes_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listEdgeIndexes_result implements TBase, java.io.Serializable, Cloneable, Comparable<listEdgeIndexes_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdgeIndexes_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListEdgeIndexesResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListEdgeIndexesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdgeIndexes_result.class, metaDataMap);
    }

    public listEdgeIndexes_result() {
    }

    public listEdgeIndexes_result(
        ListEdgeIndexesResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdgeIndexes_result(listEdgeIndexes_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listEdgeIndexes_result deepCopy() {
      return new listEdgeIndexes_result(this);
    }

    public ListEdgeIndexesResp getSuccess() {
      return this.success;
    }

    public listEdgeIndexes_result setSuccess(ListEdgeIndexesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListEdgeIndexesResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listEdgeIndexes_result))
        return false;
      listEdgeIndexes_result that = (listEdgeIndexes_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listEdgeIndexes_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListEdgeIndexesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdgeIndexes_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class rebuildEdgeIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<rebuildEdgeIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("rebuildEdgeIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RebuildIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RebuildIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(rebuildEdgeIndex_args.class, metaDataMap);
    }

    public rebuildEdgeIndex_args() {
    }

    public rebuildEdgeIndex_args(
        RebuildIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rebuildEdgeIndex_args(rebuildEdgeIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public rebuildEdgeIndex_args deepCopy() {
      return new rebuildEdgeIndex_args(this);
    }

    public RebuildIndexReq getReq() {
      return this.req;
    }

    public rebuildEdgeIndex_args setReq(RebuildIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((RebuildIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof rebuildEdgeIndex_args))
        return false;
      rebuildEdgeIndex_args that = (rebuildEdgeIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(rebuildEdgeIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new RebuildIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("rebuildEdgeIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class rebuildEdgeIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<rebuildEdgeIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("rebuildEdgeIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(rebuildEdgeIndex_result.class, metaDataMap);
    }

    public rebuildEdgeIndex_result() {
    }

    public rebuildEdgeIndex_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rebuildEdgeIndex_result(rebuildEdgeIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public rebuildEdgeIndex_result deepCopy() {
      return new rebuildEdgeIndex_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public rebuildEdgeIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof rebuildEdgeIndex_result))
        return false;
      rebuildEdgeIndex_result that = (rebuildEdgeIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(rebuildEdgeIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("rebuildEdgeIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listEdgeIndexStatus_args implements TBase, java.io.Serializable, Cloneable, Comparable<listEdgeIndexStatus_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdgeIndexStatus_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListIndexStatusReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListIndexStatusReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdgeIndexStatus_args.class, metaDataMap);
    }

    public listEdgeIndexStatus_args() {
    }

    public listEdgeIndexStatus_args(
        ListIndexStatusReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdgeIndexStatus_args(listEdgeIndexStatus_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listEdgeIndexStatus_args deepCopy() {
      return new listEdgeIndexStatus_args(this);
    }

    public ListIndexStatusReq getReq() {
      return this.req;
    }

    public listEdgeIndexStatus_args setReq(ListIndexStatusReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListIndexStatusReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listEdgeIndexStatus_args))
        return false;
      listEdgeIndexStatus_args that = (listEdgeIndexStatus_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listEdgeIndexStatus_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListIndexStatusReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdgeIndexStatus_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listEdgeIndexStatus_result implements TBase, java.io.Serializable, Cloneable, Comparable<listEdgeIndexStatus_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listEdgeIndexStatus_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListIndexStatusResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListIndexStatusResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listEdgeIndexStatus_result.class, metaDataMap);
    }

    public listEdgeIndexStatus_result() {
    }

    public listEdgeIndexStatus_result(
        ListIndexStatusResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listEdgeIndexStatus_result(listEdgeIndexStatus_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listEdgeIndexStatus_result deepCopy() {
      return new listEdgeIndexStatus_result(this);
    }

    public ListIndexStatusResp getSuccess() {
      return this.success;
    }

    public listEdgeIndexStatus_result setSuccess(ListIndexStatusResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListIndexStatusResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listEdgeIndexStatus_result))
        return false;
      listEdgeIndexStatus_result that = (listEdgeIndexStatus_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listEdgeIndexStatus_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListIndexStatusResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listEdgeIndexStatus_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createUser_args implements TBase, java.io.Serializable, Cloneable, Comparable<createUser_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createUser_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateUserReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateUserReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createUser_args.class, metaDataMap);
    }

    public createUser_args() {
    }

    public createUser_args(
        CreateUserReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createUser_args(createUser_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createUser_args deepCopy() {
      return new createUser_args(this);
    }

    public CreateUserReq getReq() {
      return this.req;
    }

    public createUser_args setReq(CreateUserReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateUserReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createUser_args))
        return false;
      createUser_args that = (createUser_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createUser_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateUserReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createUser_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createUser_result implements TBase, java.io.Serializable, Cloneable, Comparable<createUser_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createUser_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createUser_result.class, metaDataMap);
    }

    public createUser_result() {
    }

    public createUser_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createUser_result(createUser_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createUser_result deepCopy() {
      return new createUser_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public createUser_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createUser_result))
        return false;
      createUser_result that = (createUser_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createUser_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createUser_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropUser_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropUser_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropUser_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropUserReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropUserReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropUser_args.class, metaDataMap);
    }

    public dropUser_args() {
    }

    public dropUser_args(
        DropUserReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropUser_args(dropUser_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropUser_args deepCopy() {
      return new dropUser_args(this);
    }

    public DropUserReq getReq() {
      return this.req;
    }

    public dropUser_args setReq(DropUserReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropUserReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropUser_args))
        return false;
      dropUser_args that = (dropUser_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropUser_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropUserReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropUser_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropUser_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropUser_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropUser_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropUser_result.class, metaDataMap);
    }

    public dropUser_result() {
    }

    public dropUser_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropUser_result(dropUser_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropUser_result deepCopy() {
      return new dropUser_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropUser_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropUser_result))
        return false;
      dropUser_result that = (dropUser_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropUser_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropUser_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alterUser_args implements TBase, java.io.Serializable, Cloneable, Comparable<alterUser_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterUser_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AlterUserReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AlterUserReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterUser_args.class, metaDataMap);
    }

    public alterUser_args() {
    }

    public alterUser_args(
        AlterUserReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterUser_args(alterUser_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public alterUser_args deepCopy() {
      return new alterUser_args(this);
    }

    public AlterUserReq getReq() {
      return this.req;
    }

    public alterUser_args setReq(AlterUserReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AlterUserReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof alterUser_args))
        return false;
      alterUser_args that = (alterUser_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(alterUser_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AlterUserReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterUser_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alterUser_result implements TBase, java.io.Serializable, Cloneable, Comparable<alterUser_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("alterUser_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(alterUser_result.class, metaDataMap);
    }

    public alterUser_result() {
    }

    public alterUser_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alterUser_result(alterUser_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public alterUser_result deepCopy() {
      return new alterUser_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public alterUser_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof alterUser_result))
        return false;
      alterUser_result that = (alterUser_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(alterUser_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("alterUser_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class grantRole_args implements TBase, java.io.Serializable, Cloneable, Comparable<grantRole_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("grantRole_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GrantRoleReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GrantRoleReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(grantRole_args.class, metaDataMap);
    }

    public grantRole_args() {
    }

    public grantRole_args(
        GrantRoleReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public grantRole_args(grantRole_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public grantRole_args deepCopy() {
      return new grantRole_args(this);
    }

    public GrantRoleReq getReq() {
      return this.req;
    }

    public grantRole_args setReq(GrantRoleReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GrantRoleReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof grantRole_args))
        return false;
      grantRole_args that = (grantRole_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(grantRole_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GrantRoleReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("grantRole_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class grantRole_result implements TBase, java.io.Serializable, Cloneable, Comparable<grantRole_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("grantRole_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(grantRole_result.class, metaDataMap);
    }

    public grantRole_result() {
    }

    public grantRole_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public grantRole_result(grantRole_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public grantRole_result deepCopy() {
      return new grantRole_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public grantRole_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof grantRole_result))
        return false;
      grantRole_result that = (grantRole_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(grantRole_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("grantRole_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class revokeRole_args implements TBase, java.io.Serializable, Cloneable, Comparable<revokeRole_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("revokeRole_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RevokeRoleReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RevokeRoleReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(revokeRole_args.class, metaDataMap);
    }

    public revokeRole_args() {
    }

    public revokeRole_args(
        RevokeRoleReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public revokeRole_args(revokeRole_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public revokeRole_args deepCopy() {
      return new revokeRole_args(this);
    }

    public RevokeRoleReq getReq() {
      return this.req;
    }

    public revokeRole_args setReq(RevokeRoleReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((RevokeRoleReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof revokeRole_args))
        return false;
      revokeRole_args that = (revokeRole_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(revokeRole_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new RevokeRoleReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("revokeRole_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class revokeRole_result implements TBase, java.io.Serializable, Cloneable, Comparable<revokeRole_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("revokeRole_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(revokeRole_result.class, metaDataMap);
    }

    public revokeRole_result() {
    }

    public revokeRole_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public revokeRole_result(revokeRole_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public revokeRole_result deepCopy() {
      return new revokeRole_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public revokeRole_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof revokeRole_result))
        return false;
      revokeRole_result that = (revokeRole_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(revokeRole_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("revokeRole_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listUsers_args implements TBase, java.io.Serializable, Cloneable, Comparable<listUsers_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listUsers_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListUsersReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListUsersReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listUsers_args.class, metaDataMap);
    }

    public listUsers_args() {
    }

    public listUsers_args(
        ListUsersReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listUsers_args(listUsers_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listUsers_args deepCopy() {
      return new listUsers_args(this);
    }

    public ListUsersReq getReq() {
      return this.req;
    }

    public listUsers_args setReq(ListUsersReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListUsersReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listUsers_args))
        return false;
      listUsers_args that = (listUsers_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listUsers_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListUsersReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listUsers_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listUsers_result implements TBase, java.io.Serializable, Cloneable, Comparable<listUsers_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listUsers_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListUsersResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListUsersResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listUsers_result.class, metaDataMap);
    }

    public listUsers_result() {
    }

    public listUsers_result(
        ListUsersResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listUsers_result(listUsers_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listUsers_result deepCopy() {
      return new listUsers_result(this);
    }

    public ListUsersResp getSuccess() {
      return this.success;
    }

    public listUsers_result setSuccess(ListUsersResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListUsersResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listUsers_result))
        return false;
      listUsers_result that = (listUsers_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listUsers_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListUsersResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listUsers_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listRoles_args implements TBase, java.io.Serializable, Cloneable, Comparable<listRoles_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listRoles_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListRolesReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListRolesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listRoles_args.class, metaDataMap);
    }

    public listRoles_args() {
    }

    public listRoles_args(
        ListRolesReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listRoles_args(listRoles_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listRoles_args deepCopy() {
      return new listRoles_args(this);
    }

    public ListRolesReq getReq() {
      return this.req;
    }

    public listRoles_args setReq(ListRolesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListRolesReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listRoles_args))
        return false;
      listRoles_args that = (listRoles_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listRoles_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListRolesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listRoles_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listRoles_result implements TBase, java.io.Serializable, Cloneable, Comparable<listRoles_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listRoles_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListRolesResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListRolesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listRoles_result.class, metaDataMap);
    }

    public listRoles_result() {
    }

    public listRoles_result(
        ListRolesResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listRoles_result(listRoles_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listRoles_result deepCopy() {
      return new listRoles_result(this);
    }

    public ListRolesResp getSuccess() {
      return this.success;
    }

    public listRoles_result setSuccess(ListRolesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListRolesResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listRoles_result))
        return false;
      listRoles_result that = (listRoles_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listRoles_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListRolesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listRoles_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getUserRoles_args implements TBase, java.io.Serializable, Cloneable, Comparable<getUserRoles_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getUserRoles_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetUserRolesReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetUserRolesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getUserRoles_args.class, metaDataMap);
    }

    public getUserRoles_args() {
    }

    public getUserRoles_args(
        GetUserRolesReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getUserRoles_args(getUserRoles_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getUserRoles_args deepCopy() {
      return new getUserRoles_args(this);
    }

    public GetUserRolesReq getReq() {
      return this.req;
    }

    public getUserRoles_args setReq(GetUserRolesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetUserRolesReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getUserRoles_args))
        return false;
      getUserRoles_args that = (getUserRoles_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getUserRoles_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetUserRolesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getUserRoles_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getUserRoles_result implements TBase, java.io.Serializable, Cloneable, Comparable<getUserRoles_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getUserRoles_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListRolesResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListRolesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getUserRoles_result.class, metaDataMap);
    }

    public getUserRoles_result() {
    }

    public getUserRoles_result(
        ListRolesResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getUserRoles_result(getUserRoles_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getUserRoles_result deepCopy() {
      return new getUserRoles_result(this);
    }

    public ListRolesResp getSuccess() {
      return this.success;
    }

    public getUserRoles_result setSuccess(ListRolesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListRolesResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getUserRoles_result))
        return false;
      getUserRoles_result that = (getUserRoles_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getUserRoles_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListRolesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getUserRoles_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class changePassword_args implements TBase, java.io.Serializable, Cloneable, Comparable<changePassword_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("changePassword_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ChangePasswordReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ChangePasswordReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(changePassword_args.class, metaDataMap);
    }

    public changePassword_args() {
    }

    public changePassword_args(
        ChangePasswordReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public changePassword_args(changePassword_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public changePassword_args deepCopy() {
      return new changePassword_args(this);
    }

    public ChangePasswordReq getReq() {
      return this.req;
    }

    public changePassword_args setReq(ChangePasswordReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ChangePasswordReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof changePassword_args))
        return false;
      changePassword_args that = (changePassword_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(changePassword_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ChangePasswordReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("changePassword_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class changePassword_result implements TBase, java.io.Serializable, Cloneable, Comparable<changePassword_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("changePassword_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(changePassword_result.class, metaDataMap);
    }

    public changePassword_result() {
    }

    public changePassword_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public changePassword_result(changePassword_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public changePassword_result deepCopy() {
      return new changePassword_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public changePassword_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof changePassword_result))
        return false;
      changePassword_result that = (changePassword_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(changePassword_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("changePassword_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class heartBeat_args implements TBase, java.io.Serializable, Cloneable, Comparable<heartBeat_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("heartBeat_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public HBReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, HBReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(heartBeat_args.class, metaDataMap);
    }

    public heartBeat_args() {
    }

    public heartBeat_args(
        HBReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public heartBeat_args(heartBeat_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public heartBeat_args deepCopy() {
      return new heartBeat_args(this);
    }

    public HBReq getReq() {
      return this.req;
    }

    public heartBeat_args setReq(HBReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((HBReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof heartBeat_args))
        return false;
      heartBeat_args that = (heartBeat_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(heartBeat_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new HBReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("heartBeat_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class heartBeat_result implements TBase, java.io.Serializable, Cloneable, Comparable<heartBeat_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("heartBeat_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public HBResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, HBResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(heartBeat_result.class, metaDataMap);
    }

    public heartBeat_result() {
    }

    public heartBeat_result(
        HBResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public heartBeat_result(heartBeat_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public heartBeat_result deepCopy() {
      return new heartBeat_result(this);
    }

    public HBResp getSuccess() {
      return this.success;
    }

    public heartBeat_result setSuccess(HBResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((HBResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof heartBeat_result))
        return false;
      heartBeat_result that = (heartBeat_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(heartBeat_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new HBResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("heartBeat_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class balance_args implements TBase, java.io.Serializable, Cloneable, Comparable<balance_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("balance_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public BalanceReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, BalanceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(balance_args.class, metaDataMap);
    }

    public balance_args() {
    }

    public balance_args(
        BalanceReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public balance_args(balance_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public balance_args deepCopy() {
      return new balance_args(this);
    }

    public BalanceReq getReq() {
      return this.req;
    }

    public balance_args setReq(BalanceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((BalanceReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof balance_args))
        return false;
      balance_args that = (balance_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(balance_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new BalanceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("balance_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class balance_result implements TBase, java.io.Serializable, Cloneable, Comparable<balance_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("balance_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public BalanceResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, BalanceResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(balance_result.class, metaDataMap);
    }

    public balance_result() {
    }

    public balance_result(
        BalanceResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public balance_result(balance_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public balance_result deepCopy() {
      return new balance_result(this);
    }

    public BalanceResp getSuccess() {
      return this.success;
    }

    public balance_result setSuccess(BalanceResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((BalanceResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof balance_result))
        return false;
      balance_result that = (balance_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(balance_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new BalanceResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("balance_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class leaderBalance_args implements TBase, java.io.Serializable, Cloneable, Comparable<leaderBalance_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("leaderBalance_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public LeaderBalanceReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, LeaderBalanceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(leaderBalance_args.class, metaDataMap);
    }

    public leaderBalance_args() {
    }

    public leaderBalance_args(
        LeaderBalanceReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public leaderBalance_args(leaderBalance_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public leaderBalance_args deepCopy() {
      return new leaderBalance_args(this);
    }

    public LeaderBalanceReq getReq() {
      return this.req;
    }

    public leaderBalance_args setReq(LeaderBalanceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((LeaderBalanceReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof leaderBalance_args))
        return false;
      leaderBalance_args that = (leaderBalance_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(leaderBalance_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new LeaderBalanceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("leaderBalance_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class leaderBalance_result implements TBase, java.io.Serializable, Cloneable, Comparable<leaderBalance_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("leaderBalance_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(leaderBalance_result.class, metaDataMap);
    }

    public leaderBalance_result() {
    }

    public leaderBalance_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public leaderBalance_result(leaderBalance_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public leaderBalance_result deepCopy() {
      return new leaderBalance_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public leaderBalance_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof leaderBalance_result))
        return false;
      leaderBalance_result that = (leaderBalance_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(leaderBalance_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("leaderBalance_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class regConfig_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("regConfig_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RegConfigReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RegConfigReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(regConfig_args.class, metaDataMap);
    }

    public regConfig_args() {
    }

    public regConfig_args(
        RegConfigReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public regConfig_args(regConfig_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public regConfig_args deepCopy() {
      return new regConfig_args(this);
    }

    public RegConfigReq getReq() {
      return this.req;
    }

    public regConfig_args setReq(RegConfigReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((RegConfigReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof regConfig_args))
        return false;
      regConfig_args that = (regConfig_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new RegConfigReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("regConfig_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class regConfig_result implements TBase, java.io.Serializable, Cloneable, Comparable<regConfig_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("regConfig_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(regConfig_result.class, metaDataMap);
    }

    public regConfig_result() {
    }

    public regConfig_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public regConfig_result(regConfig_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public regConfig_result deepCopy() {
      return new regConfig_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public regConfig_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof regConfig_result))
        return false;
      regConfig_result that = (regConfig_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(regConfig_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("regConfig_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getConfig_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getConfig_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetConfigReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetConfigReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getConfig_args.class, metaDataMap);
    }

    public getConfig_args() {
    }

    public getConfig_args(
        GetConfigReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConfig_args(getConfig_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getConfig_args deepCopy() {
      return new getConfig_args(this);
    }

    public GetConfigReq getReq() {
      return this.req;
    }

    public getConfig_args setReq(GetConfigReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetConfigReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getConfig_args))
        return false;
      getConfig_args that = (getConfig_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetConfigReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getConfig_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getConfig_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getConfig_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetConfigResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetConfigResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getConfig_result.class, metaDataMap);
    }

    public getConfig_result() {
    }

    public getConfig_result(
        GetConfigResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConfig_result(getConfig_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getConfig_result deepCopy() {
      return new getConfig_result(this);
    }

    public GetConfigResp getSuccess() {
      return this.success;
    }

    public getConfig_result setSuccess(GetConfigResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetConfigResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getConfig_result))
        return false;
      getConfig_result that = (getConfig_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetConfigResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getConfig_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setConfig_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setConfig_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public SetConfigReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, SetConfigReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(setConfig_args.class, metaDataMap);
    }

    public setConfig_args() {
    }

    public setConfig_args(
        SetConfigReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setConfig_args(setConfig_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public setConfig_args deepCopy() {
      return new setConfig_args(this);
    }

    public SetConfigReq getReq() {
      return this.req;
    }

    public setConfig_args setReq(SetConfigReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((SetConfigReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof setConfig_args))
        return false;
      setConfig_args that = (setConfig_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new SetConfigReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("setConfig_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setConfig_result implements TBase, java.io.Serializable, Cloneable, Comparable<setConfig_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("setConfig_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(setConfig_result.class, metaDataMap);
    }

    public setConfig_result() {
    }

    public setConfig_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setConfig_result(setConfig_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public setConfig_result deepCopy() {
      return new setConfig_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public setConfig_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof setConfig_result))
        return false;
      setConfig_result that = (setConfig_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(setConfig_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("setConfig_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listConfigs_args implements TBase, java.io.Serializable, Cloneable, Comparable<listConfigs_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listConfigs_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListConfigsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListConfigsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listConfigs_args.class, metaDataMap);
    }

    public listConfigs_args() {
    }

    public listConfigs_args(
        ListConfigsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listConfigs_args(listConfigs_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listConfigs_args deepCopy() {
      return new listConfigs_args(this);
    }

    public ListConfigsReq getReq() {
      return this.req;
    }

    public listConfigs_args setReq(ListConfigsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListConfigsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listConfigs_args))
        return false;
      listConfigs_args that = (listConfigs_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listConfigs_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListConfigsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listConfigs_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listConfigs_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("listConfigs_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListConfigsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListConfigsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listConfigs_result.class, metaDataMap);
    }

    public listConfigs_result() {
    }

    public listConfigs_result(
        ListConfigsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listConfigs_result(listConfigs_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listConfigs_result deepCopy() {
      return new listConfigs_result(this);
    }

    public ListConfigsResp getSuccess() {
      return this.success;
    }

    public listConfigs_result setSuccess(ListConfigsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListConfigsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listConfigs_result))
        return false;
      listConfigs_result that = (listConfigs_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListConfigsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listConfigs_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createSnapshot_args implements TBase, java.io.Serializable, Cloneable, Comparable<createSnapshot_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSnapshot_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateSnapshotReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateSnapshotReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSnapshot_args.class, metaDataMap);
    }

    public createSnapshot_args() {
    }

    public createSnapshot_args(
        CreateSnapshotReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSnapshot_args(createSnapshot_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createSnapshot_args deepCopy() {
      return new createSnapshot_args(this);
    }

    public CreateSnapshotReq getReq() {
      return this.req;
    }

    public createSnapshot_args setReq(CreateSnapshotReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateSnapshotReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createSnapshot_args))
        return false;
      createSnapshot_args that = (createSnapshot_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createSnapshot_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateSnapshotReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSnapshot_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createSnapshot_result implements TBase, java.io.Serializable, Cloneable, Comparable<createSnapshot_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSnapshot_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSnapshot_result.class, metaDataMap);
    }

    public createSnapshot_result() {
    }

    public createSnapshot_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSnapshot_result(createSnapshot_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createSnapshot_result deepCopy() {
      return new createSnapshot_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public createSnapshot_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createSnapshot_result))
        return false;
      createSnapshot_result that = (createSnapshot_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createSnapshot_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSnapshot_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropSnapshot_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropSnapshot_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropSnapshot_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropSnapshotReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropSnapshotReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropSnapshot_args.class, metaDataMap);
    }

    public dropSnapshot_args() {
    }

    public dropSnapshot_args(
        DropSnapshotReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropSnapshot_args(dropSnapshot_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropSnapshot_args deepCopy() {
      return new dropSnapshot_args(this);
    }

    public DropSnapshotReq getReq() {
      return this.req;
    }

    public dropSnapshot_args setReq(DropSnapshotReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropSnapshotReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropSnapshot_args))
        return false;
      dropSnapshot_args that = (dropSnapshot_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropSnapshot_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropSnapshotReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropSnapshot_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropSnapshot_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropSnapshot_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropSnapshot_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropSnapshot_result.class, metaDataMap);
    }

    public dropSnapshot_result() {
    }

    public dropSnapshot_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropSnapshot_result(dropSnapshot_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropSnapshot_result deepCopy() {
      return new dropSnapshot_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropSnapshot_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropSnapshot_result))
        return false;
      dropSnapshot_result that = (dropSnapshot_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropSnapshot_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropSnapshot_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listSnapshots_args implements TBase, java.io.Serializable, Cloneable, Comparable<listSnapshots_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSnapshots_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListSnapshotsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSnapshotsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSnapshots_args.class, metaDataMap);
    }

    public listSnapshots_args() {
    }

    public listSnapshots_args(
        ListSnapshotsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSnapshots_args(listSnapshots_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listSnapshots_args deepCopy() {
      return new listSnapshots_args(this);
    }

    public ListSnapshotsReq getReq() {
      return this.req;
    }

    public listSnapshots_args setReq(ListSnapshotsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListSnapshotsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listSnapshots_args))
        return false;
      listSnapshots_args that = (listSnapshots_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listSnapshots_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListSnapshotsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSnapshots_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listSnapshots_result implements TBase, java.io.Serializable, Cloneable, Comparable<listSnapshots_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSnapshots_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListSnapshotsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSnapshotsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSnapshots_result.class, metaDataMap);
    }

    public listSnapshots_result() {
    }

    public listSnapshots_result(
        ListSnapshotsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSnapshots_result(listSnapshots_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listSnapshots_result deepCopy() {
      return new listSnapshots_result(this);
    }

    public ListSnapshotsResp getSuccess() {
      return this.success;
    }

    public listSnapshots_result setSuccess(ListSnapshotsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListSnapshotsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listSnapshots_result))
        return false;
      listSnapshots_result that = (listSnapshots_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listSnapshots_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListSnapshotsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSnapshots_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class runAdminJob_args implements TBase, java.io.Serializable, Cloneable, Comparable<runAdminJob_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("runAdminJob_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AdminJobReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AdminJobReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(runAdminJob_args.class, metaDataMap);
    }

    public runAdminJob_args() {
    }

    public runAdminJob_args(
        AdminJobReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public runAdminJob_args(runAdminJob_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public runAdminJob_args deepCopy() {
      return new runAdminJob_args(this);
    }

    public AdminJobReq getReq() {
      return this.req;
    }

    public runAdminJob_args setReq(AdminJobReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AdminJobReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof runAdminJob_args))
        return false;
      runAdminJob_args that = (runAdminJob_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(runAdminJob_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AdminJobReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("runAdminJob_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class runAdminJob_result implements TBase, java.io.Serializable, Cloneable, Comparable<runAdminJob_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("runAdminJob_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public AdminJobResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AdminJobResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(runAdminJob_result.class, metaDataMap);
    }

    public runAdminJob_result() {
    }

    public runAdminJob_result(
        AdminJobResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public runAdminJob_result(runAdminJob_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public runAdminJob_result deepCopy() {
      return new runAdminJob_result(this);
    }

    public AdminJobResp getSuccess() {
      return this.success;
    }

    public runAdminJob_result setSuccess(AdminJobResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((AdminJobResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof runAdminJob_result))
        return false;
      runAdminJob_result that = (runAdminJob_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(runAdminJob_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new AdminJobResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("runAdminJob_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addZone_args implements TBase, java.io.Serializable, Cloneable, Comparable<addZone_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("addZone_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AddZoneReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AddZoneReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(addZone_args.class, metaDataMap);
    }

    public addZone_args() {
    }

    public addZone_args(
        AddZoneReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addZone_args(addZone_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public addZone_args deepCopy() {
      return new addZone_args(this);
    }

    public AddZoneReq getReq() {
      return this.req;
    }

    public addZone_args setReq(AddZoneReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AddZoneReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof addZone_args))
        return false;
      addZone_args that = (addZone_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(addZone_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AddZoneReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("addZone_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addZone_result implements TBase, java.io.Serializable, Cloneable, Comparable<addZone_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("addZone_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(addZone_result.class, metaDataMap);
    }

    public addZone_result() {
    }

    public addZone_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addZone_result(addZone_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public addZone_result deepCopy() {
      return new addZone_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public addZone_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof addZone_result))
        return false;
      addZone_result that = (addZone_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(addZone_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("addZone_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropZone_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropZone_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropZone_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropZoneReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropZoneReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropZone_args.class, metaDataMap);
    }

    public dropZone_args() {
    }

    public dropZone_args(
        DropZoneReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropZone_args(dropZone_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropZone_args deepCopy() {
      return new dropZone_args(this);
    }

    public DropZoneReq getReq() {
      return this.req;
    }

    public dropZone_args setReq(DropZoneReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropZoneReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropZone_args))
        return false;
      dropZone_args that = (dropZone_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropZone_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropZoneReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropZone_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropZone_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropZone_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropZone_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropZone_result.class, metaDataMap);
    }

    public dropZone_result() {
    }

    public dropZone_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropZone_result(dropZone_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropZone_result deepCopy() {
      return new dropZone_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropZone_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropZone_result))
        return false;
      dropZone_result that = (dropZone_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropZone_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropZone_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addHostIntoZone_args implements TBase, java.io.Serializable, Cloneable, Comparable<addHostIntoZone_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("addHostIntoZone_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AddHostIntoZoneReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AddHostIntoZoneReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(addHostIntoZone_args.class, metaDataMap);
    }

    public addHostIntoZone_args() {
    }

    public addHostIntoZone_args(
        AddHostIntoZoneReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addHostIntoZone_args(addHostIntoZone_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public addHostIntoZone_args deepCopy() {
      return new addHostIntoZone_args(this);
    }

    public AddHostIntoZoneReq getReq() {
      return this.req;
    }

    public addHostIntoZone_args setReq(AddHostIntoZoneReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AddHostIntoZoneReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof addHostIntoZone_args))
        return false;
      addHostIntoZone_args that = (addHostIntoZone_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(addHostIntoZone_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AddHostIntoZoneReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("addHostIntoZone_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addHostIntoZone_result implements TBase, java.io.Serializable, Cloneable, Comparable<addHostIntoZone_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("addHostIntoZone_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(addHostIntoZone_result.class, metaDataMap);
    }

    public addHostIntoZone_result() {
    }

    public addHostIntoZone_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addHostIntoZone_result(addHostIntoZone_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public addHostIntoZone_result deepCopy() {
      return new addHostIntoZone_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public addHostIntoZone_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof addHostIntoZone_result))
        return false;
      addHostIntoZone_result that = (addHostIntoZone_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(addHostIntoZone_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("addHostIntoZone_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropHostFromZone_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropHostFromZone_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropHostFromZone_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropHostFromZoneReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropHostFromZoneReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropHostFromZone_args.class, metaDataMap);
    }

    public dropHostFromZone_args() {
    }

    public dropHostFromZone_args(
        DropHostFromZoneReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropHostFromZone_args(dropHostFromZone_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropHostFromZone_args deepCopy() {
      return new dropHostFromZone_args(this);
    }

    public DropHostFromZoneReq getReq() {
      return this.req;
    }

    public dropHostFromZone_args setReq(DropHostFromZoneReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropHostFromZoneReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropHostFromZone_args))
        return false;
      dropHostFromZone_args that = (dropHostFromZone_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropHostFromZone_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropHostFromZoneReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropHostFromZone_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropHostFromZone_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropHostFromZone_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropHostFromZone_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropHostFromZone_result.class, metaDataMap);
    }

    public dropHostFromZone_result() {
    }

    public dropHostFromZone_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropHostFromZone_result(dropHostFromZone_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropHostFromZone_result deepCopy() {
      return new dropHostFromZone_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropHostFromZone_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropHostFromZone_result))
        return false;
      dropHostFromZone_result that = (dropHostFromZone_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropHostFromZone_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropHostFromZone_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getZone_args implements TBase, java.io.Serializable, Cloneable, Comparable<getZone_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getZone_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetZoneReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetZoneReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getZone_args.class, metaDataMap);
    }

    public getZone_args() {
    }

    public getZone_args(
        GetZoneReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getZone_args(getZone_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getZone_args deepCopy() {
      return new getZone_args(this);
    }

    public GetZoneReq getReq() {
      return this.req;
    }

    public getZone_args setReq(GetZoneReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetZoneReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getZone_args))
        return false;
      getZone_args that = (getZone_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getZone_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetZoneReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getZone_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getZone_result implements TBase, java.io.Serializable, Cloneable, Comparable<getZone_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getZone_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetZoneResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetZoneResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getZone_result.class, metaDataMap);
    }

    public getZone_result() {
    }

    public getZone_result(
        GetZoneResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getZone_result(getZone_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getZone_result deepCopy() {
      return new getZone_result(this);
    }

    public GetZoneResp getSuccess() {
      return this.success;
    }

    public getZone_result setSuccess(GetZoneResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetZoneResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getZone_result))
        return false;
      getZone_result that = (getZone_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getZone_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetZoneResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getZone_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listZones_args implements TBase, java.io.Serializable, Cloneable, Comparable<listZones_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listZones_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListZonesReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListZonesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listZones_args.class, metaDataMap);
    }

    public listZones_args() {
    }

    public listZones_args(
        ListZonesReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listZones_args(listZones_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listZones_args deepCopy() {
      return new listZones_args(this);
    }

    public ListZonesReq getReq() {
      return this.req;
    }

    public listZones_args setReq(ListZonesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListZonesReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listZones_args))
        return false;
      listZones_args that = (listZones_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listZones_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListZonesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listZones_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listZones_result implements TBase, java.io.Serializable, Cloneable, Comparable<listZones_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listZones_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListZonesResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListZonesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listZones_result.class, metaDataMap);
    }

    public listZones_result() {
    }

    public listZones_result(
        ListZonesResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listZones_result(listZones_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listZones_result deepCopy() {
      return new listZones_result(this);
    }

    public ListZonesResp getSuccess() {
      return this.success;
    }

    public listZones_result setSuccess(ListZonesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListZonesResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listZones_result))
        return false;
      listZones_result that = (listZones_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listZones_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListZonesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listZones_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addGroup_args implements TBase, java.io.Serializable, Cloneable, Comparable<addGroup_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("addGroup_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AddGroupReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AddGroupReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(addGroup_args.class, metaDataMap);
    }

    public addGroup_args() {
    }

    public addGroup_args(
        AddGroupReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addGroup_args(addGroup_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public addGroup_args deepCopy() {
      return new addGroup_args(this);
    }

    public AddGroupReq getReq() {
      return this.req;
    }

    public addGroup_args setReq(AddGroupReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AddGroupReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof addGroup_args))
        return false;
      addGroup_args that = (addGroup_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(addGroup_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AddGroupReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("addGroup_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addGroup_result implements TBase, java.io.Serializable, Cloneable, Comparable<addGroup_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("addGroup_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(addGroup_result.class, metaDataMap);
    }

    public addGroup_result() {
    }

    public addGroup_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addGroup_result(addGroup_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public addGroup_result deepCopy() {
      return new addGroup_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public addGroup_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof addGroup_result))
        return false;
      addGroup_result that = (addGroup_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(addGroup_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("addGroup_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropGroup_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropGroup_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropGroup_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropGroupReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropGroupReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropGroup_args.class, metaDataMap);
    }

    public dropGroup_args() {
    }

    public dropGroup_args(
        DropGroupReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropGroup_args(dropGroup_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropGroup_args deepCopy() {
      return new dropGroup_args(this);
    }

    public DropGroupReq getReq() {
      return this.req;
    }

    public dropGroup_args setReq(DropGroupReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropGroupReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropGroup_args))
        return false;
      dropGroup_args that = (dropGroup_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropGroup_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropGroupReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropGroup_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropGroup_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropGroup_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropGroup_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropGroup_result.class, metaDataMap);
    }

    public dropGroup_result() {
    }

    public dropGroup_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropGroup_result(dropGroup_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropGroup_result deepCopy() {
      return new dropGroup_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropGroup_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropGroup_result))
        return false;
      dropGroup_result that = (dropGroup_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropGroup_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropGroup_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addZoneIntoGroup_args implements TBase, java.io.Serializable, Cloneable, Comparable<addZoneIntoGroup_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("addZoneIntoGroup_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AddZoneIntoGroupReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AddZoneIntoGroupReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(addZoneIntoGroup_args.class, metaDataMap);
    }

    public addZoneIntoGroup_args() {
    }

    public addZoneIntoGroup_args(
        AddZoneIntoGroupReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addZoneIntoGroup_args(addZoneIntoGroup_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public addZoneIntoGroup_args deepCopy() {
      return new addZoneIntoGroup_args(this);
    }

    public AddZoneIntoGroupReq getReq() {
      return this.req;
    }

    public addZoneIntoGroup_args setReq(AddZoneIntoGroupReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AddZoneIntoGroupReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof addZoneIntoGroup_args))
        return false;
      addZoneIntoGroup_args that = (addZoneIntoGroup_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(addZoneIntoGroup_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AddZoneIntoGroupReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("addZoneIntoGroup_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addZoneIntoGroup_result implements TBase, java.io.Serializable, Cloneable, Comparable<addZoneIntoGroup_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("addZoneIntoGroup_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(addZoneIntoGroup_result.class, metaDataMap);
    }

    public addZoneIntoGroup_result() {
    }

    public addZoneIntoGroup_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addZoneIntoGroup_result(addZoneIntoGroup_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public addZoneIntoGroup_result deepCopy() {
      return new addZoneIntoGroup_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public addZoneIntoGroup_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof addZoneIntoGroup_result))
        return false;
      addZoneIntoGroup_result that = (addZoneIntoGroup_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(addZoneIntoGroup_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("addZoneIntoGroup_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropZoneFromGroup_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropZoneFromGroup_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropZoneFromGroup_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropZoneFromGroupReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropZoneFromGroupReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropZoneFromGroup_args.class, metaDataMap);
    }

    public dropZoneFromGroup_args() {
    }

    public dropZoneFromGroup_args(
        DropZoneFromGroupReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropZoneFromGroup_args(dropZoneFromGroup_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropZoneFromGroup_args deepCopy() {
      return new dropZoneFromGroup_args(this);
    }

    public DropZoneFromGroupReq getReq() {
      return this.req;
    }

    public dropZoneFromGroup_args setReq(DropZoneFromGroupReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropZoneFromGroupReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropZoneFromGroup_args))
        return false;
      dropZoneFromGroup_args that = (dropZoneFromGroup_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropZoneFromGroup_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropZoneFromGroupReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropZoneFromGroup_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropZoneFromGroup_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropZoneFromGroup_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropZoneFromGroup_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropZoneFromGroup_result.class, metaDataMap);
    }

    public dropZoneFromGroup_result() {
    }

    public dropZoneFromGroup_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropZoneFromGroup_result(dropZoneFromGroup_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropZoneFromGroup_result deepCopy() {
      return new dropZoneFromGroup_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropZoneFromGroup_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropZoneFromGroup_result))
        return false;
      dropZoneFromGroup_result that = (dropZoneFromGroup_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropZoneFromGroup_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropZoneFromGroup_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getGroup_args implements TBase, java.io.Serializable, Cloneable, Comparable<getGroup_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getGroup_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetGroupReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetGroupReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getGroup_args.class, metaDataMap);
    }

    public getGroup_args() {
    }

    public getGroup_args(
        GetGroupReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getGroup_args(getGroup_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getGroup_args deepCopy() {
      return new getGroup_args(this);
    }

    public GetGroupReq getReq() {
      return this.req;
    }

    public getGroup_args setReq(GetGroupReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetGroupReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getGroup_args))
        return false;
      getGroup_args that = (getGroup_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getGroup_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetGroupReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getGroup_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getGroup_result implements TBase, java.io.Serializable, Cloneable, Comparable<getGroup_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getGroup_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetGroupResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetGroupResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getGroup_result.class, metaDataMap);
    }

    public getGroup_result() {
    }

    public getGroup_result(
        GetGroupResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getGroup_result(getGroup_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getGroup_result deepCopy() {
      return new getGroup_result(this);
    }

    public GetGroupResp getSuccess() {
      return this.success;
    }

    public getGroup_result setSuccess(GetGroupResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetGroupResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getGroup_result))
        return false;
      getGroup_result that = (getGroup_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getGroup_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetGroupResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getGroup_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listGroups_args implements TBase, java.io.Serializable, Cloneable, Comparable<listGroups_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listGroups_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListGroupsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListGroupsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listGroups_args.class, metaDataMap);
    }

    public listGroups_args() {
    }

    public listGroups_args(
        ListGroupsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listGroups_args(listGroups_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listGroups_args deepCopy() {
      return new listGroups_args(this);
    }

    public ListGroupsReq getReq() {
      return this.req;
    }

    public listGroups_args setReq(ListGroupsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListGroupsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listGroups_args))
        return false;
      listGroups_args that = (listGroups_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listGroups_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListGroupsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listGroups_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listGroups_result implements TBase, java.io.Serializable, Cloneable, Comparable<listGroups_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listGroups_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListGroupsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListGroupsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listGroups_result.class, metaDataMap);
    }

    public listGroups_result() {
    }

    public listGroups_result(
        ListGroupsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listGroups_result(listGroups_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listGroups_result deepCopy() {
      return new listGroups_result(this);
    }

    public ListGroupsResp getSuccess() {
      return this.success;
    }

    public listGroups_result setSuccess(ListGroupsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListGroupsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listGroups_result))
        return false;
      listGroups_result that = (listGroups_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listGroups_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListGroupsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listGroups_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createBackup_args implements TBase, java.io.Serializable, Cloneable, Comparable<createBackup_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createBackup_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateBackupReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateBackupReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createBackup_args.class, metaDataMap);
    }

    public createBackup_args() {
    }

    public createBackup_args(
        CreateBackupReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createBackup_args(createBackup_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createBackup_args deepCopy() {
      return new createBackup_args(this);
    }

    public CreateBackupReq getReq() {
      return this.req;
    }

    public createBackup_args setReq(CreateBackupReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateBackupReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createBackup_args))
        return false;
      createBackup_args that = (createBackup_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createBackup_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateBackupReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createBackup_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createBackup_result implements TBase, java.io.Serializable, Cloneable, Comparable<createBackup_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createBackup_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public CreateBackupResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateBackupResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createBackup_result.class, metaDataMap);
    }

    public createBackup_result() {
    }

    public createBackup_result(
        CreateBackupResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createBackup_result(createBackup_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createBackup_result deepCopy() {
      return new createBackup_result(this);
    }

    public CreateBackupResp getSuccess() {
      return this.success;
    }

    public createBackup_result setSuccess(CreateBackupResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((CreateBackupResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createBackup_result))
        return false;
      createBackup_result that = (createBackup_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createBackup_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new CreateBackupResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createBackup_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class restoreMeta_args implements TBase, java.io.Serializable, Cloneable, Comparable<restoreMeta_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("restoreMeta_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RestoreMetaReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RestoreMetaReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(restoreMeta_args.class, metaDataMap);
    }

    public restoreMeta_args() {
    }

    public restoreMeta_args(
        RestoreMetaReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public restoreMeta_args(restoreMeta_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public restoreMeta_args deepCopy() {
      return new restoreMeta_args(this);
    }

    public RestoreMetaReq getReq() {
      return this.req;
    }

    public restoreMeta_args setReq(RestoreMetaReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((RestoreMetaReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof restoreMeta_args))
        return false;
      restoreMeta_args that = (restoreMeta_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(restoreMeta_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new RestoreMetaReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("restoreMeta_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class restoreMeta_result implements TBase, java.io.Serializable, Cloneable, Comparable<restoreMeta_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("restoreMeta_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(restoreMeta_result.class, metaDataMap);
    }

    public restoreMeta_result() {
    }

    public restoreMeta_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public restoreMeta_result(restoreMeta_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public restoreMeta_result deepCopy() {
      return new restoreMeta_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public restoreMeta_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof restoreMeta_result))
        return false;
      restoreMeta_result that = (restoreMeta_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(restoreMeta_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("restoreMeta_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addListener_args implements TBase, java.io.Serializable, Cloneable, Comparable<addListener_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("addListener_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public AddListenerReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, AddListenerReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(addListener_args.class, metaDataMap);
    }

    public addListener_args() {
    }

    public addListener_args(
        AddListenerReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addListener_args(addListener_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public addListener_args deepCopy() {
      return new addListener_args(this);
    }

    public AddListenerReq getReq() {
      return this.req;
    }

    public addListener_args setReq(AddListenerReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((AddListenerReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof addListener_args))
        return false;
      addListener_args that = (addListener_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(addListener_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new AddListenerReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("addListener_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addListener_result implements TBase, java.io.Serializable, Cloneable, Comparable<addListener_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("addListener_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(addListener_result.class, metaDataMap);
    }

    public addListener_result() {
    }

    public addListener_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addListener_result(addListener_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public addListener_result deepCopy() {
      return new addListener_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public addListener_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof addListener_result))
        return false;
      addListener_result that = (addListener_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(addListener_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("addListener_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class removeListener_args implements TBase, java.io.Serializable, Cloneable, Comparable<removeListener_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeListener_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RemoveListenerReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RemoveListenerReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(removeListener_args.class, metaDataMap);
    }

    public removeListener_args() {
    }

    public removeListener_args(
        RemoveListenerReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeListener_args(removeListener_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public removeListener_args deepCopy() {
      return new removeListener_args(this);
    }

    public RemoveListenerReq getReq() {
      return this.req;
    }

    public removeListener_args setReq(RemoveListenerReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((RemoveListenerReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof removeListener_args))
        return false;
      removeListener_args that = (removeListener_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(removeListener_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new RemoveListenerReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("removeListener_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class removeListener_result implements TBase, java.io.Serializable, Cloneable, Comparable<removeListener_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeListener_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(removeListener_result.class, metaDataMap);
    }

    public removeListener_result() {
    }

    public removeListener_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeListener_result(removeListener_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public removeListener_result deepCopy() {
      return new removeListener_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public removeListener_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof removeListener_result))
        return false;
      removeListener_result that = (removeListener_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(removeListener_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("removeListener_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listListener_args implements TBase, java.io.Serializable, Cloneable, Comparable<listListener_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listListener_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListListenerReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListListenerReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listListener_args.class, metaDataMap);
    }

    public listListener_args() {
    }

    public listListener_args(
        ListListenerReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listListener_args(listListener_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listListener_args deepCopy() {
      return new listListener_args(this);
    }

    public ListListenerReq getReq() {
      return this.req;
    }

    public listListener_args setReq(ListListenerReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListListenerReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listListener_args))
        return false;
      listListener_args that = (listListener_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listListener_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListListenerReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listListener_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listListener_result implements TBase, java.io.Serializable, Cloneable, Comparable<listListener_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listListener_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListListenerResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListListenerResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listListener_result.class, metaDataMap);
    }

    public listListener_result() {
    }

    public listListener_result(
        ListListenerResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listListener_result(listListener_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listListener_result deepCopy() {
      return new listListener_result(this);
    }

    public ListListenerResp getSuccess() {
      return this.success;
    }

    public listListener_result setSuccess(ListListenerResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListListenerResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listListener_result))
        return false;
      listListener_result that = (listListener_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listListener_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListListenerResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listListener_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getStatis_args implements TBase, java.io.Serializable, Cloneable, Comparable<getStatis_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getStatis_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetStatisReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetStatisReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getStatis_args.class, metaDataMap);
    }

    public getStatis_args() {
    }

    public getStatis_args(
        GetStatisReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getStatis_args(getStatis_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getStatis_args deepCopy() {
      return new getStatis_args(this);
    }

    public GetStatisReq getReq() {
      return this.req;
    }

    public getStatis_args setReq(GetStatisReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetStatisReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getStatis_args))
        return false;
      getStatis_args that = (getStatis_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getStatis_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetStatisReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getStatis_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getStatis_result implements TBase, java.io.Serializable, Cloneable, Comparable<getStatis_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getStatis_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetStatisResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetStatisResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getStatis_result.class, metaDataMap);
    }

    public getStatis_result() {
    }

    public getStatis_result(
        GetStatisResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getStatis_result(getStatis_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getStatis_result deepCopy() {
      return new getStatis_result(this);
    }

    public GetStatisResp getSuccess() {
      return this.success;
    }

    public getStatis_result setSuccess(GetStatisResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetStatisResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getStatis_result))
        return false;
      getStatis_result that = (getStatis_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getStatis_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetStatisResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getStatis_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class signInFTService_args implements TBase, java.io.Serializable, Cloneable, Comparable<signInFTService_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("signInFTService_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public SignInFTServiceReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, SignInFTServiceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(signInFTService_args.class, metaDataMap);
    }

    public signInFTService_args() {
    }

    public signInFTService_args(
        SignInFTServiceReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public signInFTService_args(signInFTService_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public signInFTService_args deepCopy() {
      return new signInFTService_args(this);
    }

    public SignInFTServiceReq getReq() {
      return this.req;
    }

    public signInFTService_args setReq(SignInFTServiceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((SignInFTServiceReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof signInFTService_args))
        return false;
      signInFTService_args that = (signInFTService_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(signInFTService_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new SignInFTServiceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("signInFTService_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class signInFTService_result implements TBase, java.io.Serializable, Cloneable, Comparable<signInFTService_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("signInFTService_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(signInFTService_result.class, metaDataMap);
    }

    public signInFTService_result() {
    }

    public signInFTService_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public signInFTService_result(signInFTService_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public signInFTService_result deepCopy() {
      return new signInFTService_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public signInFTService_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof signInFTService_result))
        return false;
      signInFTService_result that = (signInFTService_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(signInFTService_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("signInFTService_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class signOutFTService_args implements TBase, java.io.Serializable, Cloneable, Comparable<signOutFTService_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("signOutFTService_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public SignOutFTServiceReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, SignOutFTServiceReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(signOutFTService_args.class, metaDataMap);
    }

    public signOutFTService_args() {
    }

    public signOutFTService_args(
        SignOutFTServiceReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public signOutFTService_args(signOutFTService_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public signOutFTService_args deepCopy() {
      return new signOutFTService_args(this);
    }

    public SignOutFTServiceReq getReq() {
      return this.req;
    }

    public signOutFTService_args setReq(SignOutFTServiceReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((SignOutFTServiceReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof signOutFTService_args))
        return false;
      signOutFTService_args that = (signOutFTService_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(signOutFTService_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new SignOutFTServiceReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("signOutFTService_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class signOutFTService_result implements TBase, java.io.Serializable, Cloneable, Comparable<signOutFTService_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("signOutFTService_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(signOutFTService_result.class, metaDataMap);
    }

    public signOutFTService_result() {
    }

    public signOutFTService_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public signOutFTService_result(signOutFTService_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public signOutFTService_result deepCopy() {
      return new signOutFTService_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public signOutFTService_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof signOutFTService_result))
        return false;
      signOutFTService_result that = (signOutFTService_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(signOutFTService_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("signOutFTService_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listFTClients_args implements TBase, java.io.Serializable, Cloneable, Comparable<listFTClients_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listFTClients_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListFTClientsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListFTClientsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listFTClients_args.class, metaDataMap);
    }

    public listFTClients_args() {
    }

    public listFTClients_args(
        ListFTClientsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listFTClients_args(listFTClients_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listFTClients_args deepCopy() {
      return new listFTClients_args(this);
    }

    public ListFTClientsReq getReq() {
      return this.req;
    }

    public listFTClients_args setReq(ListFTClientsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListFTClientsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listFTClients_args))
        return false;
      listFTClients_args that = (listFTClients_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listFTClients_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListFTClientsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listFTClients_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listFTClients_result implements TBase, java.io.Serializable, Cloneable, Comparable<listFTClients_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listFTClients_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListFTClientsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListFTClientsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listFTClients_result.class, metaDataMap);
    }

    public listFTClients_result() {
    }

    public listFTClients_result(
        ListFTClientsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listFTClients_result(listFTClients_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listFTClients_result deepCopy() {
      return new listFTClients_result(this);
    }

    public ListFTClientsResp getSuccess() {
      return this.success;
    }

    public listFTClients_result setSuccess(ListFTClientsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListFTClientsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listFTClients_result))
        return false;
      listFTClients_result that = (listFTClients_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listFTClients_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListFTClientsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listFTClients_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createFTIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<createFTIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createFTIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateFTIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateFTIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createFTIndex_args.class, metaDataMap);
    }

    public createFTIndex_args() {
    }

    public createFTIndex_args(
        CreateFTIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createFTIndex_args(createFTIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createFTIndex_args deepCopy() {
      return new createFTIndex_args(this);
    }

    public CreateFTIndexReq getReq() {
      return this.req;
    }

    public createFTIndex_args setReq(CreateFTIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateFTIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createFTIndex_args))
        return false;
      createFTIndex_args that = (createFTIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createFTIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateFTIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createFTIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createFTIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<createFTIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createFTIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createFTIndex_result.class, metaDataMap);
    }

    public createFTIndex_result() {
    }

    public createFTIndex_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createFTIndex_result(createFTIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createFTIndex_result deepCopy() {
      return new createFTIndex_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public createFTIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createFTIndex_result))
        return false;
      createFTIndex_result that = (createFTIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(createFTIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createFTIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropFTIndex_args implements TBase, java.io.Serializable, Cloneable, Comparable<dropFTIndex_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropFTIndex_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public DropFTIndexReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, DropFTIndexReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropFTIndex_args.class, metaDataMap);
    }

    public dropFTIndex_args() {
    }

    public dropFTIndex_args(
        DropFTIndexReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropFTIndex_args(dropFTIndex_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public dropFTIndex_args deepCopy() {
      return new dropFTIndex_args(this);
    }

    public DropFTIndexReq getReq() {
      return this.req;
    }

    public dropFTIndex_args setReq(DropFTIndexReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((DropFTIndexReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropFTIndex_args))
        return false;
      dropFTIndex_args that = (dropFTIndex_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(dropFTIndex_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new DropFTIndexReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropFTIndex_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropFTIndex_result implements TBase, java.io.Serializable, Cloneable, Comparable<dropFTIndex_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropFTIndex_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(dropFTIndex_result.class, metaDataMap);
    }

    public dropFTIndex_result() {
    }

    public dropFTIndex_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropFTIndex_result(dropFTIndex_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public dropFTIndex_result deepCopy() {
      return new dropFTIndex_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public dropFTIndex_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof dropFTIndex_result))
        return false;
      dropFTIndex_result that = (dropFTIndex_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(dropFTIndex_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("dropFTIndex_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listFTIndexes_args implements TBase, java.io.Serializable, Cloneable, Comparable<listFTIndexes_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listFTIndexes_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListFTIndexesReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListFTIndexesReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listFTIndexes_args.class, metaDataMap);
    }

    public listFTIndexes_args() {
    }

    public listFTIndexes_args(
        ListFTIndexesReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listFTIndexes_args(listFTIndexes_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listFTIndexes_args deepCopy() {
      return new listFTIndexes_args(this);
    }

    public ListFTIndexesReq getReq() {
      return this.req;
    }

    public listFTIndexes_args setReq(ListFTIndexesReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListFTIndexesReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listFTIndexes_args))
        return false;
      listFTIndexes_args that = (listFTIndexes_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listFTIndexes_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListFTIndexesReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listFTIndexes_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listFTIndexes_result implements TBase, java.io.Serializable, Cloneable, Comparable<listFTIndexes_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listFTIndexes_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListFTIndexesResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListFTIndexesResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listFTIndexes_result.class, metaDataMap);
    }

    public listFTIndexes_result() {
    }

    public listFTIndexes_result(
        ListFTIndexesResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listFTIndexes_result(listFTIndexes_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listFTIndexes_result deepCopy() {
      return new listFTIndexes_result(this);
    }

    public ListFTIndexesResp getSuccess() {
      return this.success;
    }

    public listFTIndexes_result setSuccess(ListFTIndexesResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListFTIndexesResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listFTIndexes_result))
        return false;
      listFTIndexes_result that = (listFTIndexes_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listFTIndexes_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListFTIndexesResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listFTIndexes_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createSession_args implements TBase, java.io.Serializable, Cloneable, Comparable<createSession_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createSession_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public CreateSessionReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateSessionReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSession_args.class, metaDataMap);
    }

    public createSession_args() {
    }

    public createSession_args(
        CreateSessionReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSession_args(createSession_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public createSession_args deepCopy() {
      return new createSession_args(this);
    }

    public CreateSessionReq getReq() {
      return this.req;
    }

    public createSession_args setReq(CreateSessionReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((CreateSessionReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createSession_args))
        return false;
      createSession_args that = (createSession_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(createSession_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new CreateSessionReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSession_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createSession_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("createSession_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public CreateSessionResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CreateSessionResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(createSession_result.class, metaDataMap);
    }

    public createSession_result() {
    }

    public createSession_result(
        CreateSessionResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createSession_result(createSession_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public createSession_result deepCopy() {
      return new createSession_result(this);
    }

    public CreateSessionResp getSuccess() {
      return this.success;
    }

    public createSession_result setSuccess(CreateSessionResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((CreateSessionResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof createSession_result))
        return false;
      createSession_result that = (createSession_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new CreateSessionResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("createSession_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class updateSessions_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("updateSessions_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public UpdateSessionsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, UpdateSessionsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(updateSessions_args.class, metaDataMap);
    }

    public updateSessions_args() {
    }

    public updateSessions_args(
        UpdateSessionsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public updateSessions_args(updateSessions_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public updateSessions_args deepCopy() {
      return new updateSessions_args(this);
    }

    public UpdateSessionsReq getReq() {
      return this.req;
    }

    public updateSessions_args setReq(UpdateSessionsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((UpdateSessionsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof updateSessions_args))
        return false;
      updateSessions_args that = (updateSessions_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new UpdateSessionsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("updateSessions_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class updateSessions_result implements TBase, java.io.Serializable, Cloneable, Comparable<updateSessions_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("updateSessions_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public UpdateSessionsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, UpdateSessionsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(updateSessions_result.class, metaDataMap);
    }

    public updateSessions_result() {
    }

    public updateSessions_result(
        UpdateSessionsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public updateSessions_result(updateSessions_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public updateSessions_result deepCopy() {
      return new updateSessions_result(this);
    }

    public UpdateSessionsResp getSuccess() {
      return this.success;
    }

    public updateSessions_result setSuccess(UpdateSessionsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((UpdateSessionsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof updateSessions_result))
        return false;
      updateSessions_result that = (updateSessions_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(updateSessions_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new UpdateSessionsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("updateSessions_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listSessions_args implements TBase, java.io.Serializable, Cloneable, Comparable<listSessions_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listSessions_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListSessionsReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSessionsReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSessions_args.class, metaDataMap);
    }

    public listSessions_args() {
    }

    public listSessions_args(
        ListSessionsReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSessions_args(listSessions_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listSessions_args deepCopy() {
      return new listSessions_args(this);
    }

    public ListSessionsReq getReq() {
      return this.req;
    }

    public listSessions_args setReq(ListSessionsReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListSessionsReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listSessions_args))
        return false;
      listSessions_args that = (listSessions_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listSessions_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListSessionsReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSessions_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listSessions_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("listSessions_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListSessionsResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListSessionsResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listSessions_result.class, metaDataMap);
    }

    public listSessions_result() {
    }

    public listSessions_result(
        ListSessionsResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listSessions_result(listSessions_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listSessions_result deepCopy() {
      return new listSessions_result(this);
    }

    public ListSessionsResp getSuccess() {
      return this.success;
    }

    public listSessions_result setSuccess(ListSessionsResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListSessionsResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listSessions_result))
        return false;
      listSessions_result that = (listSessions_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListSessionsResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listSessions_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getSession_args implements TBase, java.io.Serializable, Cloneable, Comparable<getSession_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getSession_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetSessionReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetSessionReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getSession_args.class, metaDataMap);
    }

    public getSession_args() {
    }

    public getSession_args(
        GetSessionReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getSession_args(getSession_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getSession_args deepCopy() {
      return new getSession_args(this);
    }

    public GetSessionReq getReq() {
      return this.req;
    }

    public getSession_args setReq(GetSessionReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetSessionReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getSession_args))
        return false;
      getSession_args that = (getSession_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getSession_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetSessionReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getSession_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getSession_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getSession_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetSessionResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetSessionResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getSession_result.class, metaDataMap);
    }

    public getSession_result() {
    }

    public getSession_result(
        GetSessionResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getSession_result(getSession_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getSession_result deepCopy() {
      return new getSession_result(this);
    }

    public GetSessionResp getSuccess() {
      return this.success;
    }

    public getSession_result setSuccess(GetSessionResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetSessionResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getSession_result))
        return false;
      getSession_result that = (getSession_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetSessionResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getSession_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class removeSession_args implements TBase, java.io.Serializable, Cloneable, Comparable<removeSession_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeSession_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public RemoveSessionReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, RemoveSessionReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(removeSession_args.class, metaDataMap);
    }

    public removeSession_args() {
    }

    public removeSession_args(
        RemoveSessionReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeSession_args(removeSession_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public removeSession_args deepCopy() {
      return new removeSession_args(this);
    }

    public RemoveSessionReq getReq() {
      return this.req;
    }

    public removeSession_args setReq(RemoveSessionReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((RemoveSessionReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof removeSession_args))
        return false;
      removeSession_args that = (removeSession_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(removeSession_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new RemoveSessionReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("removeSession_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class removeSession_result implements TBase, java.io.Serializable, Cloneable, Comparable<removeSession_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeSession_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(removeSession_result.class, metaDataMap);
    }

    public removeSession_result() {
    }

    public removeSession_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeSession_result(removeSession_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public removeSession_result deepCopy() {
      return new removeSession_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public removeSession_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof removeSession_result))
        return false;
      removeSession_result that = (removeSession_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(removeSession_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("removeSession_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class killQuery_args implements TBase, java.io.Serializable, Cloneable, Comparable<killQuery_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("killQuery_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public KillQueryReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, KillQueryReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(killQuery_args.class, metaDataMap);
    }

    public killQuery_args() {
    }

    public killQuery_args(
        KillQueryReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public killQuery_args(killQuery_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public killQuery_args deepCopy() {
      return new killQuery_args(this);
    }

    public KillQueryReq getReq() {
      return this.req;
    }

    public killQuery_args setReq(KillQueryReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((KillQueryReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof killQuery_args))
        return false;
      killQuery_args that = (killQuery_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(killQuery_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new KillQueryReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("killQuery_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class killQuery_result implements TBase, java.io.Serializable, Cloneable, Comparable<killQuery_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("killQuery_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(killQuery_result.class, metaDataMap);
    }

    public killQuery_result() {
    }

    public killQuery_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public killQuery_result(killQuery_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public killQuery_result deepCopy() {
      return new killQuery_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public killQuery_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof killQuery_result))
        return false;
      killQuery_result that = (killQuery_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(killQuery_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("killQuery_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class reportTaskFinish_args implements TBase, java.io.Serializable, Cloneable, Comparable<reportTaskFinish_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("reportTaskFinish_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ReportTaskReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ReportTaskReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(reportTaskFinish_args.class, metaDataMap);
    }

    public reportTaskFinish_args() {
    }

    public reportTaskFinish_args(
        ReportTaskReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public reportTaskFinish_args(reportTaskFinish_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public reportTaskFinish_args deepCopy() {
      return new reportTaskFinish_args(this);
    }

    public ReportTaskReq getReq() {
      return this.req;
    }

    public reportTaskFinish_args setReq(ReportTaskReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ReportTaskReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof reportTaskFinish_args))
        return false;
      reportTaskFinish_args that = (reportTaskFinish_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(reportTaskFinish_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ReportTaskReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("reportTaskFinish_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class reportTaskFinish_result implements TBase, java.io.Serializable, Cloneable, Comparable<reportTaskFinish_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("reportTaskFinish_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ExecResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ExecResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(reportTaskFinish_result.class, metaDataMap);
    }

    public reportTaskFinish_result() {
    }

    public reportTaskFinish_result(
        ExecResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public reportTaskFinish_result(reportTaskFinish_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public reportTaskFinish_result deepCopy() {
      return new reportTaskFinish_result(this);
    }

    public ExecResp getSuccess() {
      return this.success;
    }

    public reportTaskFinish_result setSuccess(ExecResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ExecResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof reportTaskFinish_result))
        return false;
      reportTaskFinish_result that = (reportTaskFinish_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(reportTaskFinish_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ExecResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("reportTaskFinish_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listCluster_args implements TBase, java.io.Serializable, Cloneable, Comparable<listCluster_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listCluster_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public ListClusterInfoReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListClusterInfoReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listCluster_args.class, metaDataMap);
    }

    public listCluster_args() {
    }

    public listCluster_args(
        ListClusterInfoReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listCluster_args(listCluster_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public listCluster_args deepCopy() {
      return new listCluster_args(this);
    }

    public ListClusterInfoReq getReq() {
      return this.req;
    }

    public listCluster_args setReq(ListClusterInfoReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((ListClusterInfoReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listCluster_args))
        return false;
      listCluster_args that = (listCluster_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(listCluster_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new ListClusterInfoReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listCluster_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listCluster_result implements TBase, java.io.Serializable, Cloneable, Comparable<listCluster_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listCluster_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ListClusterInfoResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ListClusterInfoResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(listCluster_result.class, metaDataMap);
    }

    public listCluster_result() {
    }

    public listCluster_result(
        ListClusterInfoResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listCluster_result(listCluster_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public listCluster_result deepCopy() {
      return new listCluster_result(this);
    }

    public ListClusterInfoResp getSuccess() {
      return this.success;
    }

    public listCluster_result setSuccess(ListClusterInfoResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((ListClusterInfoResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof listCluster_result))
        return false;
      listCluster_result that = (listCluster_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(listCluster_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new ListClusterInfoResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("listCluster_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getMetaDirInfo_args implements TBase, java.io.Serializable, Cloneable, Comparable<getMetaDirInfo_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getMetaDirInfo_args");
    private static final TField REQ_FIELD_DESC = new TField("req", TType.STRUCT, (short)1);

    public GetMetaDirInfoReq req;
    public static final int REQ = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(REQ, new FieldMetaData("req", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetMetaDirInfoReq.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getMetaDirInfo_args.class, metaDataMap);
    }

    public getMetaDirInfo_args() {
    }

    public getMetaDirInfo_args(
        GetMetaDirInfoReq req) {
      this();
      this.req = req;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getMetaDirInfo_args(getMetaDirInfo_args other) {
      if (other.isSetReq()) {
        this.req = TBaseHelper.deepCopy(other.req);
      }
    }

    public getMetaDirInfo_args deepCopy() {
      return new getMetaDirInfo_args(this);
    }

    public GetMetaDirInfoReq getReq() {
      return this.req;
    }

    public getMetaDirInfo_args setReq(GetMetaDirInfoReq req) {
      this.req = req;
      return this;
    }

    public void unsetReq() {
      this.req = null;
    }

    // Returns true if field req is set (has been assigned a value) and false otherwise
    public boolean isSetReq() {
      return this.req != null;
    }

    public void setReqIsSet(boolean __value) {
      if (!__value) {
        this.req = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case REQ:
        if (__value == null) {
          unsetReq();
        } else {
          setReq((GetMetaDirInfoReq)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REQ:
        return getReq();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getMetaDirInfo_args))
        return false;
      getMetaDirInfo_args that = (getMetaDirInfo_args)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetReq(), that.isSetReq(), this.req, that.req)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {req});
    }

    @Override
    public int compareTo(getMetaDirInfo_args other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetReq()).compareTo(other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(req, other.req);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case REQ:
            if (__field.type == TType.STRUCT) {
              this.req = new GetMetaDirInfoReq();
              this.req.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.req != null) {
        oprot.writeFieldBegin(REQ_FIELD_DESC);
        this.req.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getMetaDirInfo_args");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("req");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getReq() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getReq(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getMetaDirInfo_result implements TBase, java.io.Serializable, Cloneable, Comparable<getMetaDirInfo_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getMetaDirInfo_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public GetMetaDirInfoResp success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap;

    static {
      Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
      tmpMetaDataMap.put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, GetMetaDirInfoResp.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
    }

    static {
      FieldMetaData.addStructMetaDataMap(getMetaDirInfo_result.class, metaDataMap);
    }

    public getMetaDirInfo_result() {
    }

    public getMetaDirInfo_result(
        GetMetaDirInfoResp success) {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getMetaDirInfo_result(getMetaDirInfo_result other) {
      if (other.isSetSuccess()) {
        this.success = TBaseHelper.deepCopy(other.success);
      }
    }

    public getMetaDirInfo_result deepCopy() {
      return new getMetaDirInfo_result(this);
    }

    public GetMetaDirInfoResp getSuccess() {
      return this.success;
    }

    public getMetaDirInfo_result setSuccess(GetMetaDirInfoResp success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been assigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean __value) {
      if (!__value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object __value) {
      switch (fieldID) {
      case SUCCESS:
        if (__value == null) {
          unsetSuccess();
        } else {
          setSuccess((GetMetaDirInfoResp)__value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object _that) {
      if (_that == null)
        return false;
      if (this == _that)
        return true;
      if (!(_that instanceof getMetaDirInfo_result))
        return false;
      getMetaDirInfo_result that = (getMetaDirInfo_result)_that;

      if (!TBaseHelper.equalsNobinary(this.isSetSuccess(), that.isSetSuccess(), this.success, that.success)) { return false; }

      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.deepHashCode(new Object[] {success});
    }

    @Override
    public int compareTo(getMetaDirInfo_result other) {
      if (other == null) {
        // See java.lang.Comparable docs
        throw new NullPointerException();
      }

      if (other == this) {
        return 0;
      }
      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, other.success);
      if (lastComparison != 0) { 
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField __field;
      iprot.readStructBegin(metaDataMap);
      while (true)
      {
        __field = iprot.readFieldBegin();
        if (__field.type == TType.STOP) { 
          break;
        }
        switch (__field.id)
        {
          case SUCCESS:
            if (__field.type == TType.STRUCT) {
              this.success = new GetMetaDirInfoResp();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, __field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, __field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      return toString(1, true);
    }

    @Override
    public String toString(int indent, boolean prettyPrint) {
      String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
      String newLine = prettyPrint ? "\n" : "";
      String space = prettyPrint ? " " : "";
      StringBuilder sb = new StringBuilder("getMetaDirInfo_result");
      sb.append(space);
      sb.append("(");
      sb.append(newLine);
      boolean first = true;

      sb.append(indentStr);
      sb.append("success");
      sb.append(space);
      sb.append(":").append(space);
      if (this.getSuccess() == null) {
        sb.append("null");
      } else {
        sb.append(TBaseHelper.toString(this.getSuccess(), indent + 1, prettyPrint));
      }
      first = false;
      sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

}
